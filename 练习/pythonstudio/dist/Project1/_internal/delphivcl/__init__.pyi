from typing import Any, Callable, ClassVar, Iterator, List

from typing import overload
import CustomButton
import CustomLinkLabel
import CustomStyleEngine
import CustomStyleServices
import StyleManager
Application: Application
IDABORT: int
IDCANCEL: int
IDCLOSE: int
IDCONTINUE: int
IDHELP: int
IDIGNORE: int
IDNO: int
IDOK: int
IDRETRY: int
IDTRYAGAIN: int
IDYES: int
MB_ABORTRETRYIGNORE: int
MB_APPLMODAL: int
MB_DEFBUTTON1: int
MB_DEFBUTTON2: int
MB_DEFBUTTON3: int
MB_DEFBUTTON4: int
MB_HELP: int
MB_ICONASTERISK: int
MB_ICONERROR: int
MB_ICONEXCLAMATION: int
MB_ICONHAND: int
MB_ICONINFORMATION: int
MB_ICONQUESTION: int
MB_ICONSTOP: int
MB_ICONWARNING: int
MB_NOFOCUS: int
MB_OK: int
MB_OKCANCEL: int
MB_RETRYCANCEL: int
MB_SYSTEMMODAL: int
MB_TASKMODAL: int
MB_YESNO: int
MB_YESNOCANCEL: int
Screen: Screen
bkAbort: int
bkAll: int
bkCancel: int
bkClose: int
bkCustom: int
bkHelp: int
bkIgnore: int
bkNo: int
bkOK: int
bkRetry: int
bkYes: int
caFree: int
caHide: int
caMinimize: int
caNone: int
cl3DDkShadow: int
cl3DLight: int
clActiveBorder: int
clActiveCaption: int
clAppWorkSpace: int
clAqua: int
clBackground: int
clBlack: int
clBlue: int
clBtnFace: int
clBtnHighlight: int
clBtnShadow: int
clBtnText: int
clCaptionText: int
clCream: int
clDefault: int
clDkGray: int
clFuchsia: int
clGradientActiveCaption: int
clGradientInactiveCaption: int
clGray: int
clGrayText: int
clGreen: int
clHighlight: int
clHighlightText: int
clHotLight: int
clInactiveBorder: int
clInactiveCaption: int
clInactiveCaptionText: int
clInfoBk: int
clInfoText: int
clLime: int
clLtGray: int
clMaroon: int
clMedGray: int
clMenu: int
clMenuBar: int
clMenuHighlight: int
clMenuText: int
clMoneyGreen: int
clNavy: int
clNone: int
clOlive: int
clPurple: int
clRed: int
clScrollBar: int
clSilver: int
clSkyBlue: int
clTeal: int
clWhite: int
clWindow: int
clWindowFrame: int
clWindowText: int
clYellow: int
crAppStart: int
crArrow: int
crCross: int
crDefault: int
crDrag: int
crHSplit: int
crHandPoint: int
crHelp: int
crHourGlass: int
crIBeam: int
crMultiDrag: int
crNo: int
crNoDrop: int
crNone: int
crSQLWait: int
crSize: int
crSizeAll: int
crSizeNESW: int
crSizeNS: int
crSizeNWSE: int
crSizeWE: int
crUpArrow: int
crVSplit: int
fmCreate: int
fmOpenRead: int
fmOpenReadWrite: int
fmOpenWrite: int
fmShareCompat: int
fmShareDenyNone: int
fmShareDenyRead: int
fmShareDenyWrite: int
fmShareExclusive: int
fsBorder: str
fsSurface: str
gdFixed: str
gdFocused: str
gdSelected: str
mdNearest: int
mdNull: int
mdPrimary: int
mrAbort: int
mrAll: int
mrCancel: int
mrIgnore: int
mrNo: int
mrNoToAll: int
mrNone: int
mrOk: int
mrRetry: int
mrYes: int
mrYesToAll: int
ssAlt: str
ssCtrl: str
ssDouble: str
ssLeft: str
ssMiddle: str
ssRight: str
ssShift: str

class Action(CustomAction):
    '''TAction is the base class for VCL action objects. TAction implements actions to be used with menu items and controls. The published properties and events of TAction actions can be managed in the Object Inspector at design time.
    The TAction class is almost the same as TCustomAction. TAction extends only the following features of TCustomAction:
    
    Changes the public scope to published for the AutoCheck, Caption, Checked, Enabled, GroupIndex, HelpType, HelpContext, HelpKeyword, Hint, ImageIndex, SecondaryShortCuts, ShortCut, and Visible properties.
    Sets the published scope for the OnExecute, OnUpdate, and OnHint events.
    The published scope of these properties and events provides the possibility to use the Object Inspector assistance for editing values of these properties and events.
    The DisableIfNoHandler property is set to True while an action is created, that is, the action is inaccessible if it does not have an OnExecute event handler.
    TAction is a generic action component. It can be added to action lists when there is no predefined action class that implements the desired response to user commands. Unlike predefined action classes, which have built-in methods that respond when users click the client controls, TAction has no built-in response to user commands. Instead, when using TAction, you can provide the response when the action "fires" by writing (using the Object Inspector\'s assistance) an OnExecute event handler, and configure the properties of TAction to reflect the current conditions by writing an OnUpdate event handler.
    Action objects are used to centralize the response to user commands (actions) and to represent user interface elements in applications that use action lists or action bands. 
    TAction can also act as a base class for predefined action classes. You can derive from TAction if you want to retain the published scope of the supported properties and events. If you want to use the public scope to some of the supported properties and events, you can derive from TCustomAction.
    For predefined actions that augment the behavior of TAction, see the action classes in the Vcl.StdActns, Vcl.DBActns, and Vcl.ExtActns units.'''
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    AutoCheck: bool
    """bool: Controls whether the Checked property toggles when the action executes.
        AutoCheck causes the Checked property to toggle when the action executes. This allows the Checked property of the action to remain in sync with the Checked property of the client (or an equivalent).
        If the client has an AutoCheck property of its own, the AutoCheck property of the action is propagated to the AutoCheck property of the client."""
    Caption: str
    """str: Represents the caption of the action.
        Caption holds the string that is used as the caption of the action, when it is set. The value of Caption can be propagated to all client controls and client menu items linked to the action."""
    Checked: bool
    """bool: Indicates whether client controls and menu items appear checked.
        Checked specifies the checked state for the action. The value of Checked can be propagated to all client controls and client menu items linked to the action.
        
        Note:  If the action has a GroupIndex value greater than 0, then setting Checked to True sets to False the Checked properties of all other actions in the GroupIndex group.
        Tip: Use the AutoCheck property to ensure that the action's Checked property toggles when the action executes."""
    Enabled: bool
    """bool: Specifies the enabled state for the action.
        The value of Enabled can be propagated to all client controls and client menu items linked to the action."""
    GroupIndex: int
    """int: Indicates a group of actions in one action list. Actions in this group act like the group of radio buttons.
        The value of GroupIndex is used to define groups of actions. Actions in each group act like groups of radio buttons. When GroupIndex is greater than 0, this value identifies the group to which some actions belong. The value of GroupIndex can be propagated to all client controls and client menu items linked to the action.
        When the Checked property of any action in that group is set to True, the Checked properties of all other actions in the group are set to False. That is, only one action in the group can be checked at a time.
        
        Note:  All actions in a group must be listed by the same action list."""
    HelpContext: int
    """int: Keeps the integer context ID that identifies the Help topic for the action.
        HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
        HelpContext is only used when htContext is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the action.
        The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
        HelpKeyword is only used when htKeyword is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property's value to invoke the online Help showing the topic with this keyword."""
    HelpType: HelpType
    """HelpType: Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
        The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
        HelpType can keep one of the following constants:
        
        htContext ? instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
        htKeyword ? instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help."""
    Hint: str
    """str: Stores the Help hint text.
        Hint holds the hint string indicating the hint text for the action.
        Hint contains the text strings that appear in a pop-up box (or in a status bar) when the user moves the mouse over screen elements.
        This hint string can be propagated to clients of the action ? to controls, menu items, and other GUI elements. 
        
        Note: VCL controls support hint strings containing three parts that can be shown in separate locations (see Vcl.Controls.TControl.Hint)."""
    ImageIndex: int
    """int: Stores an index in a list of images.
        ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
        The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 
        
        Note: When ImageIndex is -1, this means that the list does not contain any images.
        In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control's text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control's text is always drawn with the offset to the right to reserve a place for drawing an image."""
    ImageName: str
    """str: Displays the name of linked items from the Image Collection."""
    OnExecute: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnHint: Callable[[str,bool],None]
    """Callable[[str, bool], None]:"""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TAction.Create(AOwner: Component) -> None
        Creates and initializes a TAction object.
        Applications do not usually create action objects explicitly. Actions are created automatically when you add them to an action manager or action list component at design time. When instantiating TAction at run time, assign a TActionList or TActionManager component to the new action's ActionList property after calling Create.
        Create sets the DisableIfNoHandler to True, that is, the action is inaccessible if it does not have an OnExecute event handler."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ActionList(CustomActionList):
    """TActionList maintains a list of actions that can be used by components and controls such as menu items and buttons.
    Use Action lists to centralize the response to user commands (actions). Action list components maintain a list of actions that are available to the client controls in an application. Add action list components to your form or data module from the standard page of the component palette. Double-click the action list to display the Action List editor, from which you can add, delete, and rearrange actions.
    
    Note:  While it is  possible to maintain the actions for an application using TActionList, it can be simpler to use Vcl.ActnMan.TActionManager instead."""
    __hash__: ClassVar[None] = ...
    ActionCount: Any
    """Indicates the number of actions in the action list."""
    Actions: Any
    """Lists the actions maintained by the action list."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Images: CustomImageList
    """CustomImageList:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExecute: Callable[[BasicAction,bool],None]
    """Callable[[BasicAction, bool], None]:"""
    OnStateChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnUpdate: Callable[[BasicAction,bool],None]
    """Callable[[BasicAction, bool], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    State: ActionListState
    """ActionListState: Indicates whether the actions in the action list respond when the user triggers a client object. 
        State can be one of the constants defined in the TActionListState type: 
        asNormal, asSuspended, and asSuspendedEnabled."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ActivityIndicator(CustomActivityIndicator):
    """An animated rotating display indicating that the application is performing some activity.
    Create the activity indicator, set the color, size and type, and set the Animate property to True to start the animation. You can modify the speed of the animation with the FrameDelay property."""
    __hash__: ClassVar[None] = ...
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    Animate: bool
    """bool: Specifies whether the activity indicator is currently animated.
        Default is False."""
    FrameDelay: int
    """int: Specifies how fast the activity indicator displays its animation sequence.
        Set this property to a lower value to speed up the animation."""
    IndicatorColor: ActivityIndicatorColor
    """ActivityIndicatorColor: The color of the activity indicator.
        Possible values are:
        
        aicBlack: Default. The elements of the indicator are black.
        aicWhite: The elements of the indicator are white."""
    IndicatorSize: ActivityIndicatorSize
    """ActivityIndicatorSize: The size of the activity indicator.
        Possible values are:
        
        aisSmall: 24 x 24 pixels.
        aisMedium: Default. 32 x 32 pixels.
        aisLarge: 48 x 48 pixels.
        aisXLarge: 64 x 64 pixels."""
    IndicatorType: ActivityIndicatorType
    """ActivityIndicatorType: The type of the activity indicator.
        Possible values are:
        
        aitMomentumDots : Default. Traditional Windows 8/10 rotating sequence of dots, accelerating and deccelerating in a circular pattern.
        aitRotatingSector : Alternating sectors of a segmented ring are highlighted in sequence to indicate activity.
        aitSectorRing : Sectors of a segmented ring are highlighted in sequence until the ring is completely highlighted. On the next pass, each sector is displayed in a dimmed state."""
    Parent: Any
    """Returns/Sets the Control Parent"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BaseBindScopeComponent(Component):
    """Base class for the binding scope component. TBaseBindScopeComponent is the ancestor for the TCustomBindScope component. TBaseBindScopeComponent provides functionality for adding scope mappings, getting scope members and values, returning the scope itself or the scope of a member. It also provides properties for accessing the binding expressions in this scope and the scope mappings."""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TBaseBindScopeComponent.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Data.Bind.Components.TBaseBindScopeComponent.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Data.Bind.Components.TBaseBindScopeComponent.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BaseImageList(Component):
    """Wrapper for Delphi TBaseImageList"""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Count: int
    """int:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def BeginUpdate(self, *args, **kwargs) -> Any: ...
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Change(self, *args, **kwargs) -> Any: ...
    def EndUpdate(self, *args, **kwargs) -> Any: ...
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BaseLinkingBindSource(BaseBindScopeComponent):
    """Base class for scope with supports linking"""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BaseObjectBindSource(BaseLinkingBindSource):
    """Is a bind source that supports adapters to connect to different types of data.
    The TBaseObjectBindSource class implements a bind source that supports adapters to connect to different types of data. The adapter can be provided by setting a property (InternalAdapter) or by implementing the OnCreateAdapter event."""
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool: Specifies whether the bind source adapter is active. 
        Read Active to determine whether the bind source adapter is active. By default, the Active property is set to True.
        When Active is False, the bind source does not have an adapter or its adapter is not active. When Active is True, the bind source has an active adapter."""
    AutoActivate: bool
    """bool: Specifies whether the bind source is automatically activated.  Set AutoActive to True for automatic activation."""
    BOF: Any
    """bool: Indicates whether the bind source adapter is positioned in the first record.
        Read BOF (beginning of file) to determine if ItemIndex is located in the first record. If BOF is True, the bind source has an adapter and the active record is the first one. BOF is also True if there is no active record. BOF is False in all other cases."""
    CanModify: bool
    """bool: Specifies whether the bind source has permission to modify the data.
        Check CanModify to determine if data can be edited. When CanModify is set to True, the bind source can edit the data. When CanModify is set to False, the bind source cannot edit the data."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Editing: bool
    """bool: Indicates whether the data is in edit mode. 
        Read Editing to determine whether the bind source adapter can currently edit the data. If the Editing property is True, the data provided by the bind source adapter is in editing mode. Otherwise, it is False."""
    Eof: Any
    """bool: Indicates whether the bind source adapter is positioned in the last record. 
        Read Eof (end of file) to determine if ItemIndex is located in the last record. If Eof is True, the bind source has an adapter and the active record is the last one or there are no records. Eof is False if the ItemIndex is located in any other position."""
    InternalAdapter: BindSourceAdapter
    """BindSourceAdapter: Returns the internal adapter of the bind source. 
        The InternalAdapter property holds the internal adapter of the bind source. InternalAdapter uses the GetInternalAdapter method to return the internal adapter of the bind source.
        
        Note:  The GetInternalAdapter method always returns nil. Descendant classes must override this method to return the internal adapter."""
    ItemIndex: int
    """int: Specifies the index of the current record. 
        ItemIndex holds the index of the current record of the dataset the bind source adapter is currently on. The first item has the index 0, the second item has the index 1, and so on. If no item is selected, the value of ItemIndex is -1."""
    Members: Object
    """Object:"""
    OnCreateAdapter: Callable[[Object,BindSourceAdapter],None]
    """Callable[[Object, BindSourceAdapter], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyUpdates(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Cancel(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def CancelUpdates(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Create(self, AOwner: Component) -> None:
        """TBaseObjectBindSource.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Data.Bind.ObjectScope.TBaseObjectBindSource.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Delete(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Data.Bind.ObjectScope.TBaseObjectBindSource.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Edit(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def First(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetFormatLink(self, AFieldName: str) -> IEditFormatLink:
        """TBaseObjectBindSource.GetFormatLink(AFieldName: str) -> IEditFormatLink
        Embarcadero Technologies does not currently have any additional information."""
    def GetMember(self, AMemberName: str) -> Object:
        """TBaseObjectBindSource.GetMember(AMemberName: str) -> Object
        Returns the member for the given member name.
        Data.Bind.ObjectScope.TBaseObjectBindSource.GetMember inherits from Data.Bind.Components.TBaseBindScopeComponent.GetMember. All content below this line refers to Data.Bind.Components.TBaseBindScopeComponent.GetMember.
        Returns the member for the given member name.
        The GetMember method returns the scope member, as a TObject, for the member name given through the AMemberName parameter. This member is later used in the generated bindings expressions.
        
        Tip: This member object or its properties may be referenced by bindings expressions."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def Insert(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def IsRequired(self, AFieldName: str) -> bool:
        """TBaseObjectBindSource.IsRequired(AFieldName: str) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def IsValidChar(self, AFieldName: str, AChar) -> bool:
        """TBaseObjectBindSource.IsValidChar(AFieldName: str, AChar: unicodechr(str)) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def Last(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Locate(self, KeyFields: str, KeyValues: Value) -> bool:
        """TBaseObjectBindSource.Locate(KeyFields: str, KeyValues: Value) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def Lookup(self, KeyFields: str, KeyValues: Value, ResultFields: str) -> Value:
        """TBaseObjectBindSource.Lookup(KeyFields: str, KeyValues: Value, ResultFields: str) -> Value
        Embarcadero Technologies does not currently have any additional information."""
    def Next(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Post(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Prior(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Refresh(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BasicAction(Component):
    """TBasicAction is the ancestor class for all action objects.
    TBasicAction introduces the fundamental behavior for an action. Descendants of TBasicAction add functionality for containment in an action list, for being categorized, and for specializing their behavior tailored to particular clients such as controls or menu items. Use TBasicAction if you want to create an action for an object that is neither a menu item nor a control."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    OnExecute: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnUpdate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TBasicAction.Create(AOwner: Component) -> None
        Instantiates and initializes a TBasicAction object.
        Applications do not need to instantiate TBasicAction directly. Actions are created automatically when you choose New Action in the Action List editor.
        If you want to create an action at run time, you should call the Create constructor of a FireMonkey action (FMX.ActnList.TAction) or VCL action (Vcl.ActnList.TAction), or any of their subclasses. The Create constructors assign a TActionList component to the ActionList property of the created action.
        Create calls the inherited constructor and then creates a list of clients of the created action."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of an instance of a TBasicAction object.
        You do not need to call the destructor for an action. An action is a component and is automatically destroyed by its owner, which was passed to the constructor when it is created. If you must destroy an action manually, call Free instead, which safely invokes the destructor."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def ExecuteTarget(self, Target: Object) -> None:
        """TBasicAction.ExecuteTarget(Target: Object) -> None
        Introduces an interface for invoking an action on a target client component or control.
        ExecuteTarget does nothing in TBasicAction. ExecuteTarget was introduced in TBasicAction so that descendants can override it to initiate the action on the target. For example, an edit action that performs copying might copy the contents of an edit control to the clipboard."""
    def HandlesTarget(self, Target: Object) -> bool:
        """TBasicAction.HandlesTarget(Target: Object) -> bool
        Introduces an interface for verifying that the type and state of a target component or control are appropriate for the action.
        HandlesTarget does nothing in TBasicAction. HandlesTarget was introduced in TBasicAction so that descendants can override it to check the type and state of a target. HandlesTarget can verify any information about a target that is relevant for the action. HandlesTarget returns True if the target meets the specified criteria, False otherwise."""
    def Suspended(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def UpdateTarget(self, Target: Object) -> None:
        """TBasicAction.UpdateTarget(Target: Object) -> None
        Introduces an interface for a method of notifying a client when the action updates itself.
        UpdateTarget does nothing in TBasicAction. UpdateTarget was introduced in TBasicAction so that descendants can override it to correspondingly update a target when the action updates."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BasicBindComponent(Component):
    """Wrapper for Delphi TBasicBindComponent"""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Bevel(Control):
    """Wrapper for Delphi TBevel"""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    Shape: BevelShape
    """BevelShape:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Style: BevelStyle
    """BevelStyle:"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TBevel.Create(AOwner: Component) -> None
        Creates an instance of TControl.
        Calling Create constructs and initializes an instance of TControl. However, you should never attempt to instantiate a TControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants.
        Create calls the parent constructor and initializes the control. 
        When overriding Create, always call the inherited Create method first, then proceed with the control's initialization. Remember to specify the override directive when overriding the Create method.
        
        Note:  If a control's constructor allocates resources or memory, also override the destructor to free those resources."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BindComponentDelegate(ContainedBindComponent):
    """Is a binding component that wraps one or more other binding components."""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    OnActivated: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnActivating: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnAssignedValue: Callable[[Object,BindingAssignValueRec,Value],None]
    """Callable[[Object, BindingAssignValueRec, Value], None]:"""
    OnAssigningValue: Callable[[Object,BindingAssignValueRec,Value,bool],None]
    """Callable[[Object, BindingAssignValueRec, Value, bool], None]:"""
    OnEvalError: Callable[[Object,Exception],None]
    """Callable[[Object, Exception], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetDelegates(self, *args, **kwargs) -> Any:
        """Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BindingsList(CustomBindingsList):
    """Implements the bindings list component. TBindingsList is built on the TCustomBindingsList component and publishes additional properties that can be accessed from within the Object Inspector."""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Methods: Methods
    """Methods: Specifies a list of available methods. For more information about these methods, read the LiveBindings Methods topic."""
    OutputConverters: OutputConverters
    """OutputConverters: Specifies a list of available output converters. For more information about output converters, read the LiveBindings Output Converters help topic."""
    Owner: Any
    """Returns the Component Owner"""
    PromptDeleteUnused: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseAppManager: bool
    """bool: Specifies whether the bindings list uses the global application manager for managed bindings."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BitBtn(WinControl):
    """TBitBtn is a push button control that can include a bitmap on its face.
    Bitmap buttons exhibit the same behavior as button controls. Use them to initiate actions from forms and dialog boxes.
    Bitmap buttons implement properties that specify the bitmap images, along with their appearance and placement on the button. You can choose from predefined bitmap buttons styles or use your own customized bitmap for the button. Although the button can be associated with only one bitmap, the bitmap (glyph property) can be subdivided into four equal-sized portions, which are displayed based on the state of the button: up, down, disabled, and clicked.
    The Kind property of TBitBtn provides commonly used buttons, such as OK, Cancel, Help, and so on. These predefined button types have corresponding graphical images and default behaviors, so you can easily add them to your application with little or no coding necessary.
    The recommended way to implement the response of other button kinds to user clicks is to assign an action from an action list as the value of the Action property. By setting the Action property, you make the button a client of the action, and the action handles updating the button's properties and responding when the user clicks the button.
    If you are not using the built-in response to a specific kind of button or an action to respond when the user clicks the button, then you can specify the button's response by writing an OnClick event handler."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Cancel: bool
    """bool:"""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Default: bool
    """bool:"""
    DisabledImageIndex: int
    """int:"""
    DisabledImageName: str
    """str:"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Glyph: Bitmap
    '''Bitmap: Specifies the bitmap that appears on the bitmap button.
        Use the Open dialog box that appears as an editor in the Object Inspector to choose a bitmap file (with a .BMP extension) to use on the button, or specify a TBitmap object at runtime.
        You can provide up to four images within a single bitmap. All images must be the same size and next to each other in a row. Bit buttons display one of these images depending on their state.
        
        
        
        
        
        Image position
        
        Button state
        
        Description
        
        
        
        First
        
        
        
        Up
        
        
        
        This image appears when the button is up (unselected). This image is also used when the button has focus (for example, if the user tabs to it); in this case, a focus rectangle is drawn around the button. If no other images exist in the bitmap, bit buttons also use this image for all other states.
        
        
        
        
        Second
        
        
        
        Disabled
        
        
        
        This image usually appears dimmed to indicate that the button can\'t be selected.
        
        
        
        
        Third
        
        
        
        Clicked
        
        
        
        This image appears when the button is clicked. The Up image reappears when the user releases the mouse button.
        
        
        
        
        Fourth
        
        
        
        Down
        
        
        
        This image appears when the button stays down (indicating that it remains selected).
        
        
        
        
        If only one image is present, bit buttons attempt to represent the other states by altering the image slightly for the different states, although the Down state is always the same as the Up state. If you aren\'t satisfied with the results, you can provide additional images in the bitmap.
        If you have multiple images in a bitmap, you must specify the number of images that are in the bitmap with the Num Glyphs property.
        
        Note:  The lower left pixel of the bitmap is reserved for the "transparent" color. Any pixel in the bitmap which matches that lower left pixel will be transparent.'''
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HotImageIndex: int
    """int:"""
    HotImageName: str
    """str:"""
    ImageIndex: int
    """int:"""
    ImageName: str
    """str:"""
    Images: CustomImageList
    """CustomImageList:"""
    Kind: BitBtnKind
    """BitBtnKind: Specifies the kind of bitmap button.
        Use Kind to specify the appearance of the TBitBtn control and its response when the user clicks the button. A standard set of buttons are included and operate as expected without the addition of code. However, you can write additional code in the button events, if you want to. This does not include the Custom button kind, which can be programmed in any way you like.
        The images (such as the green check mark on the OK button) appear on the button when using this version of TBitBtn."""
    Layout: ButtonLayout
    """ButtonLayout: Specifies where the image appears on the bitmap button.
        Layout indicates whether the text appears on the left of the button (blGlyphLeft), the right of the button (blGlyphRight), the top (blGlyphTop) or the bottom (blGlyphBottom)."""
    Margin: int
    """int: Specifies the number of pixels between the edge of the image (specified in the Glyph property) and the edge of the button.
        The margin is the space between the image edge and the button edge. The format of the edges depends on the layout of the image and text (specified in the Layout property). For example, if Layout is blGlyphLeft, the margin appears between the left edge of the image and the left edge of the button. If Margin is 3, three pixels separate the image and the button edges. If Margin is 0, there is no space between the image and the button edges.
        If Margin is -1 (the default value), the image and text (specified in the Caption property) are centered. The number of pixels between the image and button edge is equal to the number of pixels between the opposite edge of the button and the text."""
    ModalResult: int
    """int:"""
    NumGlyphs: int
    """int: Indicates the number of images that are in the graphic specified in the Glyph property.
        If you have multiple images in a bitmap, you must specify the number of images that are in the bitmap with the NumGlyphs property. The default value is 1."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    PressedImageIndex: int
    """int:"""
    PressedImageName: str
    """str:"""
    SelectedImageIndex: int
    """int:"""
    SelectedImageName: str
    """str:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    Spacing: int
    """int: Determines where the image and text appear on a bitmap or speed button.
        Spacing determines the number of pixels between the image (specified in the Glyph property) and the text (specified in the Caption property). The default value is 4 pixels.
        If Spacing is a positive number, its value is the number of pixels between the image and text. If Spacing is 0, no pixels will be between the image and text. If Spacing is -1, the text appears centered between the image and the button edge. The number of pixels between the image and text is equal to the number of pixels between the text and the button edge opposite the glyph."""
    Style: ButtonStyle
    """ButtonStyle: Determines the appearance of a bitmap button.
        Style indicates whether the TBitBtn control uses the modern button look, or reflects the look of a 16-bit Windows pushbutton."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    WordWrap: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Click(self, *args, **kwargs) -> Any:
        """Simulates a mouse click, as if the user had clicked the button.
        Use Click to simulate a mouse click. Click performs the following tasks:
        
        If the value of the Kind property is bkClose, Click closes the form.
        If the value of Kind is bkHelp, Click displays the Help screen assigned with the HelpContext property.
        Any associated action fires, or, if there is no associated action, any code attached to the OnClick event is executed."""
    def Create(self, AOwner: Component) -> None:
        """TBitBtn.Create(AOwner: Component) -> None
        Constructs an instance of the button control and initializes its values.
        Use Create to programmatically instantiate a button. Buttons added using the form designer are created automatically.
        The AOwner parameter specifies the component, typically a form, that is responsible for freeing the button."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the bitmap button object.
        Do not call Destroy directly in an application. Instead, call Free. Free checks that the bitmap button is not nil, and only then calls Destroy."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Bitmap(Graphic):
    """TBitmap is an encapsulation of a Windows bitmap (HBITMAP), including its palette (HPALETTE).
    A bitmap is a powerful graphics object used to create, manipulate and store images in memory and as files on a disk.
    TBitmap contains an internal image of the bitmap graphic and automatically manages realization of the palette when drawn. 
    To draw a bitmap on a canvas, call the Draw or StretchDraw methods of a TCanvas object, passing a TBitmap as a parameter.
    Creating copies of a TBitmap is very fast since the handle is copied rather than the image. If the image is modified and the handle is shared by more than one TBitmap object, the image is copied before the modification is performed (that is, copy on write)."""
    __hash__: ClassVar[None] = ...
    AlphaFormat: AlphaFormat
    """AlphaFormat: Indicates how reserved byte of each pixel is used in 32 bit bitmaps.
        Use AlphaFormat to change the way a TBitmap uses the reserved byte of each pixel in a 32bit Bitmap."""
    Canvas: Any
    Handle: Any
    HandleType: Any
    IgnorePalette: Any
    MaskHandle: Any
    Monochrome: Any
    PixelFormat: Any
    ScanLine: Pointer
    """Pointer:"""
    TransparentColor: Any
    TransparentMode: Any
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, Source: Persistent) -> None:
        """TBitmap.Assign(Source: Persistent) -> None
        Copies a new bitmap image to the bitmap object.
        Assign copies the bitmap image contained in Source to the bitmap object. If Source is not a bitmap, Assign calls the inherited Assign method, which can copy an image from any class that knows how to copy to a TBitmap object. If the bitmap needs to be changed, the actual bitmap image is copied before the changes are made (copy on write).
        
        Note:  An object of one type can always be assigned to another object of the same type. Also, the Source can be of type TPicture if the Graphic property of the picture is a bitmap."""
    @classmethod
    def CanLoadFromStream(cls, Stream: Stream) -> bool:
        """TBitmap.CanLoadFromStream(Stream: Stream) -> bool
        Vcl.Graphics.TBitmap.CanLoadFromStream inherits from Vcl.Graphics.TGraphic.CanLoadFromStream. All content below this line refers to Vcl.Graphics.TGraphic.CanLoadFromStream.
        CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
        The method uses current stream position, it does not change current stream position."""
    def Create(self, *args, **kwargs) -> Any:
        """Instantiates a bitmap object.
        Call Create to instantiate a bitmap object at runtime. Create is also called automatically when a bitmap image is loaded into a TImage.
        Create allocates memory for a bitmap object, and calls the inherited Create. Then it creates a TBitmapImage as the internal image that represents the bitmap.\r
        Instantiates a bitmap object.
        Call Create to instantiate a bitmap object at runtime. Create is also called automatically when a bitmap image is loaded into a TImage.
        Create allocates memory for a bitmap object, and calls the inherited Create. Then it creates a TBitmapImage as the internal image that represents the bitmap."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the instance of the bitmap object.
        Destroy is the destructor for a TBitmap object.
        Do not call the destructor directly in an application. Instead, call Free. Free verifies that the bitmap object is not nil before it calls Destroy.
        Destroy releases the internal bitmap image (TBitmapImage object) and frees the canvas before calling the inherited destructor."""
    def Dormant(self) -> Any:
        """TBitmap.Dormant()"""
    def FreeImage(self) -> Any:
        """TBitmap.FreeImage()"""
    def HandleAllocated(self, *args, **kwargs) -> Any:
        """Indicates whether the TBitmap object has acquired a handle to the underlying GDI object.
        Use HandleAllocated to determine whether the Handle property is set to an HBITMAP value. HandleAllocated indicates whether the underlying GDI object has already been created. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, it automatically creates a bitmap and returns its handle if the underlying GDI object does not already exist."""
    def LoadFromClipboardFormat(self, AFormat: int, AData: int, APalette: int) -> None:
        """TBitmap.LoadFromClipboardFormat(AFormat: int, AData: int, APalette: int) -> None
        Loads a bitmap from the Clipboard into the bitmap object.
        LoadFromClipboardFormat is called if the bitmap is registered with the TPicture object using the RegisterClipboardFormat method.
        LoadFromClipboardFormat replaces the current image with the data pointed to by the AData parameter. The palette for the bitmap is specified by the APalette parameter.
        The following code snippet shows how to load a bitmap from the clipboard and use that picture to draw on the canvas of the form.
        
        Note: To load a bitmap into the clipboard, you can use the code snippet for the SaveToClipboardFormat method.
        
        Delphi:
        
        uses
          Vcl.Clipbrd;
        
        procedure TForm1.Button1Click(Sender: TObject);
        var
          Bitmap : TBitmap;
        begin
         Bitmap := TBitMap.Create;
         try
           Bitmap.LoadFromClipBoardFormat(cf_BitMap, ClipBoard.GetAsHandle(cf_Bitmap), 0);
           Canvas.draw(0,0,Bitmap);
         finally
           Bitmap.Free;
           Clipboard.Clear;
         end;
        end;
        
        
        
        C++:
        
        #include <Vcl.Clipbrd.hpp>
        
        void __fastcall TForm1::Button1Click(TObject *Sender){
        \tTBitmap* Bitmap;
        \tTClipboard* cb = Clipboard();
        
        \tBitmap = new TBitmap();
        \ttry{
        \t\tBitmap->LoadFromClipboardFormat(CF_BITMAP, cb->GetAsHandle(CF_BITMAP), 0);
        \t\tCanvas->Draw(0,0,Bitmap);
        \t}
        \t__finally{
        \t\tdelete Bitmap;
        \t\tcb->Clear();
        \t}
        }"""
    def LoadFromResourceID(self) -> Any:
        """TBitmap.LoadFromResourceID()"""
    def LoadFromResourceName(self) -> Any:
        """TBitmap.LoadFromResourceName()"""
    def LoadFromStream(self, Stream: Stream) -> None:
        """TBitmap.LoadFromStream(Stream: Stream) -> None
        Loads the bitmap from a stream into the bitmap object.
        Use LoadFromStream to load the bitmap image from a stream. The Stream parameter specifies the stream from which to read the bitmap image. For example, use LoadFromStream to load a bitmap image from a BLOB stream that reads from a graphic field in a dataset."""
    def Mask(self) -> Any:
        """TBitmap.Mask()"""
    def ReleaseHandle(self) -> Any:
        """TBitmap.ReleaseHandle()"""
    def ReleaseMaskHandle(self) -> Any:
        """TBitmap.ReleaseMaskHandle()"""
    def ReleasePalette(self) -> Any:
        """TBitmap.ReleasePalette()"""
    def SaveToClipboardFormat(self, Format: int, Data: int, APalette: int) -> None:
        '''TBitmap.SaveToClipboardFormat(Format: int, Data: int, APalette: int) -> None
        Creates a local copy of the bitmap in Clipboard format.
        Use SaveToClipboardFormat to copy the bitmap to a Clipboard format. The bitmap\'s palette is returned in the APalette parameter, the format in the AFormat parameter, and a handle to the data in the AData parameter. Before the bitmap can be saved, an application must have registered the format with the TBitmap object using the RegisterClipboardFormat method.
        The following code snippet shows how to save a bitmap to the clipboard.
        
        Note: To load a bitmap from the clipboard, you can use the code snippet for the LoadFromClipboardFormat method.
        
        Delphi:
        
        uses
          Vcl.Clipbrd;
        
        procedure TForm1.Button1Click(Sender: TObject);
        var
          MyFormat : Word;
          Bitmap : TBitMap;
          AData : THandle;
          APalette : HPALETTE;
        begin
          Bitmap := TBitmap.Create;
          try
            Bitmap.LoadFromFile(\'C:\\Users\\Public\\Pictures\\Sample Pictures\\desert.bmp\');
            Bitmap.SaveToClipBoardFormat(MyFormat, AData, APalette);
            ClipBoard.SetAsHandle(MyFormat,AData);
          finally
            Bitmap.Free;
          end;
        end;
        
        
        
        C++:
        
        #include <Vcl.Clipbrd.hpp>
        
        void __fastcall TForm1::Button1Click(TObject *Sender){
        \tTClipboard* cb = Clipboard();
        \tunsigned short MyFormat;
        \tTBitmap* Bitmap;
        \tunsigned int AData;
        \tHPALETTE APalette;
        
        \tBitmap = new TBitmap();
        \ttry{
        \t\tBitmap->LoadFromFile("C:\\\\Users\\\\Public\\\\Pictures\\\\Sample Pictures\\\\desert.bmp");
        \t\tBitmap->SaveToClipboardFormat(MyFormat, AData, APalette);
        \t\tcb->SetAsHandle(MyFormat, AData);
        \t}
        \t__finally{
        \t\tdelete Bitmap;
        \t}
        }'''
    def SaveToStream(self, Stream: Stream) -> None:
        """TBitmap.SaveToStream(Stream: Stream) -> None
        Saves the bitmap to a stream.
        Use SaveToStream to write the bitmap image to the stream specified by the Stream parameter. For example, specify a TBlobStream object as the Stream parameter to save the bitmap image to a graphic field in a dataset."""
    def SetSize(self, AWidth: int, AHeight: int) -> None:
        """TBitmap.SetSize(AWidth: int, AHeight: int) -> None
        Specifies the size of the bitmap.
        Use the SetSize method to set both the height and width of the bitmap. This results in better performance than setting the height and width separately."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BoundLabel(Control):
    '''TBoundLabel is the type of a labeled edit control\'s label.
    TBoundLabel implements the label of a labeled edit control. Unlike other label controls such as TLabel, TBoundLabel "belongs" to the labeled edit control (it is a subcomponent of the edit control). This means that the bound label\'s Owner is the edit control rather than the form, and the edit control is responsible for loading and saving the bound label.
    Use the properties of TBoundLabel to specify how you want the labeled edit control\'s label to appear. For example, you can use the Caption property to specify the text that appears in the label. You can use the Alignment and Layout properties to specify the placement of that caption within the label.'''
    __hash__: ClassVar[None] = ...
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    IsLabelModified: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Layout: TextLayout
    """TextLayout:"""
    Left: int
    """int: Specifies the horizontal coordinate of the left edge of a component relative to its parent.
        Use the Left property to determine where the left side of the control begins or to reposition the left side of the control.
        If the control is contained in another control, the Left and Top properties are relative to the parent control. If the control is contained directly by the form, the property values are relative to the form. For forms, the value of the Left property is relative to the screen in pixels."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowAccelChar: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Top: int
    """int: Specifies the Y coordinate of the upper-left corner of a control, relative to its parent or containing control in pixels.
        Use Top to locate the top of the control or reposition the control to a different Y coordinate. The Top property, like the Left property, is the position of the control relative to its container. Thus, if a control is contained in a TPanel, the Left and Top properties are relative to the panel. If the control is contained directly by the form, it is relative to the form. For forms, the value of the Top property is relative to the screen in pixels."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Transparent: bool
    """bool:"""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    WordWrap: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TBoundLabel.Create(AOwner: Component) -> None
        Creates a new TBoundLabel object.
        Do not create instances of TBoundLabel. Bound labels are instantiated by the labeled edit controls to which they belong.
        AOwner specifies the labeled edit control that acts as the bound label's Owner."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BufferedFileStream(FileStream):
    """TBufferedFileStream adds buffering support to TFileStream.
    TBufferedFileStream optimizes multiple consecutive small reads or writes. However, TBufferedFileStream can be used as a drop-in replacement for TFileStream, enabling applications to read from and write to a file on a disk.
    
    Note: TBufferedFileStream will not give performance gain for random position reads or writes, or large reads or writes."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AFileName: str, Mode: int, BufferSize: int) -> None:
        """TBufferedFileStream.Create(AFileName: str, Mode: int, BufferSize: int) -> None
        Creates an instance of TBufferedFileStream.
        Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
        The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or'ed together. The open mode must be one of the following values:
        
        
        
        Value
        
        Meaning
        
        Declared In
        
        
        
        fmCreate
        
        
        
        Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.
        
        
        
        System.Classes
        
        
        
        
        fmOpenRead
        
        
        
        Open the file for reading only.
        
        
        
        System.SysUtils
        
        
        
        
        fmOpenWrite
        
        
        
        Open the file for writing only. Writing to the file completely replaces the current contents.
        
        
        
        System.SysUtils
        
        
        
        
        fmOpenReadWrite
        
        
        
        Open the file to modify the current contents rather than replace them.
        
        
        
        System.SysUtils
        
        
        
        The share mode must be one of the following values:
        
        
        
        Value
        
        Meaning
        
        Declared In
        
        
        
        fmShareCompat
        
        
        
        Sharing is compatible with the way FCBs are opened.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareExclusive
        
        
        
        Other applications cannot open the file for any reason.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyWrite
        
        
        
        Other applications can open the file for reading but not for writing.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyRead
        
        
        
        Other applications can open the file for writing but not for reading.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyNone
        
        
        
        No attempt is made to prevent other applications from reading from or writing to the file.
        
        
        
        System.SysUtils
        
        
        Note: On Windows, the Rights parameter is ignored.
        The BufferSize parameter determines the size of the buffer used to read from or write to the file.
        If the file cannot be opened, Create raises an exception.\r
        Creates an instance of TBufferedFileStream.
        Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
        The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or'ed together. The open mode must be one of the following values:
        
        
        
        Value
        
        Meaning
        
        Declared In
        
        
        
        fmCreate
        
        
        
        Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.
        
        
        
        System.Classes
        
        
        
        
        fmOpenRead
        
        
        
        Open the file for reading only.
        
        
        
        System.SysUtils
        
        
        
        
        fmOpenWrite
        
        
        
        Open the file for writing only. Writing to the file completely replaces the current contents.
        
        
        
        System.SysUtils
        
        
        
        
        fmOpenReadWrite
        
        
        
        Open the file to modify the current contents rather than replace them.
        
        
        
        System.SysUtils
        
        
        
        The share mode must be one of the following values:
        
        
        
        Value
        
        Meaning
        
        Declared In
        
        
        
        fmShareCompat
        
        
        
        Sharing is compatible with the way FCBs are opened.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareExclusive
        
        
        
        Other applications cannot open the file for any reason.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyWrite
        
        
        
        Other applications can open the file for reading but not for writing.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyRead
        
        
        
        Other applications can open the file for writing but not for reading.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyNone
        
        
        
        No attempt is made to prevent other applications from reading from or writing to the file.
        
        
        
        System.SysUtils
        
        
        Note: On Windows, the Rights parameter is ignored.
        The BufferSize parameter determines the size of the buffer used to read from or write to the file.
        If the file cannot be opened, Create raises an exception."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys this instance of TBufferedFileStream."""
    def FlushBuffer(self, *args, **kwargs) -> Any:
        """Writes the buffered data that have not yet been written to the file.
        When using a buffered file stream, call FlushBuffer to write to the file the data from the buffer that are still not written.
        Once you call FlushBuffer, the buffer will remain empty until the next read or write operation."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def Read(self, Buffer, Count: int) -> int:
        """TBufferedFileStream.Read(Buffer, Count: int) -> int
        Reads up to Count bytes of data from the resource associated with the handle stream into Buffer.
        System.Classes.TBufferedFileStream.Read inherits from System.Classes.THandleStream.Read. All content below this line refers to System.Classes.THandleStream.Read.
        Reads up to Count bytes of data from the resource associated with the handle stream into Buffer.
        Use Read to read data from the resource associated with the handle stream when the number of bytes in the file is not known. Read transfers up to Count bytes from the resource, starting at the current position, and then advances the current position in the resource by the number of bytes actually transferred. Read returns the number of bytes actually transferred, which may be less than Count if the end of file marker is encountered.
        All other data-reading methods of a handle stream (ReadBuffer, ReadComponent) call Read to do the actual reading."""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def Seek(self, Offset: int, Origin: SeekOrigin) -> int:
        """TBufferedFileStream.Seek(Offset: int, Origin: SeekOrigin) -> int
        Resets the current position of the handle stream.
        System.Classes.TBufferedFileStream.Seek inherits from System.Classes.THandleStream.Seek. All content below this line refers to System.Classes.THandleStream.Seek.
        Resets the current position of the handle stream.
        Use Seek to move the current position within the resource associated with the handle stream by the indicated offset. Seek allows an application to read from or write to a particular location within the resource.
        The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        soFromBeginning
        
        
        
        Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be >= 0.
        
        
        
        
        soFromCurrent
        
        
        
        Offset is from the current position in the resource. Seek moves to Position + Offset.
        
        
        
        
        soFromEnd
        
        
        
        Offset is from the end of the resource. Offset must be <= 0 to indicate a number of bytes before the end of the file.
        
        
        Or you can also use TSeekOrigin and its values to indicate where to start a seek operation.
        Seek returns the new value of the Position property, the new current position in the resource."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """TBufferedFileStream.Write(Buffer, Count: int) -> int
        Writes Count bytes from the Buffer to the current position in the resource.
        System.Classes.TBufferedFileStream.Write inherits from System.Classes.THandleStream.Write. All content below this line refers to System.Classes.THandleStream.Write.
        Writes Count bytes from the Buffer to the current position in the resource.
        Use Write to write Count bytes to the resource associated with the handle stream, starting at the current position. After writing to the resource, Write advances the current position by the number bytes written, and returns the number of bytes written.
        All other data-writing methods of a handle stream (WriteBuffer, WriteComponent) call Write to do the actual writing."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Button(WinControl):
    """TButton is a push button control.
    Use TButton to put a standard push button on a form. TButton introduces several properties to control its behavior in a dialog box setting. Users choose button controls to initiate actions.
    To use a button that displays a bitmap instead of a label, use TBitBtn. To use a button that can remain in a pressed position, use TSpeedButton.
    The Caption property can be used to define an accelerator key to a control. 
    
    Note: Because the TButton caption is always centered, changing the BiDiMode alignment has no effect.
    Note: Changing the color of the Caption is not supported for TButton. Instead, use a button type whose Caption color can be changed using the Font property, such as TSpeedButton or TBitBtn."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Cancel: bool
    """bool:"""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    CommandLinkHint: str
    """str:"""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Default: bool
    """bool:"""
    DisabledImageIndex: int
    """int:"""
    DisabledImageName: str
    """str:"""
    DisabledImages: CustomImageList
    """CustomImageList:"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    DropDownMenu: PopupMenu
    """PopupMenu:"""
    ElevationRequired: bool
    """bool:"""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HotImageIndex: int
    """int:"""
    HotImageName: str
    """str:"""
    ImageAlignment: ImageAlignment
    """ImageAlignment:"""
    ImageIndex: int
    """int:"""
    ImageMargins: ImageMargins
    """ImageMargins:"""
    ImageName: str
    """str:"""
    Images: CustomImageList
    """CustomImageList:"""
    ModalResult: int
    """int:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDropDownClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    PressedImageIndex: int
    """int:"""
    PressedImageName: str
    """str:"""
    SelectedImageIndex: int
    """int:"""
    SelectedImageName: str
    """str:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    Style: CustomButton.TButtonStyle
    """CustomButton.TButtonStyle:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    StylusHotImageIndex: int
    """int:"""
    StylusHotImageName: str
    """str:"""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    WordWrap: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class BytesStream(MemoryStream):
    """TBytesStream is a stream that stores its data in bytes.
    Use TBytesStream to store data as bytes in a memory buffer. 
    Memory streams are useful as intermediary objects that can hold information as well as read it from or write it to another storage medium. They provide a useful format for comparing the contents of streams, or for manipulating data that is stored in a less accessible medium."""
    __hash__: ClassVar[None] = ...
    Bytes: tuple
    """tuple: Specifies the stored data.
        The Bytes property returns the buffer in which the data is stored. Use the Size property to find the actual amount of data in the buffer."""
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, ABytes: tuple) -> None:
        """TBytesStream.Create(ABytes: tuple) -> None
        Constructs an object and initializes its data before the object is first used.
        System.Classes.TBytesStream.Create inherits from System.TObject.Create. All content below this line refers to System.TObject.Create.
        Constructs an object and initializes its data before the object is first used.
        Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
        Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.
        
        Note: If an exception escapes from a constructor, the object's destructor is called to clean up the failed instance."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Canvas(Persistent):
    """TCanvas provides an abstract drawing space for objects that must render their own images.
    Use TCanvas as a drawing surface for objects that draw an image of themselves. Standard window controls such as edit controls or list boxes do not require a canvas, as they are drawn by the system. 
    TCanvas provides properties, events, and methods that assist in creating an image by:
    
    Specifying the type of brush, pen, and font to use.
    Drawing and filling a variety of shapes and lines.
    Writing text.
    Rendering graphic images.
    Enabling a response to changes in the current image.
    TCanvas has two descendants, TControlCanvas and TMetafileCanvas, which assist in drawing images of controls and in creating metafile images for objects."""
    __hash__: ClassVar[None] = ...
    Brush: Brush
    """Brush: Determines the color and pattern for filling graphical shapes and backgrounds.
        Set the Brush property to specify the color and pattern to use when drawing the background or filling in graphical shapes. The value of Brush is a TBrush object. Set the properties of the TBrush object to specify the color and pattern or bitmap to use when filling in spaces on the canvas.
        
        Note:  Setting the Brush property assigns the specified TBrush object, rather than replacing the current TBrush object."""
    CanvasOrientation: Any
    """Determines the orientation of the canvas as left-to-right or right-to-left."""
    ClipRect: Any
    """Specifies the boundaries of the clipping rectangle."""
    CopyMode: int
    """int: Specifies how a graphical image is copied onto the canvas.
        Set CopyMode to affect the way graphical images are drawn onto the canvas. The CopyMode is used when copying an image from another canvas using the CopyRect method. CopyMode is also used by TBitmap objects when they draw themselves to a canvas.
        Use CopyMode to achieve a variety of affects when rendering an image. Achieve special effects like merged images and making parts of a bitmap transparent by combining multiple images with different CopyModes."""
    Font: Font
    """Font: Specifies the font to use when writing text on the image.
        Set Font to specify the font to use for writing text on the image. The value of Font is a T Font object. Set the properties of the T Font object to specify the font face, color, size, style, and any other aspects of the font.
        The Canvas.Font property is only guaranteed to equal the Font property if you have an owner-drawn listbox (where you are expected to use the canvas). Even in that case, it is only guaranteed to equal the Font property once the first paint message is underway. If you use a canvas inside an ownerdraw event, everything should work as expected. Using the canvas for a reason outside the scope of its intended usage may give unpredictable results.
        
        Note:  Setting the Font property assigns the specified T Font object, rather than replacing the current T Font object."""
    Handle: Any
    """Specifies the handle for this canvas."""
    LockCount: Any
    """Indicates the number of times the canvas has been locked to prevent interference from other threads."""
    OnChange: Any
    """Occurs when the image has just changed."""
    OnChanging: Any
    """Occurs just before a change is made to the image."""
    Pen: Pen
    """Pen: Specifies the kind of pen the canvas uses for drawing lines and outlining shapes.
        Set Pen to specify the pen to use for drawing lines and outlining shapes in the image. The value of Pen is a TPen object. Set the properties of the TPen object to specify the color, style, width, and mode of the pen.
        
        Note:  Setting the Pen property assigns the specified TPen object, rather than replacing the current TPen object."""
    PenPos: Any
    """Specifies the current drawing position of the Pen."""
    TextFlags: Any
    """Specifies how text is written to the canvas."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AngleArc(self, X: int, Y: int, Radius: int, StartAngle: float, SweepAngle: float) -> None:
        """TCanvas.AngleArc(X: int, Y: int, Radius: int, StartAngle: float, SweepAngle: float) -> None
        Draws an arc on the image along the perimeter of the circle defined by the parameters.
        The AngleArc method draws a line from the current position to the starting point of the arc and then a counterclockwise circular arc to the arc endpoint.  The arc traverses the perimeter of a circle whose center lies at (X,Y) and whose radius is Radius. The arc is drawn following the perimeter of the circle, counterclockwise, from the StartAngle with a sweep angle of SweepAngle.
        If the sweep angle is greater than 360 degrees, the entire circle is drawn and part of the arc is drawn multiple times.
        The current position is updated to the arc endpoint."""
    def Arc(self) -> Any:
        """TCanvas.Arc()"""
    def ArcTo(self, X1: int, Y1: int, X2: int, Y2: int, X3: int, Y3: int, X4: int, Y4: int) -> None:
        """TCanvas.ArcTo(X1: int, Y1: int, X2: int, Y2: int, X3: int, Y3: int, X4: int, Y4: int) -> None
        Draws an arc on the image along the perimeter of the ellipse bounded by the specified rectangle.
        Vcl.Graphics.TCanvas.ArcTo inherits from Vcl.Graphics.TCustomCanvas.ArcTo. All content below this line refers to Vcl.Graphics.TCustomCanvas.ArcTo.
        Draws an arc on the image along the perimeter of the ellipse bounded by the specified rectangle.
        Override the ArcTo method (or just use Arcto from descendant classes) to implement drawing of an elliptically curved line with the current Pen. The arc traverses the perimeter of an ellipse that is bounded by the points (X1,Y1) and (X2,Y2). The arc is drawn following the perimeter of the ellipse, counterclockwise, from the starting point to the ending point. The starting point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X3,Y3). The ending point is defined by the intersection of the ellipse and a line defined by the center of the ellipse and (X4, Y4).
        This procedure draws lines by using the current pen and updates the value of PenPos to the value of the last endpoint."""
    def BrushCopy(self) -> Any:
        """TCanvas.BrushCopy()"""
    def Chord(self) -> Any:
        """TCanvas.Chord()"""
    def CopyRect(self) -> Any:
        """TCanvas.CopyRect()"""
    def Create(self, *args, **kwargs) -> Any:
        """Creates an instance of TCanvas.
        Call Create to instantiate a TCanvas object at runtime. Create allocates memory for the instance of TCanvas and creates the TFont, TBrush and TPen objects for the Font, Brush, and Pen properties. Create also initializes the CopyMode to cmSrcCopy."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TCanvas.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TCanvas object is not nil and only then calls Destroy."""
    def Draw(self) -> Any:
        """TCanvas.Draw()"""
    def DrawFocusRect(self) -> Any:
        """TCanvas.DrawFocusRect()"""
    def Ellipse(self) -> Any:
        """TCanvas.Ellipse()"""
    def FillRect(self) -> Any:
        """TCanvas.FillRect()"""
    def FloodFill(self) -> Any:
        """TCanvas.FloodFill()"""
    def FrameRect(self) -> Any:
        """TCanvas.FrameRect()"""
    def GetPixel(self, x, y) -> TColor:
        """TCanvas.GetPixel(x, y) -> TColor
        This is the same as TCanvas.Pixels[x, y].\rReturns the color of the pixels within the current ClipRect."""
    def HandleAllocated(self, *args, **kwargs) -> Any:
        """Indicates whether the TCanvas object has acquired a handle to a device context.
        Use HandleAllocated to determine whether the Handle property is set to an HDC value. HandleAllocated indicates whether the canvas has acquired a device context. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, TCanvas automatically allocates a new device context and returns its handle if the property had not been previously set."""
    def LineTo(self) -> Any:
        """TCanvas.LineTo()"""
    def Lock(self) -> Any:
        """TCanvas.Lock()"""
    def MoveTo(self) -> Any:
        """TCanvas.MoveTo()"""
    def Pie(self) -> Any:
        """TCanvas.Pie()"""
    def PolyBezier(self) -> Any:
        """TCanvas.PolyBezier()"""
    def PolyBezierTo(self) -> Any:
        """TCanvas.PolyBezierTo()"""
    def Polygon(self) -> Any:
        """TCanvas.Polygon()"""
    def Polyline(self) -> Any:
        """TCanvas.Polyline()"""
    def Rectangle(self) -> Any:
        """TCanvas.Rectangle()"""
    def Refresh(self) -> Any:
        """TCanvas.Refresh()"""
    def RoundRect(self) -> Any:
        """TCanvas.RoundRect()"""
    def SetPixel(self, x, y, color) -> Any:
        """TCanvas.SetPixel(x, y, color)
        This is the same as TCanvas.Pixels[x, y] := color\rSpecifies the color of the pixels within the current ClipRect."""
    def StretchDraw(self) -> Any:
        """TCanvas.StretchDraw()"""
    def TextExtent(self) -> Any:
        """TCanvas.TextExtent()"""
    def TextHeight(self) -> Any:
        """TCanvas.TextHeight()"""
    def TextOut(self) -> Any:
        """TCanvas.TextOut()"""
    def TextRect(self) -> Any:
        """TCanvas.TextRect()"""
    def TextWidth(self) -> Any:
        """TCanvas.TextWidth()"""
    def TryLock(self) -> Any:
        """TCanvas.TryLock()"""
    def Unlock(self) -> Any:
        """TCanvas.Unlock()"""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CheckBox(WinControl):
    """TCheckBox represents a check box that can be on (checked) or off (unchecked).
    A TCheckBox component presents an option for the user. The user can check the box to select the option, or uncheck it to deselect the option. 
    The Caption property can be used to define an accelerator key to a control."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: LeftRight
    """LeftRight:"""
    AllowGrayed: bool
    """bool:"""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Checked: bool
    """bool:"""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    State: CheckBoxState
    """CheckBoxState:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    WordWrap: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Collection(Persistent):
    """TCollection is a container for TCollectionItem objects.
    Each TCollection holds a group of TCollectionItem descendants. TCollection maintains an index of the collection items in its Items array. The Count property contains the number of items in the collection. Use the Add and Delete methods to add items to the collection and delete items from the collection.
    Objects descended from TCollection can contain objects descended from TCollectionItem. Thus, for each TCollection descendant, there is a corresponding TCollectionItem descendant. 
    The following table lists some typical descendants of TCollection with the corresponding TCollectionItem descendant and the component that uses each pair:
    
    
    
    TCollection descendant
    
    TCollectionItem descendant
    
    Component
    
    
    
    TBitmapLinks
    
    
    
    TBitmapLink
    
    
    
    TCustomStyleObject
    
    
    
    
    TAggregates
    
    
    
    TAggregate
    
    
    
    TClientDataSet
    
    
    
    
    TCookieCollection
    
    
    
    TCookie
    
    
    
    TWebResponse
    
    
    
    
    TCoolBands
    
    
    
    TCoolBand
    
    
    
    TCoolBar
    
    
    
    
    TDBGridColumns
    
    
    
    TColumn
    
    
    
    TDBGrid
    
    
    
    
    TDependencies
    
    
    
    TDependency
    
    
    
    TService
    
    
    
    
    THeaderSections
    
    
    
    THeaderSection
    
    
    
    THeaderControl
    
    
    
    
    TListColumns
    
    
    
    TListColumn
    
    
    
    TListView
    
    
    
    
    TParams
    
    
    
    TParam
    
    
    
    many datasets
    
    
    
    
    TStatusPanels
    
    
    
    TStatusPanel
    
    
    
    TStatusBar
    
    
    The controls that use TCollection and TCollectionItem descendants have a published property that holds a collection. (For example, the Panels property of TStatusBar holds a TStatusPanels.) A standard property editor, referred to generically as the Collection editor, can be invoked from the Object Inspector to edit the items in the collection. 
    
    Note: When writing a TCollection descendant that is used by another control, be sure to override the protected GetOwner method of the collection so that the descendant class instances can appear in the Object Inspector.
    Note: TCollection has the TOwnedCollection descendant that maintains information about its owner. TOwnedCollection implements the GetOwner method. Therefore, classes derived from TOwnedCollection do not need to add anything in order to appear in the Object Inspector."""
    __hash__: ClassVar[None] = ...
    Capacity: int
    """int: Provides access to the internal TList.Capacity property.
        The Capacity property specifies the allocated size of the array of pointers maintained by the TList object. This value is set to the number of pointers the list will need to contain."""
    Count: Any
    """Returns the count of collection items"""
    ItemClass: CollectionItemClass
    """CollectionItemClass: Indicates the class to which the collection's items belong.
        ItemClass is the class (descended from TCollectionItem) to which the items in the collection belong. For example, in an instance of the TCollection descendant THeaderSections, the value of the ItemClass property is THeaderSection."""
    Items: Any
    """Returns an iterator over the collection items"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Add(self) -> Any:
        """TCollection.Add()
        Adds a collection item to the collection"""
    def Assign(self, Source: Persistent) -> None:
        """TCollection.Assign(Source: Persistent) -> None
        Copies the contents of the Source collection to the current object.
        Use Assign to copy the contents of one TCollection instance to another. The Assign method deletes all items from the destination collection (the object where it is executed), then adds a copy of each item in the source collection's Items array.
        Source is another object (typically another collection) that contains the items that replace this collection's items."""
    def BeginUpdate(self) -> Any:
        """TCollection.BeginUpdate()
        Suspends screen repainting."""
    def Clear(self) -> Any:
        """TCollection.Clear()
        Clears all collection items"""
    def ClearAndResetID(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Create(self, ItemClass: CollectionItemClass) -> None:
        """TCollection.Create(ItemClass: CollectionItemClass) -> None
        Creates and initializes a collection.
        Call Create to instantiate a TCollection object at run time. Typically, TCollection descendants are created by a component that uses the collection to implement a property.
        ItemClass identifies the TCollectionItem descendants that must be used to represent the items in the collection. The Add method uses this class to create items of the appropriate type."""
    def Delete(self, Index) -> Any:
        """TCollection.Delete(Index)
        Deletes a single item from the collection."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the collection and each item in it.
        Destroy uses the Clear method to free each item referenced in the Items array, then destroys the collection itself."""
    def EndUpdate(self) -> Any:
        """TCollection.EndUpdate()
        Re-enables screen repainting."""
    def FindItemID(self, ID: int) -> CollectionItem:
        """TCollection.FindItemID(ID: int) -> CollectionItem
        Returns the item with the specified ID.
        The FindItemID method returns the item in the collection whose ID property is passed to it as a parameter. If no item has the specified ID, FindItemID returns nil (Delphi) or NULL (C++)."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TCollection enumerator.
        GetEnumerator returns a TCollectionEnumerator reference, which enumerates all items in the collection. 
        To do so, call the TCollectionEnumerator GetCurrent method within a While MoveNext do loop."""
    def GetItem(self, Index: int) -> CollectionItem:
        """TCollection.GetItem(Index: int) -> CollectionItem
        Returns a specified item in the collection.
        GetItem is the protected read implementation of the Items property."""
    def GetNamePath(self, *args, **kwargs) -> Any:
        '''Returns a string used by the Object Inspector.
        If the collection has no owner, GetNamePath returns the name of the collection\'s actual (runtime) type. If the collection is owned, GetNamePath returns the owner\'s name followed, if applicable, by a dot and the name of the owner\'s property that holds the collection. For example, GetNamePath might return "TreeView1.Items".
        
        Note:  For a collection to have an owner, it must override the GetOwner method.'''
    def Insert(self, Index) -> Any:
        """TCollection.Insert(Index)
        Inserts a new collection item to the collection at the Index position"""
    def Owner(self, *args, **kwargs) -> Any:
        """Returns the Owner of the collection.
        Call Owner to obtain a reference to the object that owns this collection. Typically, the owner uses the collection to implement one of its properties."""
    def SetItem(self, Index: int, Value: CollectionItem) -> None:
        """TCollection.SetItem(Index: int, Value: CollectionItem) -> None
        Copies the properties of another item to a specified item in the collection.
        SetItem is the protected write implementation of the Items property. It calls the Assign method of the item specified by Index, so that the properties of the item specified by Value are copied to that item."""
    def Sort(self, AComparer) -> None:
        """TCollection.Sort(AComparer: IComparer<System.Classes.CollectionItem>) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ColorBox(CustomListControl):
    """TColorBox represents a combo box that lets users select a color.
    Use TColorBox to provide the user with a drop-down combo box from which to select a color. Use the Style property to specify which colors the color box should list. Each color is displayed next to a small square that is drawn in the corresponding color.
    Use the Selected property to access the color that the user selects. The Colors property provides access to the entire list of colors, while the ColorNames property lists their names."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoComplete: bool
    """bool:"""
    AutoDropDown: bool
    """bool:"""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DefaultColorColor: int
    """int:"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DropDownCount: int
    """int:"""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    ItemHeight: int
    """int:"""
    NoneColorColor: int
    """int:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCloseUp: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDropDown: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetColors: Callable[[CustomColorBox,Strings],None]
    """Callable[[CustomColorBox, Strings], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelect: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    Selected: int
    """int:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    Style: ColorBoxStyle
    """ColorBoxStyle:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ComboBox(CustomListControl):
    """TComboBox combines an edit box with a scrollable list.
    A TComboBox component is an edit box with a scrollable drop-down list attached to it. Users can select an item from the list or type directly into the edit box.
    
    Note:  The width of the button in a TComboBox is equal to the width that Windows uses for scrollbars. This width depends on the color scheme that the user has chosen (by right-clicking the desktop, selecting Properties, and choosing Appearance). If you carefully size your combo box so all the text is visible, then a user running under a different color scheme may find that the text is obscured by the button. One solution is to set the scrollbar wide when developing the application. Most color schemes use a scrollbar that is at most 21 pixels wide."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoCloseUp: bool
    """bool:"""
    AutoComplete: bool
    """bool:"""
    AutoCompleteDelay: int
    """int:"""
    AutoDropDown: bool
    """bool:"""
    AutoDropDownWidth: bool
    """bool:"""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    CanUndoSelText: bool
    """bool:"""
    CharCase: EditCharCase
    """EditCharCase:"""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    DropDownCount: int
    """int:"""
    DropDownWidth: int
    """int:"""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    ExtendedUI: bool
    """bool:"""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    ImeMode: ImeMode
    """ImeMode: Determines the behavior of the input method editor (IME).
        Set ImeMode to configure the way an IME processes user keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application. 
        ImeMode allows a control to influence the type of conversion performed by the IME so that it is appropriate for the input expected by the control. For example, a control that only accepts numeric input might specify an ImeMode of imClose, as no conversion is necessary for numeric input.
        
        Note:  The value of ImeMode only takes effect when the control receives focus. To change the value of ImeMode when the control already has input focus, call the SetIme method."""
    ImeName: str
    """str: Specifies the input method editor (IME) to use for converting keyboard input to Asian language characters.
        Set ImeName to specify which IME to use for converting keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application.
        ImeName must specify one of the IMEs that has been installed through the Windows control panel. The property inspector provides a drop-down list of all currently installed IMEs on the system. At runtime, applications can obtain a list of currently installed IMEs from the global Screen variable.
        If ImeName specifies an unavailable IME, the IME that was active when the application started is used instead. No exception is generated.
        
        Note:  The value of ImeName only takes effect when the control receives focus. To change the value of ImeName after the control has input focus, call the SetIme method."""
    ItemHeight: int
    """int:"""
    ItemIndex: int
    """int:"""
    Items: Strings
    """Strings:"""
    MaxLength: int
    """int:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCloseUp: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDrawItem: Callable[[WinControl,int,Rect,OwnerDrawState],None]
    """Callable[[WinControl, int, Rect, OwnerDrawState], None]:"""
    OnDropDown: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMeasureItem: Callable[[WinControl,int,int],None]
    """Callable[[WinControl, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelect: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    Sorted: bool
    """bool:"""
    Style: ComboBoxStyle
    """ComboBoxStyle:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Text: str
    """str: Contains a text string associated with the control.
        Use the Text property to read the Text of the control or to specify a new string for the Text value. By default, Text is the control name. For edit controls and memos, the Text appears within the control. For combo boxes, the Text is the content of the edit control portion of the combo box. 
        
        Note:  Controls that display text use either the Caption property or the Text property to specify the text value. Which property is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control."""
    TextHint: str
    """str:"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Component(Persistent):
    """TComponent is the common ancestor of all component classes.
    TComponent is the base class for all components. Components are persistent objects that have the following capabilities:
    
    IDE integration. The ability to appear on an IDE palette and be manipulated in a Form Designer.
    Ownership. The ability to manage other components. If component A owns component B, then A is responsible for destroying B when A is destroyed.
    Streaming and filing. Enhancements of the persistence features inherited from TPersistent.
    COM support. Components can be converted into ActiveX controls or other COM objects using wizards provided with Windows products. Components can serve as wrappers for COM objects.
    Note: COM features are present in all implementations of TComponent, including those provided for compatibility with OS X. However, COM features are Windows only and cannot be used in multi-device (cross-platform) applications.
    TComponent does not provide any user interface or display features. These features are provided by two classes that directly descend from TComponent:
    
    TControl, in the FMX.Types unit, is the base class for visual components in applications built with the FireMonkey (FMX) framework.
    TControl, in the Vcl.Controls unit, is the base class for visual components in Windows-only (VCL) applications.
    Note: Only the FMX.Types unit and other FireMonkey-specific units can be used with OS X applications. That is, you cannot use VCL units in multi-device applications.
    Components that can be visible at run time are sometimes called visual components. Other components, which are never visible at run time, are sometimes called non-visual components. However it is more common to refer to visual components as controls and non-visual components simply as components.
    Do not create instances of TComponent. Use TComponent as a base class when declaring non-visual components that can appear on the component palette and be used in the Form Designer. Properties and methods of TComponent provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior."""
    __hash__: ClassVar[None] = ...
    ComObject: IInterface
    """IInterface: Specifies the interface reference implemented by the component.
        Use ComObject to assign a COM interface implemented by a component to an interface reference. This property is used by components that support COM interfaces. 
        If the component is not a wrapper for a COM component, trying to read ComObject causes TComponent to raise an EComponentError exception."""
    ComponentCount: Any
    """Returns the owned component count"""
    ComponentIndex: int
    """int: Indicates the position of the component in its owner's Components property array.
        Use ComponentIndex when iterating through the Components list of the component's owner to perform an action on owned components. It can be used in conjunction with ComponentCount. ComponentIndex is used internally for iterative assignment procedures. 
        
        Note:  The first component in the list has a ComponentIndex value of 0, the second has a value of 1, and so on. Therefore, when using ComponentIndex with ComponentCount, note that ComponentCount is always 1 more than the highest Components index."""
    ComponentState: ComponentState
    """ComponentState: Describes the current state of the component, indicating when a component needs to avoid certain actions.
        ComponentState is a set of constants defined in the TComponentState type.
        Components use the ComponentState property to detect states in which certain kinds of actions are allowed or disallowed. For example, if a component needs to avoid certain behaviors at design time that it performs at run time, it can check for the csDesigning flag. 
        ComponentState is read-only and its flags are set automatically when appropriate."""
    ComponentStyle: ComponentStyle
    """ComponentStyle: Governs the behavior of the component.
        ComponentStyle governs how the component interacts with the streaming system and the Object Inspector. ComponentStyle is a read-only property. Typically, the value of the various component style flags are part of a component definition, specified in a component constructor. The one exception to this is the csSubComponent style, which can be set by calling the SetSubComponent method."""
    Components: Any
    """Returns an iterator over the owned components"""
    DesignInfo: int
    """int: Contains information used by the Form designer.
        DesignInfo is used internally. Do not use this property in applications."""
    Name: str
    """str: Specifies the name of the component as referenced in code.
        Use Name to change the name of a component to reflect its purpose in the current application. By default, the IDE assigns sequential names based on the type of the component, such as 'Button1', 'Button2', and so on.
        Use Name to refer to the component in code.
        
        Warning: Changing Name at run time causes any references to the old name to become undefined. Any subsequent code that uses the old name will cause an exception."""
    Observers: Observers
    """Observers: Indicates the TObservers object added to the TComponent.
        Observers is a read-only property that returns the TObservers added to the TComponent, in order to use the notifications provided by the observers either with LiveBindings or for the developers' own purposes."""
    Owner: Any
    """Returns the Component Owner"""
    Tag: int
    """int: Stores a NativeInt integral value as a part of a component.
        Tag has no predefined meaning. The Tag property can store any additional integer value for the convenience of developers. Often, Tag stores a pointer. A Tag value can be typecast to the appropriate pointer type. Notice that on 64-bit platforms, all  pointer types are 8 bytes in size, while on 32-bit platforms, pointer types are 4 bytes. These pointer sizes correspond to sizes of NativeInt integral values on 64-bit and 32-bit platforms."""
    VCLComObject: Pointer
    """Pointer: Represents information used internally by components that support COM.
        VCLComObject is for internal use only."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Performs any necessary actions before the first destructor is called.
        BeforeDestruction is called automatically immediately before the component's first destructor executes. Do not call it explicitly in your applications.
        As implemented in TComponent, BeforeDestruction checks whether the Destroying method has been called, and if not, calls it. Descendants that override this method to perform other actions before a component is destroyed should call the inherited method first to ensure that this check takes place."""
    def BeginInvoke(self, AProc: Proc, AContext: Object) -> IAsyncResult:
        """TComponent.BeginInvoke(AProc: Proc, AContext: Object) -> IAsyncResult
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type.\r
        Performs an asynchronous call to the method specified by either AProc or AFunc.
        The AContext parameter specifies the context where the method executes in. This context corresponds to the main thread. In case of a Tcontrol descendant, it executes in the context of the thread on which the closest window handle was created.
        BeginInvoke returns the results of the asynchronous execution in an interface IAsyncResult used as a return type."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TComponent.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def DestroyComponents(self, *args, **kwargs) -> Any:
        """Destroys all owned components.
        DestroyComponents iterates through the components owned by the component, removing each from the list of owned components and destroying it.
        It is not necessary to call DestroyComponents directly. DestroyComponents is automatically called when the component is destroyed."""
    def Destroying(self, *args, **kwargs) -> Any:
        """Indicates that the component and its owned components are about to be destroyed.
        Destroying sets the csDestroying flag in the ComponentState property. It then calls the Destroying method for each owned component so that its csDestroying flag is also set. If csDestroying is already set, Destroying does nothing.
        It is not necessary to call Destroying directly. Destroying is automatically called when the component is destroyed."""
    def EndFunctionInvoke(self, AsyncResult: IAsyncResult) -> Object:
        """TComponent.EndFunctionInvoke(AsyncResult: IAsyncResult) -> Object
        Blocks the caller until the specified ASyncResult completes.
        Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. The result type corresponds to a TObject class type.
        EndInvoke raises any exception that may occur while the asynchronous method executes."""
    def EndInvoke(self, ASyncResult: IAsyncResult) -> None:
        """TComponent.EndInvoke(ASyncResult: IAsyncResult) -> None
        Blocks the caller until the specified ASyncResult completes.
        Returns the result from the method that BeginInvoke asynchronously executes. This result is immediately returned after the given IAsyncResult finishes. 
        EndInvoke raises any exception that may occur while the asynchronous method executes."""
    def ExecuteAction(self, Action: BasicAction) -> bool:
        """TComponent.ExecuteAction(Action: BasicAction) -> bool
        Executes an action.
        ExecuteAction executes an action for the component. Action is a TBasicAction or any descendant of TBasicAction. 
        ExecuteAction first checks whether the provided action is compatible with the component and then executes the action. The return value is a Boolean. A value of True is returned if the action was executed; otherwise, False is returned. 
        Derived classes can override this method to implement a distinct way of handling actions."""
    def FindComponent(self, AName: str) -> Component:
        """TComponent.FindComponent(AName: str) -> Component
        Indicates whether a given component is owned by the component.
        FindComponent returns the component in the Components property array with the name that matches the string in the AName parameter. Use FindComponent to determine whether a given component is owned by another.
        Component name matches are not case sensitive."""
    def FreeNotification(self, AComponent: Component) -> None:
        """TComponent.FreeNotification(AComponent: Component) -> None
        Ensures that AComponent is notified that the component is going to be destroyed.
        Use FreeNotification to register AComponent as a component that should be notified when the component is about to be destroyed. It is only necessary to register components this way when they are in a different form or have a different owner. For example, if AComponent is in another form and uses the component to implement a property, it must call FreeNotification so that its Notification method is called when the component is destroyed.
        For components with the same owner, the Notification method is called automatically when an application explicitly frees the component. This notification is not sent out when components are freed implicitly, because the Owner is already being freed."""
    def FreeOnRelease(self, *args, **kwargs) -> Any:
        """Frees the interface reference for components that were created from COM classes.
        FreeOnRelease is called when an interface implemented by the component is released. FreeOnRelease is used internally and calls the corresponding interface method. It should not be necessary to call FreeOnRelease directly."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TComponent enumerator.
        GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
        To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop."""
    def GetNamePath(self, *args, **kwargs) -> Any:
        """Returns a string used by the Object Inspector.
        GetNamePath is used to determine the text to display in the Object Inspector for the name of the object being edited. GetNamePath is introduced in TPersistent so descendants such as collections can appear in the Object Inspector. TComponent overrides GetNamePath to return the component's name. Do not call GetNamePath directly."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def InsertComponent(self, AComponent: Component) -> None:
        """TComponent.InsertComponent(AComponent: Component) -> None
        Establishes the component as the owner of a specified component.
        InsertComponent adds the component passed in the AComponent parameter to the end of the Components array property. The inserted component must have no name (no specified Name property value), or the name must be unique among all others in the Components list.
        When the owning component is destroyed, AComponent is also destroyed.
        Components are automatically inserted and removed when visually manipulating them in the form designer. Use InsertComponent when manually adding components to another Owner component's Components list."""
    def IsImplementorOf(self, I: IInterface) -> bool:
        """TComponent.IsImplementorOf(I: IInterface) -> bool
        Indicates whether the component implements a specified interface.
        Call IsImplementorOf to determine whether the component (or, if the component aggregates its interface with other components, whether the controlling component) supports the interface specified by I. IsImplementorOf is similar to the QueryInterface method, but it can handle a request for a nil (Delphi) or NULL (C++) interface, and it does not return an interface pointer.
        The streaming system that loads and saves components uses IsImplementorOf to resolve property values that are interfaces."""
    def ReferenceInterface(self, I: IInterface, Operation: Operation) -> bool:
        """TComponent.ReferenceInterface(I: IInterface, Operation: Operation) -> bool
        Establishes or removes internal links that cause this component to be notified when the implementer of a specified interface is destroyed.
        Component writers use ReferenceInterface to ensure that properties whose values are interfaces are informed when the objects that implement those interfaces are destroyed. This notification must be in place for a property whose value is an interface to be saved with the component in a form file (that is, for such a property to persist as a published property).
        I is an interface pointer that is the value of the published property of interest.
        Operation indicates whether the notification link to the implementer of the interface should be established (opInsert) or removed (opRemove).
        ReferenceInterface returns True if it is successful in establishing or removing the notification link. If ReferenceInterface returns False when called with Operation set to opInsert, the specified interface cannot be stored as the value of a published property.
        
        Note: A result of False does not necessarily indicate an error, merely that the interface cannot be stored by the property streaming system. For example, ReferenceInterface returns False when the specified interface employs true reference counting, independent of component lifetimes."""
    def RemoveComponent(self, AComponent: Component) -> None:
        """TComponent.RemoveComponent(AComponent: Component) -> None
        Removes a specified component specified from the component's Components list.
        Components are automatically inserted and removed when visually manipulating them in the form designer. Use RemoveComponent to programmatically delete the component specified by AComponent from its Owner component."""
    def RemoveFreeNotification(self, AComponent: Component) -> None:
        """TComponent.RemoveFreeNotification(AComponent: Component) -> None
        Disables the destruction notification that was enabled by FreeNotification.
        RemoveFreeNotification removes the component specified by the AComponent parameter from the internal list of objects to be notified that the component is about to be destroyed. AComponent is added to this list by a previous call to the FreeNotification method.
        Most applications have no need to call RemoveFreeNotification. It is used by TComponent to detect loops where two components are notifying each other of their impending destruction."""
    def SafeCallException(self, ExceptObject: Object, ExceptAddr: Pointer) -> int:
        """TComponent.SafeCallException(ExceptObject: Object, ExceptAddr: Pointer) -> int
        Handles exceptions in methods declared using the safecall calling convention.
        SafeCallException handles exceptions in methods that use the safecall calling convention. Some classes that implement interfaces override this method to handle errors that might occur. TComponent calls the implementation of this method for the interface supported by the component, if it exists. If the component does not support interfaces, this method calls the SafeCallException method inherited from TObject, which returns E_UNEXPECTED. This is a default return value that is appropriate for classes that do not support any interfaces."""
    def SetSubComponent(self, IsSubComponent: bool) -> None:
        """TComponent.SetSubComponent(IsSubComponent: bool) -> None
        Identifies whether the component is a subcomponent.
        Call SetSubComponent to indicate whether this component is a subcomponent. A subcomponent is a component whose Owner is a component other than the form or data module in which it resides. Unless such a component calls SetSubComponent with IsSubComponent set to True, its published properties will not be saved to the form file.
        IsSubComponent indicates whether the component is a subcomponent (True) or not (False).
        SetSubComponent is called at design time:
        
        Either from the constructor of a component that always acts as a subcomponent. In this case, the component calls its own SetSubComponent method from the constructor with IsSubComponent set to True.
        Or immediately after constructing an instance of the subcomponent. In this case, the Owner calls the SetSubComponent method of a component it has just instantiated, with IsSubComponent set to True."""
    def UpdateAction(self, Action: BasicAction) -> bool:
        """TComponent.UpdateAction(Action: BasicAction) -> bool
        Updates the state of an action.
        UpdateAction is used to update the state of an action. Action is a TBasicAction or any descendant. 
        UpdateAction first checks whether the provided action is compatible with the component and then updates it. The return value is a Boolean. A value of True is returned if the action was updated, and a value of False, otherwise. 
        Derived classes can override this method to implement a distinct way of handling action updates."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ContainedAction(BasicAction):
    """TContainedAction is the base class for actions that can be grouped by category and that can appear in action lists.
    TContainedAction introduces properties and methods that enable actions to appear in an action list. The properties of TContainedAction contain information about the relationship between the action and its action list. Methods of TContainedAction override those of the base class to take into account the action list that owns the action.
    TContainedAction defines the published Category property.
    Objects of type TContainedAction can be associated with a Category of actions. This category is used at design time to organize the actions in an action list using the Action List editor or the Action Manager editor (only available for VCL)."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    ActionList: ContainedActionList
    """ContainedActionList: Holds the action list to which the action belongs."""
    AutoCheck: bool
    """bool: Controls whether the Checked property toggles when the action executes.
        AutoCheck causes the Checked property to toggle when the action executes. This allows the Checked property of the action to remain in sync with the Checked property of the client (or an equivalent).
        If the client has an AutoCheck property of its own, the AutoCheck property of the action is propagated to the AutoCheck property of the client."""
    Caption: str
    """str: Represents the caption of the action.
        Caption holds the string that is used as the caption of the action, when it is set. The value of Caption can be propagated to all client controls and client menu items linked to the action."""
    Category: str
    """str: Group or category where the action belongs.
        IDE editors for actions group together actions that share the same category. In the VCL, if you are using an action manager, you can generate user interface elements that correspond to action categories.
        Action categories group actions by similarities, usually of behavior or functionality. Standard categories are Edit, Format, Help, Windows, and others. At design time you can modify or set the Category for an action by selecting the action from the action list or object tree view, and choosing Category in the Object Inspector."""
    Checked: bool
    """bool: Indicates whether client controls and menu items appear checked.
        Checked specifies the checked state for the action. The value of Checked can be propagated to all client controls and client menu items linked to the action.
        
        Note:  If the action has a GroupIndex value greater than 0, then setting Checked to True sets to False the Checked properties of all other actions in the GroupIndex group.
        Tip: Use the AutoCheck property to ensure that the action's Checked property toggles when the action executes."""
    DisableIfNoHandler: bool
    """bool: Indicates whether the action's clients should be disabled if no OnExecute event handler is found.
        DisableIfNoHandler defines whether to set the Enabled property of the action to False if no OnExecute event handler is set for the action. Setting Enabled to False disables all the action's clients.
        See, for example, how FMX.Forms.TApplication.UpdateAction uses DisableIfNoHandler to define whether to set Enabled to False if the OnExecute event handler is not defined to the action.
        For example, setting DisableIfNoHandler to False can be useful when managing submenus. In this case, pointing to a command on the main menu, which causes the submenu to open, does not need any OnExecute event handler. Then, if DisableIfNoHandler is True, this main menu command becomes disabled and the submenu cannot be opened. In such cases it can be convenient to use actions of types FMX.Controls.TControlAction and Vcl.Controls.TControlAction.  Objects of these classes have the value of DisableIfNoHandler set to False, by default."""
    Enabled: bool
    """bool: Specifies the enabled state for the action.
        The value of Enabled can be propagated to all client controls and client menu items linked to the action."""
    GroupIndex: int
    """int: Indicates a group of actions in one action list. Actions in this group act like the group of radio buttons.
        The value of GroupIndex is used to define groups of actions. Actions in each group act like groups of radio buttons. When GroupIndex is greater than 0, this value identifies the group to which some actions belong. The value of GroupIndex can be propagated to all client controls and client menu items linked to the action.
        When the Checked property of any action in that group is set to True, the Checked properties of all other actions in the group are set to False. That is, only one action in the group can be checked at a time.
        
        Note:  All actions in a group must be listed by the same action list."""
    HelpContext: int
    """int: Keeps the integer context ID that identifies the Help topic for the action.
        HelpContext specifies the integer context ID  to identify the Help topic to show when invoking Help for the action. The value of HelpContext can be propagated to all client controls and client menu items linked to the action. See also IsHelpLinked.
        HelpContext is only used when htContext is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the value of the HelpContext property to invoke the online Help that shows the topic with this context ID. The target topic is uniquely identified by a HelpContext context ID value."""
    HelpKeyword: str
    """str: Contains the keyword string that identifies the Help topic for the action.
        The value of HelpKeyword can be propagated to all client controls and client menu items linked to the action. 
        HelpKeyword is only used when htKeyword is selected in the HelpType property.
        
        Note: To use Help, you need to enable Help in your application. When your application supports usage of the appropriate Help system, then it can show Help topics from the associated Help file. When a client control has focus and the user presses the F1 key, the control uses the HelpKeyword property's value to invoke the online Help showing the topic with this keyword."""
    HelpType: HelpType
    """HelpType: Keeps whether to use the HelpContext or HelpKeyword property to identify the Help topic.
        The value of HelpType can be propagated to all client controls and client menu items linked to the action. 
        HelpType can keep one of the following constants:
        
        htContext ? instructs to use the HelpContext property to identify the Help topic to show when invoking Help.
        htKeyword ? instructs to use the HelpKeyword property to identify the Help topic to show when invoking Help."""
    Hint: str
    """str: Stores the Help hint text.
        Hint holds the hint string indicating the hint text for the action.
        Hint contains the text strings that appear in a pop-up box (or in a status bar) when the user moves the mouse over screen elements.
        This hint string can be propagated to clients of the action ? to controls, menu items, and other GUI elements. 
        
        Note: VCL controls support hint strings containing three parts that can be shown in separate locations (see Vcl.Controls.TControl.Hint)."""
    ImageIndex: int
    """int: Stores an index in a list of images.
        ImageIndex is a zero-based index in a list of images. TContainedAction does not provide the actual list of images, only implementations of actions in GUI application frameworks provide such a property. In general, this list of images contains images that are associated with controls and menu items that use this action.
        The value of ImageIndex can be propagated to all client controls and client menu items linked to the action. 
        
        Note: When ImageIndex is -1, this means that the list does not contain any images.
        In typical implementations of controls, an image is drawn at the leftmost position in the control, and a control's text is drawn to the right of the image. If ImageIndex is -1, then a control does not offset the text to the right to reserve a placeholder for the image. Otherwise, if ImageIndex is not -1, then the control's text is always drawn with the offset to the right to reserve a place for drawing an image."""
    Index: int
    """int: Specifies the index of the action in its action list.
        Index indicates the position of the action in its action list. You can change the action's Index at design time using one of the IDE editors to handle actions.
        The index of actions determines the order in which they appear in user interface elements such as menus and tool bars.
        Index is zero-based. When Index is -1, this means that the ActionList property does not contain any list."""
    OnHint: Callable[[str,bool],None]
    """Callable[[str, bool], None]:"""
    SecondaryShortCuts: CustomShortCutList
    """CustomShortCutList: Stores shortcuts (in addition to ShortCut) for triggering the action.
        Actions can execute in response to multiple shortcut key combinations. SecondaryShortCuts lists all the shortcut key combinations (other than the one specified by the ShortCut property) that can trigger the action. This lets you provide additional, secondary shortcuts.
        When the user types one of the key combinations listed in SecondaryShortCuts, the action's Execute method is called."""
    ShortCut: int
    """int: Shortcut that triggers the action.
        The value of Shortcut can be propagated to all client controls and client menu items linked to the action."""
    StatusAction: StatusAction
    """StatusAction: Stores the status for an input field in an action.
        StatusAction holds the status for an input field in the action, when it is set. 
        The value of StatusAction  can be propagated to all client controls and client menu items linked to the action."""
    Visible: bool
    """bool: Stores whether the action representation is visible.
        Visible specifies the visible state for the action (True means visible, False means invisible).
        This Visible value is propagated to a client of the action if IsVisibleLinked method of the action link linking the client to the action  returns True.
        If the Visible of an action is False and IsVisibleLinked of an action link returns True, then the Visible of the client (a control, menu item, or others) is also set False and this client is also invisible. Typically, IsVisibleLinked of an action link returns False if the action belongs to TCustomViewAction. Otherwise, when the action belongs to TAction, then  IsVisibleLinked of an action link returns True. That is, TCustomViewAction is used when one need to provide visible representation of clients of actions that have Visible set True."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TContainedAction.Create(AOwner: Component) -> None
        Instantiates and initializes a TContainedAction object.
        Applications do not need to call Create directly. Actions are created automatically when you choose New Action in the Action List editor. 
        Create calls the inherited System.Classes.TBasicAction.Create constructor and then 
        initializes the Enabled (setting it to True), Visible (setting it to True), and ImageIndex (setting it to -1) properties."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the instance of the contained action.
        If the action is contained in an action list or action manager, Destroy removes the action from that list. Then it calls the inherited Destroy method."""
    def DoHint(self, HintStr: str) -> bool:
        """TContainedAction.DoHint(HintStr: str) -> bool
        Calls the OnHint event handler.
        Typically, applications do not call the DoHint method. It is called automatically when the user pauses the mouse on one of the action's client controls or menu items. DoHint is called by the action's client when the client asks to show the hint.
        
        DoHint checks for an OnHint event handler and passes HintStr to it, if the event handler exists. The OnHint event handler can change the specified hint string HintStr. DoHint returns True if no event handler is assigned or if OnHint returns True. DoHint can be used to determine which hint text should be shown. For example, Vcl.Controls.TControlActionLink.DoShowHint calls DoHint internally, and if DoHint returns True, then Vcl.Controls.TControlActionLink.DoShowHint appends the action's shortcut specification to the hint text to display."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def GetParentComponent(self, *args, **kwargs) -> Any:
        """Returns the action list containing the action.
        GetParentComponent returns the action list containing the action. This action list is stored in the ActionList property. If ActionList stores nil, then GetParentComponent calls the inherited System.Classes.TComponent.GetParentComponent method."""
    def HasParent(self, *args, **kwargs) -> Any:
        """Indicates whether the action is contained in an action list.
        HasParent returns True if the action is contained in an action list stored in the  ActionList property. If ActionList stores nil, then HasParent calls the inherited System.Classes.TComponent.HasParent method."""
    def SetParentComponent(self, AParent: Component) -> None:
        """TContainedAction.SetParentComponent(AParent: Component) -> None
        Sets the action list containing the action.
        SetParentComponent sets the specified AParent action list as the action list containing the action. This action list is stored in the ActionList property."""
    def Suspended(self, *args, **kwargs) -> Any:
        """Returns True if the action list of the action is suspended."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ContainedActionList(Component):
    """The base class for list of actions, without the published properties.
    Implement TContainedActionList to work with common properties for all GUI application frameworks.
    Actions lists the actions maintained by the action list.
    The ActionCount property returns the number of actions in the list.
    OnStateChange sends a notification when the State changes."""
    __hash__: ClassVar[None] = ...
    ActionCount: Any
    """Indicates the number of actions in the action list."""
    Actions: Any
    """Lists the actions maintained by the action list."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    OnStateChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    State: ActionListState
    """ActionListState: Indicates whether the actions in the action list respond when the user triggers a client object. 
        State can be one of the constants defined in the TActionListState type: 
        asNormal, asSuspended, and asSuspendedEnabled."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TContainedActionList.Create(AOwner: Component) -> None
        Creates an instance of TContainedActionList.
        This creator is inherited from TComponent, see TComponent.Create for more information."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TContainedActionList.
        This destructor is inherited from TComponent, see TComponent.Destroy for more information."""
    def EnumByCategory(self, Proc: Callable[[ContainedAction,bool],None], Category: str, IncludeSubCategory: bool) -> bool:
        """TContainedActionList.EnumByCategory(Proc: Callable[[ContainedAction, bool], None], Category: str, IncludeSubCategory: bool) -> bool
        Calls the specified procedure (TEnumActionListEvent or TEnumActionListRef) once for every action of the list in the specified category.
        IncludeSubCategory determines whether actions in subcategories are included (True) or not (False) in the loop of calls.
        Proc, an instance of either TEnumActionListEvent or TEnumActionListRef, can set its Done argument to True to stop the loop of calls prematurely.\r
        Calls the specified procedure (TEnumActionListEvent or TEnumActionListRef) once for every action of the list in the specified category.
        IncludeSubCategory determines whether actions in subcategories are included (True) or not (False) in the loop of calls.
        Proc, an instance of either TEnumActionListEvent or TEnumActionListRef, can set its Done argument to True to stop the loop of calls prematurely."""
    def ExecuteAction(self, Action: BasicAction) -> bool:
        """TContainedActionList.ExecuteAction(Action: BasicAction) -> bool
        Generates an OnExecute event.
        Typically, applications do not call the ExecuteAction method. Instead, the action indicated by the Action parameter calls ExecuteAction in response to a user command. It is possible, however, to call ExecuteAction to generate an OnExecute event even though no client control has been triggered.
        ExecuteAction invokes the OnExecute event handler for the action list. It returns True if the event handler handles the action, False otherwise."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TContainedActionList.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Calls a specified method for each child action of the action list.
        GetChildren is used by the component streaming system. For each action in the action list, GetChildren calls the method passed in Proc. The actions are passed to the callback in the order that they are loaded or saved by the component streaming system."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TContainedActionList enumerator, a TActionListEnumerator reference that enumerates the actions in the list.
        To process all actions, read Current from the enumerator within a ?while MoveNext do? loop."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def UpdateAction(self, Action: BasicAction) -> bool:
        """TContainedActionList.UpdateAction(Action: BasicAction) -> bool
        Generates an OnUpdate event.
        Typically, applications do not call the UpdateAction method. Instead, the action indicated by the Action parameter calls UpdateAction when informed by the application that it can update itself. It is possible, however, to call UpdateAction to generate an OnUpdate event even though this has not been initiated by the application.
        UpdateAction invokes the OnUpdate event handler for the action list. It returns True if the event handler updates the action, False otherwise."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ContainedBindComponent(BasicBindComponent):
    """Base class for all common binding components descending from it.
    TContainedBindComponent is an abstract class that is the base class for TCommonBindComponent."""
    __hash__: ClassVar[None] = ...
    BindingsList: CustomBindingsList
    """CustomBindingsList: Specifies a list that holds the binding expressions."""
    Category: str
    """str: Specifies a category for this component.
        For example, for a binding expression called BindExpressionForm121, of type TBindExpression, the following code:
        
          ShowMessage(BindExpressionForm121.Category);
        
        shows the following message: Binding Expressions."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    ControlComponent: Component
    """Component: Specifies the component that will be bound to the source component, by means of LiveBindings."""
    DisplayName: str
    """str: Returns a string containing the name of this component."""
    Index: int
    """int: Returns the index of this component in the bindings list."""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def CanSetControlComponent(self, Value: Component) -> bool:
        """TContainedBindComponent.CanSetControlComponent(Value: Component) -> bool
        Returns whether the control component can be set a given value.
        As implemented in TContainedBindComponent, CanSetControlComponent always returns True, but in descendants it actually returns whether the given Value (that is itself a TComponent) can be assigned to the control component."""
    def Create(self, AOwner: Component) -> None:
        """TContainedBindComponent.Create(AOwner: Component) -> None
        Creates an instance of the TContainedBindComponent class."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of the TContainedBindComponent class."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def SetParentComponent(self, AParent: Component) -> None:
        """TContainedBindComponent.SetParentComponent(AParent: Component) -> None
        Sets the parent component of this component.
        SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Control(Component):
    """TControl is the base class for all components that are visible at run time.
    Controls are visual components, meaning the user can see them and possibly interact with them at run time. All controls have properties, methods, and events that describe aspects of their appearance, such as the position of the control, the cursor or hint associated with the control, methods to paint or move the control, and events that respond to user actions.
    TControl has many protected properties and methods that are used or published by its descendants."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    AlignWithMargins: bool
    """bool: Specifies whether a control should be constrained by margins.
        If AlignWithMargins is true, use the Margins property of the control to govern the spacing relative to other controls that are aligned with this one. The controls are not allowed to be any closer than the spacing specified in Margins. This spacing is maintained as controls are moved when the parent control resizes. 
        AlignWithMargins is true if the style csAlignWithMargins, a TControlStyle type, is in the control's ControlStyle property, and false otherwise."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BoundsRect: Rect
    """Rect: Specifies the bounding rectangle of the control, expressed in the coordinate system of the parent control.
        Use BoundsRect as a quick way to obtain the pixel locations of all corners of the control all at once.
        For example, the statement
        
        
        
        R := Control.BoundsRect;
        
        
        
        
        R = Control->BoundsRect;
        
        
        
        corresponds to
        
        
        
        R.Left := Control.Left;
        R.Top := Control.Top;
        R.Right := Control.Left + Control.Width;
        R.Bottom := Control.Top + Control.Height;
        
        
        
        
        R.Left = Control->Left;
        R.Top = Control->Top;
        R.Right = Control->Left + Control->Width;
        R.Bottom = Control->Top + Control->Height;
        
        
        
        The origin of the pixel coordinate system is in the upper-left corner of the parent window.
        
        Note:  A point is considered within the control's bounds rectangle if it lies on the left or top side but not if it lies on the right or bottom side. That is, to be inside the bounds rectangle, the x-coordinate must be greater than or equal to BoundsRect.Left and less than BoundsRect.Right, and the y-coordinate must be greater than or equal to BoundsRect.Top and less than BoundsRect.Bottom."""
    ClientHeight: int
    """int: Specifies the height of the control's client area in pixels.
        Use ClientHeight to read or change the height of the control's client area.
        For TControl, ClientHeight is the same as Height. Derived classes may implement a ClientHeight property that differs from Height. For example, the ClientHeight of a form is the value of the Height property minus the height of the title bar, resize border, and scroll bars."""
    ClientOrigin: Point
    """Point: Specifies the screen coordinates (in pixels) of the upper-left corner of a control's client area.
        Read ClientOrigin to locate the upper-left corner of the control's client area. ClientOrigin returns X and Y coordinates as a TPoint type, where X specifies the horizontal coordinate of the point and Y specifies the vertical coordinate. 
        The screen coordinates of a control that is descended from TControl and not TWinControl are the screen coordinates of the control's parent added to its Left and Top properties. If the control doesn't have a parent, an EInvalidOperation exception is raised when ClientOrigin is read."""
    ClientRect: Rect
    """Rect: Specifies the size of a control's client area in pixels.
        Read ClientRect to find out the size of the client area of a control. ClientRect returns a rectangle with its Top and Left fields set to zero, and its Bottom and Right fields set to the control's Height and Width, respectively. ClientRect is equivalent to Rect(0, 0, ClientWidth, ClientHeight). 
        A point is considered within the control's client rectangle if it lies on the left or top side but not if it lies on the right or bottom side. That is, to be inside the client rectangle, the X-coordinate must be greater than or equal to ClientRect.Left and less than ClientRect.Right, and the Y-coordinate must be greater than or equal to ClientRect.Top and less than ClientRect.Bottom. 
        
        Note: ClientRect is the size of the physical client area of the control, not its logical client area. If the control supports scrolling, the ClientRect is not the entire scrolling range, but only the region that is available at any given time."""
    ClientWidth: int
    """int: Specifies the horizontal size of the control's client area in pixels.
        Use ClientWidth to read or change the width of the control's client area. ClientWidth is equivalent to ClientRect.Right.
        For TControl, ClientWidth is the same as Width. Derived classes may implement a ClientWidth property that differs from Width. For example, the ClientWidth of a form is the value of the Width property minus the width of the resize border and scroll bars."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlState: ControlState
    """ControlState: Specifies the current state of a control at run time.
        Read ControlState to find out various conditions that affect the control such as whether it has been clicked or needs alignment. ControlState reflects transient conditions of an instance of the control, as opposed to attributes of the control class as a whole. ControlState consists of a set of flags drawn from the following values: 
        
        
        
        
        
        Flag
        
        Meaning
        
        
        
        csLButtonDown
        
        
        
        The left mouse button was clicked and not yet released. This is set for all mouse-down events.
        
        
        
        
        csClicked
        
        
        
        The same as csLButtonDown, but only set if ControlStyle contains csClickEvents, meaning that mouse-down events are interpreted as clicks.
        
        
        
        
        csPalette
        
        
        
        The system palette has changed and the control or one of its descendants has not finished adjusting by realizing its palette.
        
        
        
        
        csReadingState
        
        
        
        The control is reading its state from a stream.
        
        
        
        
        csAlignmentNeeded
        
        
        
        The control needs to realign itself when alignment is re-enabled.
        
        
        
        
        csFocusing
        
        
        
        The application is processing messages intended to give the control focus. This does not guarantee the control will receive focus, but prevents recursive calls.
        
        
        
        
        csCreating
        
        
        
        The control and/or its owner and subcontrols are being created. This flag clears when all have finished creating.
        
        
        
        
        csPaintCopy
        
        
        
        The control is being replicated, meaning a copy of the control is being painted. The ControlStyle flag csReplicatable must be set for this state to occur.
        
        
        
        
        csCustomPaint
        
        
        
        The control is processing custom paint messages.
        
        
        
        
        csDestroyingHandle
        
        
        
        The control's window is being destroyed.
        
        
        
        
        csDocking
        
        
        
        The control is being docked.
        
        
        
        
        The flags in ControlState are specific to controls, and augment the state flags in the ComponentState property.
        ControlState is primarily used by component writers in the implementation of components derived from TControl."""
    ControlStyle: ControlStyle
    """ControlStyle: Determines style characteristics of the control.
        Use ControlStyle to determine various attributes of the control, such as whether the control can capture the mouse or has a fixed size. The ControlStyle property contains a set of style flags indicating these attributes. The following table lists the flags and their meanings:
        
        
        
        
        
        Flag
        
        Meaning
        
        
        
        csAcceptsControls
        
        
        
        The control becomes the parent of any controls dropped on it at design time.
        
        
        
        
        csCaptureMouse
        
        
        
        The control captures mouse events when it is clicked.
        
        
        
        
        csDesignInteractive
        
        
        
        The control maps right mouse button clicks at design time into left mouse button clicks to manipulate the control.
        
        
        
        
        csClickEvents
        
        
        
        The control can receive and respond to mouse clicks. Some controls may not inherit this attribute, for example, TButton.
        
        
        
        
        csFramed
        
        
        
        The control has a 3D frame.
        
        
        
        
        csSetCaption
        
        
        
        The control's Caption should match the Name if it has not been explicitly set to something else.
        
        
        
        
        csOpaque
        
        
        
        The control completely fills its client rectangle.
        
        
        
        
        csDoubleClicks
        
        
        
        The control can receive and respond to double-click messages. Otherwise, map double-clicks into clicks.
        
        
        
        
        csFixedWidth
        
        
        
        The width of the control does not vary or scale.
        
        
        
        
        csFixedHeight
        
        
        
        The height of the control does not vary or scale.
        
        
        
        
        csNoDesignVisible
        
        
        
        The control is not visible at design time.
        
        
        
        
        csReplicatable
        
        
        
        The control can be copied using the PaintTo method to draw its image to an arbitrary canvas.
        
        
        
        
        csNoStdEvents
        
        
        
        Standard events such as mouse, key, and click events are ignored. This flag allows an application to run faster when there is no need to respond to these events.
        
        
        
        
        csDisplayDragImage
        
        
        
        If a control that has an associated drag image list is dragged across a control with this setting, then the image list is used to enhance the drag cursor while the cursor is over it. Otherwise, the drag cursor is used on its own.
        
        
        
        
        csReflector
        
        
        
        The control responds to Windows dialog messages, focus messages, or size change messages. Use this setting if the control can be used as an ActiveX control, so that it receives notification of these events.
        
        
        
        
        csActionClient
        
        
        
        The control is linked to an action object. This flag is set when the Action property is set, and cleared if the Action property is cleared.
        
        
        
        
        csMenuEvents
        
        
        
        The control responds to system menu commands.
        
        
        
        
        ControlStyle describes all controls instantiated from a given class. ControlStyle should not be modified at run time, except in the constructor. The ControlState property records transient conditions.
        The TControl constructor initializes ControlStyle to the set of csCaptureMouse, csClickEvents, csSetCaption, and csDoubleClicks.
        ControlStyle is primarily used by component writers when implementing components derived from TControl."""
    CurrentPPI: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    Cursor: int
    """int: Specifies the image used to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. The value of Cursor is the index of the cursor in the list of cursors maintained by the global variable, Screen. In addition to the built-in cursors provided by TScreen, applications can add custom cursors to the list."""
    CustomHint: CustomHint
    """CustomHint: CustomHint is a custom hint for the control.
        CustomHint is a TCustomHint instance for a control to specify the appearance of the control's hint."""
    DockOrientation: DockOrientation
    """DockOrientation: DockOrientation specifies how the control is docked relative to other controls docked in the same parent.
        Use DockOrientation to determine the position of the control relative to other controls docked to the same parent. Docking zones can be arranged from left to right or from top to bottom."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    ExplicitHeight: int
    """int: Specifies the explicit vertical size of the control in pixels.
        ExplicitHeight is a read-only property used internally by Delphi. Use Height in applications to allow read and write access."""
    ExplicitLeft: int
    """int: Specifies the explicit horizontal pixel coordinate of the left edge of a component relative to its parent.
        ExplicitLeft is a read-only property used internally by Delphi. Use Left in applications to allow read and write access."""
    ExplicitTop: int
    """int: Specifies the explicit vertical pixel coordinate of the top edge of a component relative to its parent.
        ExplicitTop is a read-only property used internally by Delphi. Use Top in applications to allow read and write access."""
    ExplicitWidth: int
    """int: Specifies the explicit horizontal size of the control in pixels.
        ExplicitWidth is a read-only property used internally by Delphi. Use Width in applications to allow read and write access."""
    Floating: bool
    """bool: Specifies whether the control is floating.
        Read Floating to determine whether a dockable control appears in a floating window, rather than docked to a parent control.
        
        Note:  Use Floating rather than the Parent property to determine whether a control is free-floating. Floating controls may have a non-nil (Delphi) or NULL (C++) parent if the FloatingDockSiteClass property specifies a floating window type."""
    FloatingDockSiteClass: WinControlClass
    """WinControlClass: Specifies the class of the temporary control that hosts the control when it is floating.
        Use FloatingDockSiteClass to specify the class that houses the control when it is floating. This class must be a descendant of TWinControl. By default, it is TCustomDockForm. When the control is undocked, a temporary control of this type is created and the control is docked to that control. When the control is docked to another control, the temporary floating dock site is freed.
        If the control can float as a stand-alone window, FloatingDockSiteClass is nil (Delphi) or NULL (C++)."""
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: The HelpContext property contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm help file, you must map symbolic Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set Vcl.Controls.TControl.HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control. 
        To use the Help, insert in the uses clause of your application the Vcl.HtmlHelpViewer or another unit that provides an interface to the external Help viewer to use. For C++, you need to include the HTMLHelpViewer.hpp header file."""
    HelpKeyword: str
    """str: The HelpKeyword property contains the keyword string that identifies the Help topic for the control.
        To enable the keyword-based context-sensitive Help for a control, set Vcl.Controls.TControl.HelpType to htKeyword and set HelpKeyword to a keyword string.
        No keyword (zero-length string, the default) means that no Help topic is provided for the control. 
        To use the Help, insert in the uses clause of your application the Vcl.HtmlHelpViewer or other unit that provides an interface to the external Help viewer to use. For C++, you need to include the HTMLHelpViewer.hpp header file."""
    HelpType: HelpType
    """HelpType: Specifies whether the control's context-sensitive Help topic is identified by a context ID or by keyword.
        Set HelpType to specify whether the control identifies its context-sensitive Help topic by a context ID or by keyword:
        
        When HelpType is htContext, the HelpContext property value identifies the control's Help topic.
        When HelpType is htKeyword, the HelpKeyword property value identifies the control's Help topic.
        To use the Help, insert in the uses clause of your application the Vcl.HtmlHelpViewer or another unit that provides an interface to the external Help viewer to use. For C++, you need to include the HTMLHelpViewer.hpp header file."""
    Hint: str
    '''str: Hint contains the text string that appears when the user moves the mouse over the control.
        Use the Hint property to provide a string of Help text either as a Help Hint or as Help text on a particular location, such as a status bar. 
        A Help Hint is a box containing Help text that appears for a control when the user moves the mouse pointer over the control and pauses momentarily. 
        To set up Help Hints
        
        Specify the Hint property of each control for which a Help Hint should appear.
        Set the ShowHint property of each appropriate control to True, or set the ParentShowHint property of all controls to True and set the ShowHint property of the form to True.
        At run time, set the value of the application\'s ShowHint property to True.
        To show the Hint on a status bar or another location, use the OnHint event handler of the application. The application\'s OnHint event occurs when the mouse pointer moves over the control.
        Specify a hint to be used for both a Help Hint box and by an OnHint event handler by specifying values separated by a | (pipe) character.
        For example,
        
        Edit1.Hint := \'Name|Enter Name in the edit box|1\';
        
        Edit1->Hint = "Name|Enter Name in the edit box|1";
        
        Here:
        
        The Name part is the short hint and appears at the top of the Help Hint box.
        Enter full name in the edit box is the long hint and appears below the short hint. It can be extracted using the GetLongHint function for use in an OnHint event handler.
        1 is an optional image index in an image list in the Images property of the control and specifies the index of the image to appear in the hint.
        If Hint contains only one value, the entire string is used as a Help Hint and returned by the GetLongHint and GetShortHint functions. If a control has no Hint value specified, but its parent control does, the control uses the value of the parent control (as long as the control\'s ShowHint property is True). 
        
        Note: If the application\'s ShowHint property is False, the Help Hint does not appear, but the OnHint event handler is still called.'''
    HostDockSite: WinControl
    """WinControl: Specifies the control in which the control is docked.
        Read HostDockSite to access the windowed control to which the control is docked. If the control is floating, HostDockSite is a temporary control of type FloatingDockSiteClass, or (if there is no floating dock site class) nil (Delphi) or NULL (C++).
        Most applications should use the ManualDock method rather than setting HostDockSite. Setting HostDockSite automatically undocks the control from its previous host (if any) and docks it to the specified control, but does not adjust the control's position and alignment and bypasses the standard docking events.
        For dock clients, the value of HostDockSite is the same as the value of Parent. For controls that are not docking clients, HostDockSite is nil (Delphi) or NULL (C++), while Parent specifies the containing control."""
    LRDockWidth: int
    '''int: Specifies the width of the control when it is docked horizontally.
        Read LRDockWidth to get the width of the control from the last time it was docked horizontally. Set LRDockWidth to indicate the width the control should have the next time it is docked horizontally.
        LRDockWidth allows a control to "remember" its docked size even when its width changes because it is undocked or docked with a vertical orientation.'''
    Left: int
    """int: Specifies the horizontal coordinate of the left edge of a component relative to its parent.
        Use the Left property to determine where the left side of the control begins or to reposition the left side of the control.
        If the control is contained in another control, the Left and Top properties are relative to the parent control. If the control is contained directly by the form, the property values are relative to the form. For forms, the value of the Left property is relative to the screen in pixels."""
    Margins: Margins
    """Margins: Specifies the margins of the control.
        Use the Margins property to set the margins of the control.
        If AlignWithMargins is true, then the Margins property of the control governs the spacing relative to other controls that are aligned with this one. The controls are not allowed to be closer than the spacing specified in Margins. 
        
        Note:  The Margins you set for the control have effect only when AlignWithMargins is set to true and Align is not set to alNone."""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentCustomHint: bool
    """bool: Specifies where a control looks for its custom hint.
        To have a control use the same hint customization information as its parent control, set ParentCustomHint to true.
        If ParentCustomHint is false, the control uses its own CustomHint property. 
        Set ParentCustomHint to true for all controls to ensure that all the controls on a form display their hint messages alike.
        When the value of a control's CustomHint property changes, ParentCustomHint becomes false automatically."""
    ScaleFactor: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TBDockHeight: int
    '''int: Specifies the height of the control when it is docked vertically.
        Read TBDockHeight to get the height of the control from the last time it was docked vertically. Set TBDockHeight to indicate the height the control should have the next time it is docked vertically.
        TBDockHeight allows a control to "remember" its docked size even when its height changes because it is undocked or docked with a horizontal orientation.'''
    Top: int
    """int: Specifies the Y coordinate of the upper-left corner of a control, relative to its parent or containing control in pixels.
        Use Top to locate the top of the control or reposition the control to a different Y coordinate. The Top property, like the Left property, is the position of the control relative to its container. Thus, if a control is contained in a TPanel, the Left and Top properties are relative to the panel. If the control is contained directly by the form, it is relative to the form. For forms, the value of the Top property is relative to the screen in pixels."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    UndockHeight: int
    '''int: Specifies the height of the control when it is floating.
        Read UndockHeight to get the height of the control from the last time it was floating. Set UndockHeight to indicate the height the control should have the next time it is undocked.
        UndockHeight allows a control to "remember" its floating size even when its height changes because it is docked.'''
    UndockWidth: int
    '''int: Specifies the width of the control when it is floating.
        Read UndockWidth to get the width of the control from the last time it was floating. Set UndockWidth to indicate the width the control should have the next time it is undocked.
        UndockWidth allows a control to "remember" its floating size even when its width changes because it is docked.'''
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    WindowProc: Callable[[Message],None]
    """Callable[[Message], None]:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BeginDrag(self, Immediate: bool, Threshold: int) -> None:
        """TControl.BeginDrag(Immediate: bool, Threshold: int) -> None
        Starts the dragging of a control.
        Call BeginDrag to start a drag operation. BeginDrag is called in application code only when the value of the control's DragMode is dmManual. If DragMode is dmAutomatic, BeginDrag is called automatically.
        If the Immediate parameter is true, the mouse pointer changes to the value of the DragCursor property and dragging begins immediately. If Immediate is false, the mouse pointer does not change to the value of the DragCursor property and dragging does not begin until the user moves the mouse pointer the number of pixels specified by the Threshold parameter. If the caller passes a Threshold value less than 0 (such as the default value for this parameter), BeginDrag uses the DragThreshold property of the global Mouse variable.
        Setting Immediate to false allows the control to accept mouse clicks without beginning a drag-and-drop or drag-and-dock operation."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CheckNonMainThreadUsage(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def ClientToParent(self, Point: Point, AParent: WinControl) -> Point:
        """TControl.ClientToParent(Point: Point, AParent: WinControl) -> Point
        Translates client coordinates to parent coordinates.
        ClientToParent translates Point from the current control's coordinate system to AParent's coordinate system. AParent must be a control that can be found by iterating up the chain of Parent properties. If AParent is nil (Delphi) or NULL (C++), the control's immediate parent is used.
        An EInvalidOperation exception is thrown if AParent is not an ancestor control or the Parent property is nil (Delphi) or NULL (C++)."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TControl.Create(AOwner: Component) -> None
        Creates an instance of TControl.
        Calling Create constructs and initializes an instance of TControl. However, you should never attempt to instantiate a TControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants.
        Create calls the parent constructor and initializes the control. 
        When overriding Create, always call the inherited Create method first, then proceed with the control's initialization. Remember to specify the override directive when overriding the Create method.
        
        Note:  If a control's constructor allocates resources or memory, also override the destructor to free those resources."""
    def DefaultHandler(self, Message) -> None:
        """TControl.DefaultHandler(Message) -> None
        Provides message handling for all messages that do not have specific handlers.
        Override DefaultHandler to extend the default handling of messages. DefaultHandler is the final opportunity for component writers to handle messages to controls. The method referenced by WindowProc provides the first opportunity. Individual message methods such as Click provide additional opportunities.
        DefaultHandler handles the messages Windows sends to manage the control's text: WM_GETTEXT, WM_SETTEXT, and WM_GETTEXTLENGTH."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy.
        Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
        As the control is destroyed, it:
        
        Frees the TFont object in its Font property.
        Calls its inherited destructor.
        Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method.
        When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents."""
    def Dock(self, NewDockSite: WinControl, ARect: Rect) -> None:
        """TControl.Dock(NewDockSite: WinControl, ARect: Rect) -> None
        Used internally to dock the control.
        Do not call Dock in applications. It is called automatically to implement many of the details of docking the control to a dock site.
        To dock the control programmatically, use ManualDock instead.
        The NewDockSite parameter specifies the docking site to which the control is being docked. The ARect parameter indicates the new dimensions of the control when it is docked to NewDockSite."""
    def DragDrop(self, Source: Object, X: int, Y: int) -> None:
        """TControl.DragDrop(Source: Object, X: int, Y: int) -> None
        Is an OnDragDrop event dispatcher.
        When creating a component that descends from TControl, override DragDrop to add additional code that executes before the OnDragDrop event handler is called.
        The Source parameter is the object that was dropped onto the control. The X and Y parameters are the mouse coordinates where the object was dropped."""
    def Dragging(self, *args, **kwargs) -> Any:
        """Indicates whether a control is being dragged.
        Use Dragging to determine the drag state of the control. If Dragging returns true, the control is being dragged. If Dragging is false, the control is not being dragged."""
    def DrawTextBiDiModeFlags(self, Flags: int) -> int:
        """TControl.DrawTextBiDiModeFlags(Flags: int) -> int
        Returns the text flags that reflect the current setting of the BiDiMode property.
        Call DrawTextBiDiModeFlags to obtain a value for the TextFlags property of a canvas when drawing the control's text or caption. The return value can also be used with the Windows API DrawText function.
        Flags are the current text flags, unaltered by any bidirectional mode considerations.
        DrawTextBiDiModeFlags adds or removes the DT_RIGHT or DT_RTLREADING flags based on the values returned from the UseRightToLeftAlignment and UseRightToLeftReading methods."""
    def DrawTextBiDiModeFlagsReadingOnly(self, *args, **kwargs) -> Any:
        """Returns the text flag to add that indicates whether the control's text should read from right to left.
        Call DrawTextBiDiModeFlagsReadingOnly to determine whether the DT_RTLREADING flag should be added when calling the Windows API DrawText or when assigning the TextFlags property of a canvas.
        DrawTextBiDiModeFlagsReadingOnly returns the DT_RTLREADING flag or 0, depending on the value returned from the UseRightToLeftReading method.
        To obtain the text flags that indicate the bidirectional alignment as well as text direction for the control, use DrawTextBiDiModeFlags instead."""
    def EndDrag(self, Drop: bool) -> None:
        """TControl.EndDrag(Drop: bool) -> None
        Stops a control from being dragged any further.
        Use EndDrag to stop a dragging operation that began with a call to the BeginDrag method.
        If the Drop parameter is true, the control being dragged is dropped or docked. If the Drop parameter is false, the control is not dropped or docked and dragging is canceled."""
    def GetControlsAlignment(self, *args, **kwargs) -> Any:
        """Indicates how text is aligned within the control.
        Use GetControlsAlignment to determine the alignment of the control. For controls that do not have an Alignment property, GetControlsAlignment returns taLeftJustify.
        
        Note: GetControlsAlignment returns the alignment of text before it is altered by the BiDiMode property. To check whether the alignment should be reversed to reflect the BiDiMode property, call UseRightToLeftAlignment."""
    def GetParentComponent(self, *args, **kwargs) -> Any:
        """Returns the parent of the control.
        GetParentComponent is called by the streaming system that loads and saves VCL components. The component returned by GetParentComponent is responsible for loading and saving the control when it is streamed in or out. As implemented in TControl, GetParentComponent returns the value of the Parent property."""
    def GetStyleName(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetSystemMetrics(self, nIndex: int) -> int:
        """TControl.GetSystemMetrics(nIndex: int) -> int
        Embarcadero Technologies does not currently have any additional information."""
    def GetTextBuf(self, Buffer: PWideChar, BufSize: int) -> int:
        """TControl.GetTextBuf(Buffer: PWideChar, BufSize: int) -> int
        Retrieves the control's text, copies it into a buffer, and returns the number of characters copied.
        Call GetTextBuf to retrieve the text of a control into a fixed size buffer. The text copied is the value of the Text property. GetTextBuf returns the number of characters that were actually copied, which is either the length of the Text property, or BufSize - 1, whichever is smaller.
        To find out how many characters the buffer needs to hold the entire text, call the GetTextLen method before allocating a buffer for GetTextBuf.
        
        Note: GetTextBuf is available for compatibility with 16-bit code. Where backward compatibility is not an issue, use the Text property.
        Note:  To obtain the control's text as an AnsiString, use the Text property instead."""
    def GetTextLen(self, *args, **kwargs) -> Any:
        """Returns the length of the control's text.
        Call GetTextLen to find the length of the control's text. This is the size needed for a text buffer to be used by the GetTextBuf method."""
    def HasParent(self, *args, **kwargs) -> Any:
        """Indicates whether the control has a parent.
        HasParent indicates whether the Parent property has been assigned a value. This method is used by the streaming system to determine whether the control has a parent that is responsible for writing it to a stream. As implemented in TControl, HasParent returns true if the Parent property is not nil (Delphi) or NULL (C++), and false otherwise."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def InitiateAction(self, *args, **kwargs) -> Any:
        """Calls the action link's Update method if the control is associated with an action link.
        When the application is idle, the library makes a series of calls to allow controls to update their associated actions so that they reflect the current properties of the controls. The first of these is to the InitiateAction method of the each form, followed by the InitiateAction methods of its visible menus and controls.
        InitiateAction calls the action's update method indirectly (through its action link), which leads to a number of events, any of which may update the action and stop the update process:
        
        First, the action list that contains the action receives an OnUpdate event.
        If the action list does not handle the OnUpdate event, then the Application object receives an OnActionUpdate event.
        If the OnActionUpdate event handler does not update the action, the action itself receives an OnUpdate event.
        If that does not update the action, the active control's UpdateAction method is called.
        Finally, if the action is still not updated, the active form's UpdateAction method is called."""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def IsCustomStyleActive(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def IsLightStyleColor(self, AColor: int) -> bool:
        """TControl.IsLightStyleColor(AColor: int) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def IsRightToLeft(self, *args, **kwargs) -> Any:
        """Indicates whether the control should be reversed right to left.
        Use IsRightToLeft to determine whether the control should be reversed in any way because it is running on a system with a Middle Eastern locale. IsRightToLeft is intended for component writers to ease the process of implementing the BiDiMode property.
        IsRightToLeft returns true if the application is running on a Middle East-enabled version of Windows and the BiDiMode property indicates that the control should make any adjustments."""
    def ManualDock(self, NewDockSite: WinControl, DropControl: Control, ControlSide: Align) -> bool:
        """TControl.ManualDock(NewDockSite: WinControl, DropControl: Control, ControlSide: Align) -> bool
        Docks the control.
        Use ManualDock to dock the control programmatically. ManualDock undocks the control from its current dock site, then docks the control to its new dock site.
        NewDockSite is the control's new dock site.
        DropControl is the control in the new dock site, if any, on which to drop the control. For example, when docking to a page control, DropControl would be a tab sheet.
        ControlSide specifies on which side of DropControl or NewDockSite (if DropControl is nil (Delphi) or NULL (C++)) the control should be docked. This value can be obtained by calling the dock site's GetDockEdge method."""
    def ManualFloat(self, ScreenPos: Rect) -> bool:
        """TControl.ManualFloat(ScreenPos: Rect) -> bool
        Undocks the control.
        Use ManualFloat to undock the control programmatically.
        ScreenPos is the rectangle in which the control is displayed when it starts floating."""
    def MouseWheelHandler(self, Message: Message) -> None:
        """TControl.MouseWheelHandler(Message: Message) -> None
        Dispatches messages received from a mouse wheel.
        The WndProc method calls MouseWheelHandler when it receives a mouse wheel message. MouseWheelHandler checks whether the windowed control is embedded in a form, and if so, calls the form's MouseWheelHandler method. This allows the form to respond to mouse wheel messages before they are handled by individual controls. If the windowed control is not in a form, MouseWheelHandler passes the mouse wheel message to the Perform method, which generates an OnMouseWheel event, followed (if necessary) by an OnMouseWheelUp or OnMouseWheelDown event."""
    def ParentToClient(self, Point: Point, AParent: WinControl) -> Point:
        """TControl.ParentToClient(Point: Point, AParent: WinControl) -> Point
        Translate parent coordinates to client coordinates.
        ParentToClient translates Point from the AParent's coordinate system to the current control's coordinate system. AParent must be a control that can be found by iterating up the chain of Parent properties. If AParent is nil (Delphi) or NULL (C++), the control's immediate parent is used.
        An EInvalidOperation exception is thrown if AParent is not an ancestor control or the Parent property is nil (Delphi) or NULL (C++)."""
    def Perform(self, Msg: int, WParam: int, LParam: int) -> int:
        """TControl.Perform(Msg: int, WParam: int, LParam: int) -> int
        Responds as if the control received a specified Windows message.
        Call Perform to bypass the Windows message queue and send a message directly to the control's window procedure.
        Perform fills a message record (of type TMessage) with the message ID passed in the Msg parameter, the message parameters passed in WParam and LParam, and a result field of zero. Perform then passes the message record to the WindowProc method for processing.\r
        Responds as if the control received a specified Windows message.
        Call Perform to bypass the Windows message queue and send a message directly to the control's window procedure.
        Perform fills a message record (of type TMessage) with the message ID passed in the Msg parameter, the message parameters passed in WParam and LParam, and a result field of zero. Perform then passes the message record to the WindowProc method for processing.\r
        Responds as if the control received a specified Windows message.
        Call Perform to bypass the Windows message queue and send a message directly to the control's window procedure.
        Perform fills a message record (of type TMessage) with the message ID passed in the Msg parameter, the message parameters passed in WParam and LParam, and a result field of zero. Perform then passes the message record to the WindowProc method for processing."""
    def Refresh(self, *args, **kwargs) -> Any:
        """Repaints the control on the screen.
        Call the Refresh method to repaint the control immediately. Refresh calls the Repaint method. Use the Refresh and Repaint methods interchangeably."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ReplaceDockedControl(self, Control: Control, NewDockSite: WinControl, DropControl: Control, ControlSide: Align) -> bool:
        """TControl.ReplaceDockedControl(Control: Control, NewDockSite: WinControl, DropControl: Control, ControlSide: Align) -> bool
        Docks the control in the place where another control is already docked.
        Call ReplaceDockedControl to replace a control that is already docked while moving that control to another dock site.
        Control is the control whose place this control is taking.
        NewDockSite is the new dock site for the control that is replaced.
        DropControl is a control in the new dock site on which to drop the control that is replaced. For example, if NewDockSite were a page control, DropControl would be a tab sheet.
        ControlSide specifies on which side of DropControl or NewDockSite (if DropControl is nil (Delphi) or NULL (C++)) the replaced control should be docked. This value can be obtained by calling the dock site's GetDockEdge method.
        ReplaceDockedControl does the same thing as calling the ManualDock method of the control specified by the Control parameter (using the values of NewDockSite, DropControl, and ControlSide) in addition to calling ManualDock for the control whose method this is, docking it in the current position of the Control parameter. However, calling ReplaceDockedControl is more efficient, and prevents unnecessary flicker."""
    def ScaleForPPI(self, NewPPI: int) -> None:
        """TControl.ScaleForPPI(NewPPI: int) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def ScaleRectSize(self, Value: Rect) -> Rect:
        """TControl.ScaleRectSize(Value: Rect) -> Rect
        Embarcadero Technologies does not currently have any additional information."""
    def ScaleValue(self, Value: int) -> int:
        """TControl.ScaleValue(Value: int) -> int
        The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property).\r
        The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property).\r
        The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property).\r
        The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property).\r
        The overloaded ScaleValue methods return a measure passed as parameter scaled by the current scale factor for the control (the value of the ScaleFactor read-only property)."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def SetDesignVisible(self, Value: bool) -> None:
        """TControl.SetDesignVisible(Value: bool) -> None
        Makes a control visible at design time.
        SetDesignVisible is used internally by Delphi during form design."""
    def SetParentComponent(self, Value: Component) -> None:
        """TControl.SetParentComponent(Value: Component) -> None
        Sets the parent for the control.
        Do not call the SetParentComponent method. It is used by the streaming system that loads and saves VCL components. SetParentComponent makes the component specified by the Value parameter the parent of the control.
        SetParentComponent calls the SetParent method only if the component specified as the parent is a windowed control."""
    def SetTextBuf(self, Buffer: PWideChar) -> None:
        """TControl.SetTextBuf(Buffer: PWideChar) -> None
        Sets the text of the control.
        Call the SetTextBuf method to set the text of the control to the text in the specified buffer.
        The text is set to the text in the buffer pointed to by the Buffer parameter. Buffer must point to a null-terminated string. The SetTextBuf method sends the WM_SETTEXT and CM_TEXTCHANGED messages. Doing this in the tight execution of a function can result in the change not being seen until messages from the Windows message queue are processed after the function finishes executing. To interrupt a function's execution and process messages, use the ProcessMessages method of the Application object.
        
        Note:  The SetTextBuf method is provided for backwards compatibility only. To set the text of a control now, assign a string value to the Text property."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def UseRightToLeftAlignment(self, *args, **kwargs) -> Any:
        """Specifies whether the control's alignment should be reversed right-to-left.
        Controls call UseRightToLeftAlignment when implementing the BiDiMode property. UseRightToLeftAlignment indicates whether the control's alignment should be reversed right-to-left. This information can be used when painting the control or when responding to mouse events.
        UseRightToLeftAlignment returns True if the application is running on a system with a Middle Eastern locale and the BiDiMode property is bdRightToLeft. Otherwise, it returns False. Descendants override UseRightToLeftAlignment if alignment in Middle Eastern locales depends on other factors."""
    def UseRightToLeftReading(self, *args, **kwargs) -> Any:
        """Specifies whether the control is using a right-to-left reading order.
        Controls call UseRightToLeftReading when implementing the BiDiMode property. UseRightToLeftReading indicates whether the control's text should read from right to left. This information can be used to determine which style flags to set for the control when it is created and which flags to set for drawing text.
        UseRightToLeftReading returns true if the application is running on a system with a Middle Eastern locale and the BiDiMode property is not bdLeftToRight. UseRightToLeftReading returns false otherwise."""
    def UseRightToLeftScrollBar(self, *args, **kwargs) -> Any:
        """Specifies whether the vertical scroll bar appears on the left side of the control.
        Controls call UseRightToLeftScrollBar when implementing the BiDiMode property. UseRightToLeftScrollBar returns true when the vertical scroll bar appears on the left side of the control, and false when it appears on the right side.
        UseRightToLeftScrollBar returns true if the application is running on a system with a Middle Eastern locale and the BiDiMode property is bdRightToLeft or bdRightToLeftNoAlign."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ControlBar(CustomControl):
    """TControlBar manages the layout of toolbar components.
    Use TControlBar as a docking site for toolbar components. Control bars contain child controls (usually TToolBar objects) that can be moved and resized independently. As with a cool bar, each child control resides on its own individual band that the user positions by dragging its sizing grip.
    
    Tip:  When docking TToolBar objects to a control bar, you may find it useful to use TToolDockObject.
    Note:  If you want to use TActionToolBar on a TControlBar component, you should set the AutoSize property to False. When the AutoSize property is set to True (default), the TActionToolBar control wraps its controls and expands itself in size, accordingly. This does not allow the TActionToolBar component to display properly on a TControlBar component. When the AutoSize property is set to False, the TActionToolBar hides items on the end of the bar and displays a dropdown button that provides access to those items. The control displays in the proper size."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoDock: bool
    """bool:"""
    AutoDrag: bool
    """bool:"""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BevelWidth: int
    """int: Specifies the width of the inner and outer bevels.
        Use BevelWidth to specify the width, in pixels, of the inner and outer bevels."""
    BorderWidth: int
    """int: Specifies the width of the control's border.
        Use BorderWidth to get or set the width of the control's border. Graphics or text drawn by the control is clipped to the area within the border."""
    Canvas: Canvas
    """Canvas: Specifies the TCanvas object that presents a drawing surface for the control.
        Use the properties of the TCanvas object to draw or paint on the surface of the control. Canvas encapsulates a Windows device context, providing all the tools and methods needed for drawing and painting.
        Canvas is a protected property that is usually redeclared as public in descendants of TCustomControl."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    CornerEdge: CornerEdge
    """CornerEdge:"""
    DockSite: bool
    """bool: Specifies whether the control can be the target of drag-and-dock operations.
        Set DockSite to true to allow other controls to be docked to this windowed control.
        
        Code Examples
        Docking (Delphi)
        Docking (C++)"""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    DrawingStyle: BandDrawingStyle
    """BandDrawingStyle:"""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    GradientDirection: GradientDirection
    """GradientDirection:"""
    GradientEndColor: int
    """int:"""
    GradientStartColor: int
    """int:"""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnAlignInsertBefore: Callable[[WinControl,Control,Control],bool]
    """Callable[[WinControl, Control, Control], bool]:"""
    OnAlignPosition: Callable[[WinControl,Control,int,int,int,int,Rect,AlignInfo],None]
    """Callable[[WinControl, Control, int, int, int, int, Rect, AlignInfo], None]:"""
    OnBandDrag: Callable[[Object,Control,bool],None]
    """Callable[[Object, Control, bool], None]:"""
    OnBandInfo: Callable[[Object,Control,Rect,int,int],None]
    """Callable[[Object, Control, Rect, int, int], None]:"""
    OnBandMove: Callable[[Object,Control,Rect],None]
    """Callable[[Object, Control, Rect], None]:"""
    OnBandPaint: Callable[[Object,Control,Canvas,Rect,BandPaintOptions],None]
    """Callable[[Object, Control, Canvas, Rect, BandPaintOptions], None]:"""
    OnBeginBandMove: Callable[[Object,Control,bool],None]
    """Callable[[Object, Control, bool], None]:"""
    OnCanResize: Callable[[Object,int,int,bool],None]
    """Callable[[Object, int, int, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnConstrainedResize: Callable[[Object,int,int,int,int],None]
    """Callable[[Object, int, int, int, int], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDockDrop: Callable[[Object,DragDockObject,int,int],None]
    """Callable[[Object, DragDockObject, int, int], None]:"""
    OnDockOver: Callable[[Object,DragDockObject,int,int,DragState,bool],None]
    """Callable[[Object, DragDockObject, int, int, DragState, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndBandMove: Callable[[Object,Control],None]
    """Callable[[Object, Control], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetSiteInfo: Callable[[Object,Control,Rect,Point,bool],None]
    """Callable[[Object, Control, Rect, Point, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnPaint: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnUnDock: Callable[[Object,Control,WinControl,bool],None]
    """Callable[[Object, Control, WinControl, bool], None]:"""
    ParentBackground: bool
    """bool: Determines whether the control uses its parent's theme background.
        If ParentBackground is True, the control uses the parent's theme background to draw its own background. 
        If  ParentBackground is False, the control uses its own properties, such as Color, to draw its background.
        ParentBackground has no effect unless XP themes are enabled."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    Picture: Picture
    """Picture:"""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    RowSize: int
    """int:"""
    RowSnap: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomAction(ContainedAction):
    """TCustomAction is the base class for VCL actions intended to be used with menu items and controls.
    TCustomAction introduces support for the properties, events, and methods of menu items and controls that are clients of action objects.
    Most properties and events introduced in TCustomAction are public; therefore, use TCustomAction as a base class when deriving your own actions that publish specific subset of properties of associated controls. 
    Action objects centralize the response to user commands (actions) and represent user interface elements in applications that use actions. They provide an easy way to synchronize, for example, the enabled state and caption of a speed button and a menu item, and handle the response when users click these components. Each such component, called the client, has its properties dynamically updated by the action and forwards user actions to the action for a response.
    At design time, you can work in the Action List editor with actions contained in an action list or in the Action Manager editor of the action manager. The action list or action manager is a container for actions, which it organizes into categories.
    Component and control public properties and events that are supported in TCustomAction, either directly or through an ancestor, are:
    
    Caption
    Checked
    Enabled
    HelpType
    HelpContext
    HelpKeyword
    Hint
    ImageIndex
    ShortCut
    Visible
    OnHint
    OnUpdate
    OnExecute
    Because the OnHint, OnUpdate, and OnExecute events are public, they do not appear in the Object Inspector. That is, the Object Inspector does not support generating custom event handlers for these events.
    TCustomAction can also act as the base class for predefined action classes. You can derive from TCustomAction if you want to retain the public scope of supported properties and events or modify the public scope to the published scope.  
    For predefined actions that augment the behavior of TCustomAction, see the action classes in the Vcl.StdActns, Vcl.DBActns, and Vcl.ExtActns units."""
    __hash__: ClassVar[None] = ...
    ActionComponent: Any
    """Indicates the client component that caused this action to execute."""
    ActionList: CustomActionList
    """CustomActionList: Holds the action list to which the action belongs.
        Vcl.ActnList.TCustomAction.ActionList inherits from System.Actions.TContainedAction.ActionList. All content below this line refers to System.Actions.TContainedAction.ActionList.
        Holds the action list to which the action belongs."""
    ImageName: str
    """str: Displays the name of linked items from the Image Collection."""
    Images: CustomImageList
    """CustomImageList: Embarcadero Technologies does not currently have any additional information."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TCustomAction.Create(AOwner: Component) -> None
        Instantiates and initializes a VCL TCustomAction object.
        Applications do not need to call the constructor directly. Actions are created automatically when you add them to an action manager (in the Action Manager editor) or action list component (in the Action List editor) at design time.
        If you want to create an action at run time, assign a
        TActionList or TActionManager component to its ActionList property after calling Create.
        AOwner is the component that is responsible for freeing the action. It becomes the value of the Owner property.
        Create simply calls an inherited System.Actions.TContainedAction.Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Frees an instance of TCustomAction.
        Do not call the destructor directly in an application. Instead, call Free. Free ensures that the action is not nil before calling the destructor.
        If the action is contained in an action list or action manager, Destroy removes the action from that list."""
    def Execute(self) -> Any:
        """TBasicAction.Execute()
        Generates an OnExecute event."""
    def Update(self) -> Any:
        """TBasicAction.Update()
        Provides an opportunity to execute centralized code when an application is idle."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomActionList(ContainedActionList):
    """The usual list of actions (without published properties) in VCL"""
    __hash__: ClassVar[None] = ...
    ActionCount: Any
    """Indicates the number of actions in the action list."""
    Actions: Any
    """Lists the actions maintained by the action list."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Images: CustomImageList
    """CustomImageList:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TCustomActionList.Create(AOwner: Component) -> None
        Creates an instance of TContainedActionList.
        This creator is inherited from TComponent, see TComponent.Create for more information."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TContainedActionList.
        This destructor is inherited from TComponent, see TComponent.Destroy for more information."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def IsShortCut(self, Message: WMKey) -> bool:
        """TCustomActionList.IsShortCut(Message: WMKey) -> bool"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomActivityIndicator(CustomControl):
    """The base class for TActivityIndicator.
    An animated rotating display indicating that the application is performing some activity. 
    Create the activity indicator, set the color, size and type, and call StartAnimation to start the animation. You can modify the speed of the animation with the FrameDelay property."""
    __hash__: ClassVar[None] = ...
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    Parent: Any
    """Returns/Sets the Control Parent"""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TCustomActivityIndicator.Create(AOwner: Component) -> None
        Creates an instance of the TCustomActivityIndicator.
        Create sets the default values for all the activity indicator properties."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TCustomControl.
        Vcl.WinXCtrls.TCustomActivityIndicator.Destroy inherits from Vcl.Controls.TCustomControl.Destroy. All content below this line refers to Vcl.Controls.TCustomControl.Destroy.
        Destroys an instance of TCustomControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy. 
        Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
        As the control is destroyed, it destroys the TCanvas object in its Canvas property. 
        Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method. 
        When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def StartAnimation(self, *args, **kwargs) -> Any:
        """Sets the Animate property to True."""
    def StopAnimation(self, *args, **kwargs) -> Any:
        """Sets the Animate property to False."""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomBindingsList(Component):
    """Represents the base class for the binding list.
    The TCustomBindingsList class implements a list of binding expressions, output converters, method scopes, and other binding list-related functionality."""
    __hash__: ClassVar[None] = ...
    BindCompCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    BindComps: ContainedBindComponent
    """ContainedBindComponent:"""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    DependencyList: IDependencyList
    """IDependencyList: Embarcadero Technologies does not currently have any additional information."""
    Methods: Methods
    """Methods: Specifies a list of available methods. For more information about these methods, read the LiveBindings Methods topic."""
    OutputConverters: OutputConverters
    """OutputConverters: Specifies a list of available output converters. For more information about output converters, read the LiveBindings Output Converters help topic."""
    Owner: Any
    """Returns the Component Owner"""
    PromptDeleteUnused: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseAppManager: bool
    """bool: Specifies whether the bindings list uses the global application manager for managed bindings."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TCustomBindingsList.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Data.Bind.Components.TCustomBindingsList.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Data.Bind.Components.TCustomBindingsList.Destroy inherits from System.Classes.TComponent.Destroy. All content below this line refers to System.Classes.TComponent.Destroy.
        Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TCustomBindingsList.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Enumerates all child components.
        Data.Bind.Components.TCustomBindingsList.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
        Enumerates all child components.
        GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
        GetChildren expects a TGetChildProc routine that receives all enumerated components. 
        Root represents the owner of the components that will be enumerated.
        This method does nothing in TComponent and is expected to be overridden in descendants."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TComponent enumerator.
        Data.Bind.Components.TCustomBindingsList.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
        Returns a TComponent enumerator.
        GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
        To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop."""
    def GetMethodsScope(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetOutputConverter(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def Notify(self, AObject: Object, AProperty: str) -> None:
        """TCustomBindingsList.Notify(AObject: Object, AProperty: str) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomControl(WinControl):
    """Base class for controls that wrap Windows screen objects but perform their own rendering.
    In most descendants of TWinControl, the job of drawing the control's surface belongs to the underlying Windows screen object. If a control has visible features that cannot be rendered by a Windows screen object, it requires access to a canvas object so it can do its own drawing.
    TCustomControl is one of two base classes for controls that draw their own surfaces. Because TCustomControl is descended from TWinControl, instances of its descendants can receive focus and serve as containers.
    Classes of controls that perform their own screen rendering and do not need the features of TWinControl should be descendants of TGraphicControl instead of TCustomControl. TGraphicControl objects can render themselves with less overhead, because they do not have underlying Windows screen objects.
    TCustomControl objects have a Paint method, which is called whenever the control needs to render its image. Custom controls paint themselves using the Canvas property."""
    __hash__: ClassVar[None] = ...
    Parent: Any
    """Returns/Sets the Control Parent"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TCustomControl.Create(AOwner: Component) -> None
        Creates an instance of TCustomControl.
        Calling Create constructs and initializes an instance of TCustomControl. However, you should never attempt to instantiate a TCustomControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants. Controls placed on forms at design time are created automatically.
        After calling the inherited constructor, Create initializes the control and also a TCanvas object for its Canvas property.
        When overriding Create, always call the inherited Create method first, then proceed with the control's initialization. Remember to specify the override directive when overriding the Create method.
        
        Note: If a component's constructor allocates resources or memory, also override the destructor to free those resources."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TCustomControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy. 
        Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
        As the control is destroyed, it destroys the TCanvas object in its Canvas property. 
        Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method. 
        When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomDrawGrid(CustomGrid):
    """TCustomDrawGrid is the base class for grids that publish events for painting and manipulating the cells in the grid.
    Use TCustomDrawGrid as a base class when defining grid components that publish events for painting or manipulating the cells in the grid. TCustomDrawGrid introduces a number of events and methods that take advantage of the tabular organization of the grid in responding to user actions.
    Do not create instances of TCustomDrawGrid. Instead, put a grid control in a form by instantiating a descendant of TCustomDrawGrid. Use TDrawGrid to represent non-textual material in a tabular grid. For text, use a TStringGrid object. If the text represents field values from a dataset, use TDBGrid. If you are displaying Name/Value pairs, use TValueListEditor."""
    __hash__: ClassVar[None] = ...
    Canvas: Any
    """Specifies the TCanvas object that presents a drawing surface for the control."""
    CellAlignments: Alignment
    """Alignment:"""
    Col: Any
    """Specifies the index of the column that contains the selected cell."""
    ColAlignments: Alignment
    """Alignment:"""
    ColWidths: Any
    """Specifies column widths of the grid"""
    DrawingStyle: GridDrawingStyle
    """GridDrawingStyle: Determines the style used when drawing the grid.
        DrawingStyle determines the style used to draw the grid. The following table lists the possible values of DrawingStyle. 
        
        
        
        
        Value
        
        Meaning
        
        
        
        gdsClassic
        
        
        
        The grid control uses the standard, unthemed style.
        
        
        
        
        gdsThemed
        
        
        
        The grid control uses the current operating system theme.
        
        
        
        
        gdsGradient
        
        
        
        The grid control uses gradients for styling.
        
        
        
        
        Notes about DrawingStyle for Vcl.Grids.TStringGrid:
        Setting FixedColor has no effect unless you also set DrawingStyle to gdsClassic.
        Setting GradientStartColor and GradientEndColor has no effect unless you set the value of DrawingStyle to gdsGradient."""
    EditorMode: Any
    """Determines whether the current cell can be edited."""
    GridHeight: Any
    """Specifies the height of the grid in pixels."""
    GridWidth: Any
    """Specifies the width of the grid in pixels."""
    LeftCol: Any
    """Specifies the index of the first visible scrollable column in the grid."""
    Row: Any
    """Specifies the index of the row that contains the selected cell."""
    RowHeights: Any
    """Specifies row heights of the grid"""
    Selection: Any
    """Indicates the boundaries of the current selection."""
    TabStops: bool
    """bool:"""
    TopRow: Any
    """Specifies the index of the first visible scrollable row in the grid."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def CellRect(self, ACol: int, ARow: int) -> Rect:
        """TCustomDrawGrid.CellRect(ACol: int, ARow: int) -> Rect
        Returns the screen coordinates of a cell in the grid.
        Call CellRect to obtain the boundaries, in pixels, of the cell in the column and row indicated by the ACol and ARow parameters. The top left cell is specified when ACol and ARow are set to zero.
        If the indicated cell is not visible, CellRect returns an empty rectangle."""
    def MouseToCell(self, X: int, Y: int, ACol: int, ARow: int) -> None:
        """TCustomDrawGrid.MouseToCell(X: int, Y: int, ACol: int, ARow: int) -> None
        Returns the column and row of the cell at the position with screen coordinates (X,Y).
        Call MouseToCell to convert from grid-relative screen coordinates to row and column indexes. The X and Y parameters are the screen coordinates of the point to be converted. MouseToCell returns the ACol parameter as the number of the column over the point (X,Y), and the ARow parameter as the number of the row. 
        Usually the MouseToCell method is used in a mouse event handler, which supplies the mouse coordinates as the X and Y parameters of the method call."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomEdit(WinControl):
    """TCustomEdit is the base class from which all edit-box and memo controls are derived.
    TCustomEdit encapsulates the behavior common to all components for editing text by introducing methods and properties that provide:
    Basic text editing functions such as selecting text, modifying selected text, and case conversions.
    Ability to respond to changes in the contents of the text.
    Access control of the text for making it read-only or introducing a password character to hide the actual value.
    Do not create instances of TCustomEdit. Use TCustomEdit as a base class when declaring control objects that permit the user to enter or modify text. Properties and methods of TCustomEdit provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior."""
    __hash__: ClassVar[None] = ...
    Alignment: Alignment
    """Alignment: Determines how the text is aligned within the text edit control.
        Use Alignment to change the way the text is formatted in the text edit control. Alignment can take one of the following values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        taLeftJustify
        
        
        
        Align text to the left side of the control
        
        
        
        
        taCenter
        
        
        
        Center text horizontally in the control.
        
        
        
        
        taRightJustify
        
        
        
        Align text to the right side of the control."""
    CanUndo: bool
    """bool: Indicates whether the edit control contains changes that can be backed out.
        Read CanUndo to determine whether the user has made any changes to the text that can be undone by calling the Undo method. This is useful when enabling or disabling menu items that correspond to these commands."""
    CanUndoSelText: bool
    """bool: When set to True, it allows you to call or invoke an Undo operation in order to undo a change previously made by using SetSelText or SetSelTextBuf. By default it is set to false."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    Modified: bool
    """bool: Indicates whether the user edited the text of the edit control.
        Use Modified to determine whether the user changed the Text property of the edit control. Modified is only reset to False when you assign a value to the Text property. In particular, it is not reset when the control receives focus."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    ReadOnly: bool
    """bool: Determines whether the user can change the text of the edit control.
        To restrict the edit control to display only, set the ReadOnly property to true. Set ReadOnly to false to allow the contents of the edit control to be edited.
        Setting ReadOnly to true ensures that the text is not altered, while still allowing the user to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    SelLength: int
    """int: Specifies the number of characters (bytes) that are selected.
        Read SelLength to determine the length, in bytes, of the selected text. This is the same as the number of characters, unless you are using a multi-byte character set. Set SelLength to change the selection to consist of the first SelLength bytes starting at SelStart.
        
        Note:  Setting SelLength to a value greater than the number of characters from SelStart to the end of the text results in the selection of all characters from SelStart to the end of the text. Reading SelLength immediately after setting it to a value greater than the number of available characters returns the number of characters actually selected, not the value that was just set."""
    SelStart: Any
    """Returns/sets the position of the cursor."""
    SelText: str
    """str: Specifies the selected portion of the edit control's text.
        Read SelText to determine the value of the selected text. Set SelText to replace the selected text with a new string. If there is no selection, but the edit control has focus, set SelText to insert a new string into the text at the cursor."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Text: str
    """str: Contains a text string associated with the control.
        Use the Text property to read the Text of the control or to specify a new string for the Text value. By default, Text is the control name. For edit controls and memos, the Text appears within the control. For combo boxes, the Text is the content of the edit control portion of the combo box. 
        
        Note:  Controls that display text use either the Caption property or the Text property to specify the text value. Which property is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control."""
    TextHint: str
    """str: A hint or message to be displayed when the Text property is empty.
        Use TextHint to cue the user on what kind of entry is expected in the text field. Runtime themes must be enabled.
        
        Code Examples
        StdCtrlsProp (Delphi)
        StdCtrlsProp (C++)"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Clear(self, *args, **kwargs) -> Any:
        """Deletes all text from the edit control.
        Use Clear to replace the Text property with an empty string. Clear removes all text, not just the selected text. To remove just the selected text, use ClearSelection."""
    def ClearSelection(self, *args, **kwargs) -> Any:
        """Removes the selected text from the edit control.
        Use ClearSelection to delete the selected text from the edit control. If no text is selected, ClearSelection does nothing. If all of the text is selected, ClearSelection clears all text, like the Clear method.
        
        Note:  Calling ClearSelection does the same thing as sending the edit control a WM_CLEAR message."""
    def ClearUndo(self, *args, **kwargs) -> Any:
        """Clears the undo buffer so that no changes to the text can be backed out.
        Use ClearUndo to commit changes to the Text property. After calling ClearUndo, the CanUndo property is false and the Undo method does nothing."""
    def CopyToClipboard(self, *args, **kwargs) -> Any:
        """Copies the selected text in the edit control to the Clipboard in CF_TEXT format.
        Use CopyToClipboard to replace the contents of the Clipboard with the selected text. CopyToClipboard does not clear the Clipboard if no text is selected. If no text is selected, CopyToClipboard does nothing.
        
        Note:  Calling CopyToClipboard does the same thing as sending the edit control a WM_COPY message."""
    def Create(self, AOwner: Component) -> None:
        """TCustomEdit.Create(AOwner: Component) -> None
        Creates an instance of TCustomEdit.
        Call Create to create and initialize an instance of TCustomEdit.
        AOwner is another component, typically the form, that is responsible for freeing the edit control. It becomes the value of the Owner property.
        Derived objects that override the Create method should call the inherited Create before performing any additional initialization."""
    def CutToClipboard(self, *args, **kwargs) -> Any:
        """Copies the selected text to the Clipboard in CF_TEXT format and then deletes the selection.
        Use CutToClipboard to replace the contents of the Clipboard with the selected text while clearing the selected text. If no text is selected, CutToClipboard does nothing.
        
        Note:  Calling CopyToClipboard does the same thing as sending the edit control a WM_CUT message."""
    def DefaultHandler(self, Message) -> None:
        """TCustomEdit.DefaultHandler(Message) -> None
        Provides message handling for all messages that the control does not fully process itself.
        Override DefaultHandler to change the default message handling for the edit control. The Message parameter can be cast to a TMessage type to obtain the WParam, LParam, and Result of the message. If the Result of the message is non-zero, the message has already been handled. Set the Result field to a non-zero value to prevent further processing of the message by the inherited method.
        
        Note: In Delphi, calling inherited in a message-handling method results in a call to the ancestor's DefaultHandler method if that ancestor does not specify a handler for the message being handled."""
    def GetControlsAlignment(self, *args, **kwargs) -> Any:
        """Indicates how text is aligned within the control.
        Vcl.StdCtrls.TCustomEdit.GetControlsAlignment inherits from Vcl.Controls.TControl.GetControlsAlignment. All content below this line refers to Vcl.Controls.TControl.GetControlsAlignment.
        Indicates how text is aligned within the control.
        Use GetControlsAlignment to determine the alignment of the control. For controls that do not have an Alignment property, GetControlsAlignment returns taLeftJustify.
        
        Note: GetControlsAlignment returns the alignment of text before it is altered by the BiDiMode property. To check whether the alignment should be reversed to reflect the BiDiMode property, call UseRightToLeftAlignment."""
    def GetSelTextBuf(self, Buffer: PWideChar, BufSize: int) -> int:
        """TCustomEdit.GetSelTextBuf(Buffer: PWideChar, BufSize: int) -> int
        Copies the selected text into a buffer and returns the number of characters copied.
        Use GetSelTextBuf to copy the selected text into a character buffer. If there is no selection, the buffer receives an empty string. If the selection contains more than (BufSize - 1) characters, only the first (BufSize - 1) characters are copied. GetSelTextBuf returns the number of characters that were actually copied into the buffer."""
    def PasteFromClipboard(self, *args, **kwargs) -> Any:
        """Pastes the contents of the Clipboard into edit control, replacing the current selection.
        Use PasteFromClipboard to replace the selected text with the contents of the Clipboard, or, if no text is selected, to insert the contents of the Clipboard at the cursor. If the Clipboard is empty, or if it does not contain anything in CF_TEXT format, PasteFromClipboard does nothing.
        
        Note:  Calling PasteFromClipboard does the same thing as sending the edit control a WM_PASTE message."""
    def SelectAll(self, *args, **kwargs) -> Any:
        """Selects all text in the edit control.
        Use SelectAll to select all text in the edit control. To select only part of the text, use the SelStart and SelLength properties."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def SetSelText(self, Value: str) -> None:
        """TCustomEdit.SetSelText(Value: str) -> None
        Sets the SelText property.
        SetSelText is the property access method for the SelText property."""
    def SetSelTextBuf(self, Buffer: PWideChar) -> None:
        """TCustomEdit.SetSelTextBuf(Buffer: PWideChar) -> None
        Replaces the selected text with a null-terminated string.
        Use SetSelTextBuf to replace the current selection by the contents of the null-terminated string pointed to by Buffer. If no text is selected, the contents of Buffer are inserted at the cursor. SetSelTextBuf does the same thing as setting the SelText property, except that it takes a pointer to a char type rather than a string."""
    def Undo(self, *args, **kwargs) -> Any:
        """Backs out all changes in the undo buffer.
        Call Undo to cancel all changes made to the Text property since the last call to the ClearUndo method. If ClearUndo was never called, Undo rolls back all changes.
        To determine whether there are any changes in the undo buffer, check the CanUndo property."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomForm(WinControl):
    """TCustomForm is the base class from which to derive a window such as a form or dialog.
    Derive from TCustomForm to create a custom window. The TCustomForm descendant can contain other objects, such as TButton, TCheckBox, and TComboBox objects."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Active: bool
    """bool: Specifies whether the form has focus.
        Use Active to determine whether the form has focus. The Active Form receives all keyboard input. If it has a title bar, it is drawn using the active colors specified in the Control panel.
        If Active is true , the form has focus; if Active is false, the form does not have focus."""
    ActiveControl: WinControl
    """WinControl: Specifies the control that has focus on the form.
        Use ActiveControl to get or set the control that has focus on the form. Only one control can have focus at a given time in an application.
        If the form does not have focus, ActiveControl is the control on the form that will receive focus when the form receives focus.
        
        Note:  When focus shifts to another control, ActiveControl is updated before the OnExit event occurs."""
    ActiveOleControl: WinControl
    """WinControl: Specifies the OLE control on the form that reacts to changes in focus.
        Use ActiveOleControl to get or set an OLE control on the form that reacts to changes in focus.
        If ActiveOleControl is not nil (Delphi) or NULL (C++), the user interface for the specified OLE control is deactivated when it is not focused. Also, when the form receives or loses focus, the document window for the specified OLE control is activated or deactivated respectively."""
    BorderStyle: FormBorderStyle
    """FormBorderStyle: Specifies the appearance and behavior of the form border.
        Use BorderStyle to get or set the appearance and behavior of the form border. BorderStyle can be any of the following TForm BorderStyle values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        bsDialog
        
        
        
        Not resizable; no minimize/maximize menu
        
        
        
        
        bsSingle
        
        
        
        Not resizable; minimize/maximize menu
        
        
        
        
        bsNone
        
        
        
        Not resizable; no visible border line
        
        
        
        
        bsSizeable
        
        
        
        Standard resizable border
        
        
        
        
        bsToolWindow
        
        
        
        like bsSingle but with a smaller caption
        
        
        
        
        bsSizeToolWin
        
        
        
        like bsSizeable with a smaller caption
        
        
        
        
        
        Note:  Changing the border style of an MDI child form to bsDialog or bsNone has no effect."""
    Canvas: Canvas
    """Canvas: Provides access to the drawing area of the form.
        Use TCanvas to draw on the client area of the form. Canvas is often used in the OnPaint event handler."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    CustomTitleBar: TitleBar
    """TitleBar: Embarcadero Technologies does not currently have any additional information."""
    Designer: IDesignerHook
    """IDesignerHook: Specifies the designer interface for the form.
        The Designer property is used internally at design time. Never assign a value to this property. This is done automatically by the form designer. Only use this property when designing classes for use in the form designer, such as property editors and component editors."""
    DropTarget: bool
    """bool: Specifies whether the form is the target of a drag-and-drop operation.
        Use DropTarget to determine whether the form is currently the target of a drag-and-drop operation."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    FormState: FormState
    """FormState: Indicates transitional state information about the form.
        Read FormState to determine the state of the form. FormState indicates when the form is in various transitional states or when certain Windows operations have occurred. The following table lists the values that can be included in a form's state:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        fsCreating
        
        
        
        The form's constructor is currently executing.
        
        
        
        
        fsVisible
        
        
        
        The form's window is visible. This state is used to update the Visible property.
        
        
        
        
        fsShowing
        
        
        
        The form's WindowState property is changing. This state is used to prevent WindowState changes from interfering with a transition that is in progress.
        
        
        
        
        fsModal
        
        
        
        The form was created as a modal window.
        
        
        
        
        fsCreatedMDIChild
        
        
        
        The form is an MDI parent window. This state is only set once the MDI client window has been created.
        
        
        
        
        fsActivated
        
        
        
        The form has received a CM_ACTIVATE message (because it received focus or the application became active) but has not yet called the Activate method to generate an OnActivate event."""
    GlassFrame: GlassFrame
    """GlassFrame: Accesses the Glass Frame under Windows Vista, Windows 7, or later Windows operating systems.
        Use GlassFrame to make your forms Windows Vista or Windows 7 Aero-compatible, displaying a glass effect. 
        GlassFrame is a property of a TGlassFrame object created automatically for any form. 
        
        Note: The property is only available for Windows Vista or Windows 7 with Aero. Otherwise, the Glass Frame is ignored."""
    HelpFile: str
    """str: Specifies the name of the Help file the form uses to display the Help from.
        If your form should have a Help file different from the default Help file of the application specified using the TApplication.HelpFile property of the global TApplication type object, then use the HelpFile property of the form to specify the name of the Help file the form will use to display the Help from. 
        The Help system specified by TApplication.HelpSystem displays Help topics from the Help file specified by the HelpFile property of the form when the form has the focus."""
    KeyPreview: bool
    """bool: Specifies whether the form should receive keyboard events before the active control.
        If KeyPreview is true, keyboard events occur on the form before they occur on the active control. (The active control is specified by the ActiveControl property.) 
        If KeyPreview is false, keyboard events occur only on the active control.
        Navigation keys (Tab, BackTab, the arrow keys, and so on) are unaffected by KeyPreview because they do not generate keyboard events. Similarly, when a button has focus or when its Default property is true, the Enter key is unaffected by KeyPreview because it does not generate a keyboard events.
        KeyPreview is false by default."""
    Left: int
    """int: Specifies the horizontal coordinate of the left edge of a component relative to its parent.
        Vcl.Forms.TCustomForm.Left inherits from Vcl.Controls.TControl.Left. All content below this line refers to Vcl.Controls.TControl.Left.
        Specifies the horizontal coordinate of the left edge of a component relative to its parent.
        Use the Left property to determine where the left side of the control begins or to reposition the left side of the control.
        If the control is contained in another control, the Left and Top properties are relative to the parent control. If the control is contained directly by the form, the property values are relative to the form. For forms, the value of the Left property is relative to the screen in pixels."""
    Menu: MainMenu
    """MainMenu: Specifies the form's main menu.
        Use Menu to get or set the form's main menu. At design time, Menu is set to the first TMainMenu component added to the form."""
    ModalResult: Any
    """Represents the return value of a form that is used as a modal dialog."""
    Monitor: Monitor
    """Monitor: Provides access to the monitor on which the form appears.
        Use Monitor to access information about the monitor on which the form appears if the application runs on a multi-monitor system. The monitor is determined by the DefaultMonitor property."""
    OleFormObject: IOleForm
    """IOleForm: Specifies the IOleForm interface for an in-place OLE object contained in the form.
        OleFormObject is used to communicate resize and destroy notifications when a form is used as a frame for an in-place OLE object."""
    PopupMode: PopupMode
    '''PopupMode: Controls how the top-level form behaves with respect to Window\'s WS_POPUP style.
        The PopupMode property controls how the top-level form behaves with respect to Window\'s WS_POPUP style. A window that has the WS_POPUP style is always above its "owner" in Z-order. You can use the PopupMode property in conjunction with the PopupParent property to avoid the appearance of a hung application caused by a modal dialog showing up behind another form on the screen.
        
        Note: Using the PopupMode property is similar to specifying fsStayOnTop for the FormStyle property, but allows better control over the layering. 
        The PopupMode property is automatically set to pmAuto when the ShowModal method is called. However, this causes the window handle to be recreated, which is not usually desirable. To avoid the re-creation of window handles, you can explicitly set the PopupMode property to pmAuto prior to calling the ShowModal method (such as at design time). 
        Set the PopupMode property to pmExplicit for non-modal design windows such as tool palettes and other floating tool windows. This causes the windows to always remain on top of the main form. In the case of a snapped together design (in which the window is docked to the main form), the design window remains on top of the designer.
        
        Note: For undocked windows, the design window remains above the main form, allowing other top-level forms to obscure the design window. 
        Set the PopupMode property to pmNone if you want the pop-up window to have the pre-Delphi 8 behavior (except for the ShowModal item mentioned above).
        You can force the Z-Ordering of your forms and create a "stacked" appearance that the user cannot change by setting the PopupParent property to an explicit TCustomForm. If the PopupMode property is pmExplicit and PopupParent is nil, then the Application.MainForm is implicitly used as the PopupParent. If no Application.MainForm is assigned, then Application.Handle is used as the PopupParent. If the PopupMode property is set to pmAuto, Screen.ActiveForm is used as the PopupParent.'''
    PopupParent: CustomForm
    """CustomForm: Sets an order for stacked forms that users cannot change.
        If the PopupMode property is set to pmExplicit and PopupParent is nil, then the Application.MainForm is implicitly used as the PopupParent. If no Application.MainForm is assigned, then Application.Handle is used as the PopupParent.
        If the PopupMode property is set to pmAuto, Screen.ActiveForm is used as the PopupParent property."""
    Scaled: bool
    """bool: Specifies whether the form is sized according to the value of the PixelsPerInch property.
        Scaled determines whether the form adjusts itself to differences between the font used at design time and the current system font used by a system at runtime. If Scaled is true, the form resizes itself and all its child controls to maintain the relationship between the size of controls and the height of text displayed in the default font. If Scaled is false, no such resizing occurs.
        By setting Scaled to true, the form can adjust to fonts that are not scalable (that is, fonts that only supply discrete point sizes) or to differences such as forms designed using small fonts at design time that are run on systems that use large fonts.
        The degree of resizing is determined by the PixelsPerInch property, which measures the proportion of the font on the system used when designing the form."""
    ScreenSnap: bool
    """bool: Specifies whether form snaps to edge of screen.
        ScreenSnap determines whether the edges of the form snap to the edge of the screen when the user moves the form. To control the snap distance, set the SnapBuffer property."""
    SnapBuffer: int
    """int: Specifies distance for screen snap.
        If ScreenSnap is true, SnapBuffer determines the maximum number of pixels that be between the form edge and the screen edge before the form snaps to the screen edge."""
    TaskbarHandler: TaskbarHandler
    """TaskbarHandler: Embarcadero Technologies does not currently have any additional information."""
    Top: int
    """int: Specifies the Y coordinate of the upper-left corner of a control, relative to its parent or containing control in pixels.
        Vcl.Forms.TCustomForm.Top inherits from Vcl.Controls.TControl.Top. All content below this line refers to Vcl.Controls.TControl.Top.
        Specifies the Y coordinate of the upper-left corner of a control, relative to its parent or containing control in pixels.
        Use Top to locate the top of the control or reposition the control to a different Y coordinate. The Top property, like the Left property, is the position of the control relative to its container. Thus, if a control is contained in a TPanel, the Left and Top properties are relative to the panel. If the control is contained directly by the form, it is relative to the form. For forms, the value of the Top property is relative to the screen in pixels."""
    WindowState: WindowState
    """WindowState: Represents how the form appears on the screen.
        Set WindowState to minimize, maximize, or restore the form window. Read WindowState to determine whether the form is minimized, maximized, or in a normal state."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Construction event dispatcher.
        AfterConstruction is the dispatcher for the event that occurs immediately after the form object's construction. As implemented in TCustomForm, AfterConstruction calls the OnCreate event handler, provided the OldCreateOrder property is false."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Destruction event dispatcher.
        BeforeDestruction is the dispatcher for the event that occurs immediately before the form object's destruction. As implemented in TCustomForm, BeforeDestruction calls the OnDestroy event handler, provided the OldCreateOrder property is false."""
    def Close(self) -> Any:
        """TForm.Close()
        Closes the wrapped Form"""
    def CloseQuery(self) -> Any:
        """TForm.CloseQuery()
        Asked the wrapped Form if it can close"""
    def Create(self, AOwner: Component) -> None:
        """TCustomForm.Create(AOwner: Component) -> None
        Creates and initializes a new TForm object.
        Use Create to instantiate a TForm object or descendant of TForm at runtime. AOwner is the owner of the TCustomForm object.
        For descendants of TCustomForm that are not TForm objects, use CreateNew instead. Calling Create for a TCustomForm descendant that is not a TForm will raise an exception."""
    def CreateNew(self, AOwner: Component, Dummy: int) -> None:
        """TCustomForm.CreateNew(AOwner: Component, Dummy: int) -> None"""
    def DefaultHandler(self, Message) -> None:
        """TCustomForm.DefaultHandler(Message) -> None
        Provides message handling for all messages that the form does not fully process.
        Override DefaultHandler to change the default message handling for the form. This is seldom necessary because messages can be handled by creating message methods.
        DefaultHandler passes any otherwise-unhandled messages to the form's window procedure by calling the CallWindowProc OS function.
        
        Note:  In Delphi code, calling inherited in a message-handling method results in a call to the ancestor's DefaultHandler method unless that ancestor specifies a handler for the message."""
    def DefocusControl(self, Control: WinControl, Removing: bool) -> None:
        """TCustomForm.DefocusControl(Control: WinControl, Removing: bool) -> None
        Removes focus from a control on the form.
        Use DefocusControl to remove focus from a control on the form. This method is used internally by the VCL.
        Control is the control from which to remove focus. If Control is the form's active control, DefocusControl sets the form's ActiveControl property to nil (Delphi) or NULL (C++).
        Removing specifies whether to set focus to the control's parent."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Removes the form from memory.
        Do not call Destroy. Instead, call Release, which indirectly produces a call to the Free method, which in turn calls Destroy."""
    def Dock(self, NewDockSite: WinControl, ARect: Rect) -> None:
        """TCustomForm.Dock(NewDockSite: WinControl, ARect: Rect) -> None
        Handles automatic docking of the form into other windows.
        Do not call Dock in application code. It is called automatically when the form is released on a docking site that will accept it. To dock a form programmatically, use the ManualDock method instead."""
    def FocusControl(self, Control: WinControl) -> None:
        """TCustomForm.FocusControl(Control: WinControl) -> None
        Sets focus to a control on the form.
        Use FocusControl to set focus to a control on the form.
        Control is a TWinControl object encapsulating the control on which to set focus. FocusControl sets the ActiveControl property."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        '''TCustomForm.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Returns the "child" components of the form; that is, those components that return the form from their GetParentComponent method.
        The component streaming system calls GetChildren to request that the form execute a callback for every child component in the form. The callback must execute in creation order (the order the child components appear in the form file). A child component is defined as any component that returns this form from its GetParentComponent method.
        Proc is the callback to execute for every child component.
        Root specifies the top-level component (such as a form or data module) that is currently being loaded or saved.
        In TCustomForm, GetChildren first calls the inherited method, which executes Proc for every control that lists the form as its Parent. Then, if the Root parameter identifies this form, GetChildren executes Proc for every child component that does not have a Parent.'''
    def GetFormImage(self, *args, **kwargs) -> Any:
        """Returns a bitmap of the form.
        Use the GetFormImage method to obtain a bitmap of the form."""
    def Hide(self, *args, **kwargs) -> Any:
        """Hides the form.
        Hide sets the Visible property to false."""
    def IsShortCut(self, Message: WMKey) -> bool:
        """TCustomForm.IsShortCut(Message: WMKey) -> bool
        Processes shortcut keys when the form has focus.
        IsShortCut is called automatically when the user presses a key while the form has focus. It allows the form to dispatch shortcut keys and bypass the standard keystroke processing (OnKeyDown, OnKeyPress, and OnKeyUp events).
        The Message parameter encapsulates the Windows message describing the keypress. If a shortcut for the key exists, IsShortCut executes the appropriate command and returns true. Otherwise IsShortCut returns false.
        IsShortCut generates an OnShortCut event to allow the developer to insert shortcuts for the form. If the keystroke is not handled in an OnShortCut event handler, IsShortCut checks for any shortcuts associated with the form's menus and actions."""
    def LoadProps(self) -> Any:
        """TForm.LoadProps()
        Load properties from a .pydfm file"""
    def MakeFullyVisible(self, AMonitor: Monitor) -> None:
        """TCustomForm.MakeFullyVisible(AMonitor: Monitor) -> None
        Ensures that the form is fully visible on a specified monitor.
        Call MakeFullyVisible to ensure that the form does not appear split over more than one monitor in a multi-monitor application.
        AMonitor is the monitor on which the form should appear. If AMonitor is nil (Delphi) or NULL (C++), MakeFullyVisible uses the Monitor property.
        MakeFullyVisible checks whether the form fits entirely on the specified monitor. If not, it repositions the form so that it fits, if possible."""
    def MouseWheelHandler(self, Message: Message) -> None:
        """TCustomForm.MouseWheelHandler(Message: Message) -> None
        Directs mouse wheel messages to the appropriate control.
        MouseWheelHandler is called automatically when the form or any windowed control contained in the form receives a message from a mouse wheel. The Message parameter encapsulates the message.
        As implemented in TCustomForm, MouseWheelHandler performs no special processing, but simply redirects the message to the active control by calling its Perform method. By default, the Perform method generates the appropriate mouse wheel events."""
    def Print(self, *args, **kwargs) -> Any:
        """Prints the form.
        Call Print to print the form. Print uses the GetFormImage method to obtain a bitmap of the form and draws that to the printer's HDC."""
    def RecreateAsPopup(self, AWindowHandle: int) -> None:
        """TCustomForm.RecreateAsPopup(AWindowHandle: int) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def Release(self) -> Any:
        """TForm.Release()
        Releases (destroys) the wrapped Form"""
    def ScaleForCurrentDPI(self, *args, **kwargs) -> Any:
        """Checks if there is a change in Dpi and performs the necessary changes to scale all the controls for the new Dpi."""
    def ScaleForPPI(self, NewPPI: int) -> None:
        """TCustomForm.ScaleForPPI(NewPPI: int) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def SendCancelMode(self, Sender: Control) -> None:
        """TCustomForm.SendCancelMode(Sender: Control) -> None
        Cancels modes on the form.
        Use SendCancelMode to release the mouse capture and cancel scroll bar input and menu processing on the form."""
    def SetFocus(self, *args, **kwargs) -> Any:
        """Sets focus to the form.
        Use SetFocus to give the form input focus. SetFocus calls the SetFocus method of the active control, if one exists. To determine whether the form has focus, use the Active property."""
    def SetFocusedControl(self, Control: WinControl) -> bool:
        """TCustomForm.SetFocusedControl(Control: WinControl) -> bool
        Sets focus to a control on the form.
        Use SetFocusedControl to give a control on the form input focus. SetFocusedControl returns false if the Control specified by the Control parameter was already in the process of receiving focus, true otherwise.
        
        Note:  A return value of true does not indicate the control has successfully received input focus. If the Control can't have focus (for example, if it is not visible), SetFocusedControl will still return true, indicating that an attempt was made."""
    def Show(self, *args, **kwargs) -> Any:
        """Shows the form.
        Use Show to set the form's Visible property to true and to bring the form to the front of other forms on the screen."""
    def ShowModal(self) -> Any:
        """TForm.ShowModal()
        Shows the wrapped Form as a modal form"""
    def UpdateDesignerCaption(self, AVisible: bool, AUpdateFrame: bool) -> None:
        """TCustomForm.UpdateDesignerCaption(AVisible: bool, AUpdateFrame: bool) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def WantChildKey(self, Child: Control, Message: Message) -> bool:
        """TCustomForm.WantChildKey(Child: Control, Message: Message) -> bool
        Indicates whether the form processes keyboard input for a control it owns.
        WantChildKey is called by any control that the form owns when the control receives keyboard input. If WantChildKey returns true, the control performs no further processing in response to the keyboard input, instead deferring to its parent form to respond to the keystroke. In its default implementation, WantChildKey always returns false; it is overridden in TActiveForm to implement certain ActiveX functionality."""
    def set_PopupParent(self, Value: CustomForm) -> None:
        """TCustomForm.set_PopupParent(Value: CustomForm) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomGrid(CustomControl):
    """TCustomGrid is the base type for all components that present information in a two-dimensional grid.
    Use TCustomGrid as a base class when defining components that represent information in a tabular format. TCustomGrid introduces properties and methods to control the appearance and behavior of the grid, including responses to mouse actions and user editing.
    Do not create instances of TCustomGrid. Instead, put a grid control in a form by instantiating a descendant of TCustomGrid. Use TDrawGrid to represent non-textual material in a tabular grid. For text, use a TStringGrid object. If the text represents field values from a dataset, use TDBGrid."""
    __hash__: ClassVar[None] = ...
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    IsUpdating: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BeginUpdate(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCustomGrid.Create(AOwner: Component) -> None
        Creates an instance of TCustomGrid.
        Call Create to create a grid control at runtime. Grid controls placed on a form at design time are created automatically.
        Owner is a component that is responsible for freeing the grid and for initiating the streaming process when it is saved to a form file."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TCustomGrid.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the grid reference is not nil, and only then calls Destroy."""
    def EndUpdate(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def MouseCoord(self, X: int, Y: int) -> GridCoord:
        """TCustomGrid.MouseCoord(X: int, Y: int) -> GridCoord
        Returns the row and column indexes of the cell that contains a point specified in screen coordinates.
        Call MouseCoord to locate the column and row of the cell which contains a given screen coordinate. Usually, MouseCoord is used to locate the cell that is under the mouse."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def TextWidthToColWidth(self, ATextLength: int, ACaption: str, AColumnObj: Object) -> int:
        """TCustomGrid.TextWidthToColWidth(ATextLength: int, ACaption: str, AColumnObj: Object) -> int
        Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomImageList(BaseImageList):
    """Wrapper for Delphi TCustomImageList"""
    __hash__: ClassVar[None] = ...
    AllocBy: int
    """int:"""
    BkColor: int
    """int:"""
    BlendColor: int
    """int:"""
    ColorDepth: ColorDepth
    """ColorDepth:"""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    DrawingStyle: DrawingStyle
    """DrawingStyle:"""
    GrayscaleFactor: int
    """int:"""
    Handle: int
    """int:"""
    Height: int
    """int:"""
    ImageType: ImageType
    """ImageType:"""
    Masked: bool
    """bool:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    Scaling: bool
    """bool:"""
    ShareImages: bool
    """bool:"""
    Width: int
    """int:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Add(self, Image: Bitmap, Mask: Bitmap) -> int:
        """TCustomImageList.Add(Image: Bitmap, Mask: Bitmap) -> int"""
    def AddDisabledImage(self, Value: CustomImageList, Index: int) -> int:
        """TCustomImageList.AddDisabledImage(Value: CustomImageList, Index: int) -> int"""
    def AddDisabledImages(self, Value: CustomImageList) -> None:
        """TCustomImageList.AddDisabledImages(Value: CustomImageList) -> None"""
    def AddIcon(self, Image: Icon) -> int:
        """TCustomImageList.AddIcon(Image: Icon) -> int"""
    def AddImage(self, Value: CustomImageList, Index: int) -> int:
        """TCustomImageList.AddImage(Value: CustomImageList, Index: int) -> int"""
    def AddImages(self, Value: CustomImageList) -> None:
        """TCustomImageList.AddImages(Value: CustomImageList) -> None"""
    def AddMasked(self, Image: Bitmap, MaskColor: int) -> int:
        """TCustomImageList.AddMasked(Image: Bitmap, MaskColor: int) -> int"""
    @overload
    def Assign(self, Source: Persistent) -> None:
        """TCustomImageList.Assign(Source: Persistent) -> None
        Copies the contents of another similar object.
        Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        which tells the current object to copy the contents of the Source object to itself.
        Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
        If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object's AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
        In general, the statement
        
        Destination := Source; {Delphi}
        
        Destination = Source; // C++
        
        is not the same as the statement
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.
        
        Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method."""
    @overload
    def Assign(self, Source) -> Any:
        """TCustomImageList.Assign(Source: Persistent) -> None
        Copies the contents of another similar object.
        Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        which tells the current object to copy the contents of the Source object to itself.
        Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
        If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object's AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
        In general, the statement
        
        Destination := Source; {Delphi}
        
        Destination = Source; // C++
        
        is not the same as the statement
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.
        
        Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method."""
    @overload
    def Assign(self, Source) -> Any:
        """TCustomImageList.Assign(Source: Persistent) -> None
        Copies the contents of another similar object.
        Assign copies properties and other attributes of the specified Source object to the current object. The standard form of a call to Assign is:
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        which tells the current object to copy the contents of the Source object to itself.
        Most objects override Assign to handle the assignment of properties from similar objects. When overriding Assign, call the inherited method if the destination object cannot handle the assignment of properties from the class of the Source parameter.
        If no overridden Assign method can handle the assignment of properties from Source, the method implemented in TPersistent calls the source object's AssignTo method. This allows the source object to handle the assignment. If the Source object is nil (Delphi) or NULL (C++), Assign raises an EConvertError exception.
        In general, the statement
        
        Destination := Source; {Delphi}
        
        Destination = Source; // C++
        
        is not the same as the statement
        
        Destination.Assign(Source); {Delphi}
        
        Destination->Assign(Source); // C++
        
        The assignment operator makes Destination reference the same object as Source, whereas the Assign method copies the contents of the object referenced by Source into the object referenced by Destination.
        
        Note: The types of some properties are also objects. If these properties have written methods that use Assign to set the value of the property, then in these cases the assignment operator does the same thing as the Assign method."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def CheckIndexAndName(self, AIndex: int, AName: str) -> None:
        """TCustomImageList.CheckIndexAndName(AIndex: int, AName: str) -> None"""
    def Clear(self, *args, **kwargs) -> Any: ...
    def Create(self, AOwner: Component) -> None:
        """TCustomImageList.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def CreateSize(self, AWidth: int, AHeight: int) -> None:
        """TCustomImageList.CreateSize(AWidth: int, AHeight: int) -> None"""
    def Delete(self, Index: int) -> None:
        """TCustomImageList.Delete(Index: int) -> None"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of the component and its owned components.
        Do not call Destroy directly. Call Free instead. Free verifies that the component is not nil, and only then calls Destroy.
        Never explicitly free a component in one of its own event handlers, nor free a component from the event handler of a component that it owns or contains.
        To destroy a form, call its Release method. Release waits for all the form's event handlers and the event handlers of the form's components to finish executing before destroying the form.
        
        Note: A form owns all the controls and nonvisual components that are placed on it in design mode. When it is freed, all of these components are automatically freed as well. By default, all forms are owned by the global Application object. When an application terminates, it frees the global Application object, which frees all forms. For objects that are not components, and for components created with a nil owner, be sure to call Free after finishing with the object; otherwise the memory allocated for the object will be lost until the application terminates."""
    def Draw(self, Canvas: Canvas, X: int, Y: int, Index: int, Enabled: bool) -> None:
        """TCustomImageList.Draw(Canvas: Canvas, X: int, Y: int, Index: int, Enabled: bool) -> None"""
    def DrawOverlay(self, Canvas: Canvas, X: int, Y: int, ImageIndex: int, Overlay: int, Enabled: bool) -> None:
        """TCustomImageList.DrawOverlay(Canvas: Canvas, X: int, Y: int, ImageIndex: int, Overlay: int, Enabled: bool) -> None"""
    def FileLoad(self, ResType: ResType, Name: str, MaskColor: int) -> bool:
        """TCustomImageList.FileLoad(ResType: ResType, Name: str, MaskColor: int) -> bool"""
    def GetBitmap(self, Index: int, Image: Bitmap) -> bool:
        """TCustomImageList.GetBitmap(Index: int, Image: Bitmap) -> bool"""
    def GetHotSpot(self, *args, **kwargs) -> Any: ...
    def GetIcon(self, Index: int, Image: Icon) -> None:
        """TCustomImageList.GetIcon(Index: int, Image: Icon) -> None"""
    def GetImageBitmap(self, *args, **kwargs) -> Any: ...
    def GetIndexByName(self, AName: str) -> int:
        """TCustomImageList.GetIndexByName(AName: str) -> int"""
    def GetInstRes(self, Instance: int, ResType: ResType, Name: str, Width: int, LoadFlags: LoadResources, MaskColor: int) -> bool:
        """TCustomImageList.GetInstRes(Instance: int, ResType: ResType, Name: str, Width: int, LoadFlags: LoadResources, MaskColor: int) -> bool"""
    def GetMaskBitmap(self, *args, **kwargs) -> Any: ...
    def GetNameByIndex(self, AIndex: int) -> str:
        """TCustomImageList.GetNameByIndex(AIndex: int) -> str"""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def GetResource(self, ResType: ResType, Name: str, Width: int, LoadFlags: LoadResources, MaskColor: int) -> bool:
        """TCustomImageList.GetResource(ResType: ResType, Name: str, Width: int, LoadFlags: LoadResources, MaskColor: int) -> bool"""
    def HandleAllocated(self, *args, **kwargs) -> Any: ...
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def Insert(self, Index: int, Image: Bitmap, Mask: Bitmap) -> None:
        """TCustomImageList.Insert(Index: int, Image: Bitmap, Mask: Bitmap) -> None"""
    def InsertIcon(self, Index: int, Image: Icon) -> None:
        """TCustomImageList.InsertIcon(Index: int, Image: Icon) -> None"""
    def InsertMasked(self, Index: int, Image: Bitmap, MaskColor: int) -> None:
        """TCustomImageList.InsertMasked(Index: int, Image: Bitmap, MaskColor: int) -> None"""
    def IsImageNameAvailable(self, *args, **kwargs) -> Any: ...
    def IsScaled(self, *args, **kwargs) -> Any: ...
    def Move(self, CurIndex: int, NewIndex: int) -> None:
        """TCustomImageList.Move(CurIndex: int, NewIndex: int) -> None"""
    def Overlay(self, ImageIndex: int, Overlay: int) -> bool:
        """TCustomImageList.Overlay(ImageIndex: int, Overlay: int) -> bool"""
    def RegisterChanges(self, Value: ChangeLink) -> None:
        """TCustomImageList.RegisterChanges(Value: ChangeLink) -> None"""
    def Replace(self, Index: int, Image: Bitmap, Mask: Bitmap) -> None:
        """TCustomImageList.Replace(Index: int, Image: Bitmap, Mask: Bitmap) -> None"""
    def ReplaceIcon(self, Index: int, Image: Icon) -> None:
        """TCustomImageList.ReplaceIcon(Index: int, Image: Icon) -> None"""
    def ReplaceMasked(self, Index: int, NewImage: Bitmap, MaskColor: int) -> None:
        """TCustomImageList.ReplaceMasked(Index: int, NewImage: Bitmap, MaskColor: int) -> None"""
    def ResInstLoad(self, Instance: int, ResType: ResType, Name: str, MaskColor: int) -> bool:
        """TCustomImageList.ResInstLoad(Instance: int, ResType: ResType, Name: str, MaskColor: int) -> bool"""
    def ResourceLoad(self, ResType: ResType, Name: str, MaskColor: int) -> bool:
        """TCustomImageList.ResourceLoad(ResType: ResType, Name: str, MaskColor: int) -> bool"""
    def SetSize(self, AWidth: int, AHeight: int) -> None:
        """TCustomImageList.SetSize(AWidth: int, AHeight: int) -> None"""
    def UnRegisterChanges(self, Value: ChangeLink) -> None:
        """TCustomImageList.UnRegisterChanges(Value: ChangeLink) -> None"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomLinkControlToField(LinkControlToFieldDelegate):
    """Represents the base class for linking a control to a field.
    The TCustomLinkControlToField class implements the functionality for linking a control to a field in a data source.
    
    Tip: If the direction is bidirectional, then the control must support the IEditLinkObserver interface."""
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Binding: ExpressionsBindComponent
    """ExpressionsBindComponent: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Control: Component
    """Component: Embarcadero Technologies does not currently have any additional information."""
    ControlMemberName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomParse: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Direction: LinkControlToFieldDirection
    """LinkControlToFieldDirection: Embarcadero Technologies does not currently have any additional information."""
    FieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupDataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Embarcadero Technologies does not currently have any additional information."""
    LookupKeyFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupValueFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Owner: Any
    """Returns the Component Owner"""
    Track: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseEvalShortcuts: bool
    """bool: Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False)."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def ClearExpressionProperties(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Create(self, AOwner: Component) -> None:
        """TCustomLinkControlToField.Create(AOwner: Component) -> None
        Creates an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkControlToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
        Creates an instance of the TContainedBindComponent class."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkControlToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
        Destroys an instance of the TContainedBindComponent class."""
    def GenerateExpressions(self, Sender: Component) -> None:
        """TCustomLinkControlToField.GenerateExpressions(Sender: Component) -> None
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
        Data.Bind.Components.TCustomLinkControlToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    def GetDelegates(self, *args, **kwargs) -> Any:
        """Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
        Data.Bind.Components.TCustomLinkControlToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
        Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomLinkLabel(WinControl):
    """Wrapper for Delphi TCustomLinkLabel"""
    __hash__: ClassVar[None] = ...
    Alignment: CustomLinkLabel.TLinkAlignment
    """CustomLinkLabel.TLinkAlignment:"""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnLinkClick: Callable[[Object,str,SysLinkType],None]
    """Callable[[Object, str, SysLinkType], None]:"""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    UseVisualStyle: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCustomLinkLabel.Create(AOwner: Component) -> None
        Creates an instance of TWinControl.
        Call Create to construct and initialize a new control and insert the newly-constructed control into its owner, as specified by the AOwner parameter. Create inserts the control in the owner by calling the owner's InsertComponent method. 
        Most controls override Create to initialize their unique properties. Objects that override the Create method must always call the inherited Create method first, and then proceed with the component-specific initialization. Specify the override directive when overriding the Create method.
        If a component's Create method allocates resources or memory, override the Destroy method to free those resources."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomLinkListControlToField(LinkControlToFieldDelegate):
    """Represents the base class for linking a list control to a field.
    The TCustomLinkListControlToField class implements the functionality for linking a list control, such as TListBox, to a field.
    
    Tip: If the direction is bidirectional, then the control must support the IEditLinkObserver interface."""
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoBufferCount: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    BindLink: CustomBindGridListLink
    """CustomBindGridListLink: Embarcadero Technologies does not currently have any additional information."""
    BufferCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Control: Component
    """Component: Embarcadero Technologies does not currently have any additional information."""
    ControlMemberName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomParse: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Direction: LinkControlToFieldDirection
    """LinkControlToFieldDirection: Embarcadero Technologies does not currently have any additional information."""
    FieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    FillBreakCustomFormat: str
    """str: Specifies a custom expression that is used with the field defined by the FillBreakFieldName property. For instance, the expression StrCopy(%s, 0, 1); causes a break when the first character of the field is different. This property is optional."""
    FillBreakFieldName: str
    """str: Specifies the field used to determine a break. This property is optional."""
    FillBreakGroups: FillBreakGroups
    """FillBreakGroups: Specifies a collection of break value ranges. The break value falls within an item in this collection. The display value associated with the item is displayed in the header. This property is optional."""
    FillExpressions: FormatExpressions
    """FormatExpressions: Specifies additional optional expressions to use when filling the list control. Use this collection when multiple expressions are needed to fill an item in the list.
        For instance, you can use FillExpressions in order to populate a FireMonkey list box item Text and Detail properties. Use the FillDisplayCustomFormat and FillDisplayCustomFormat properties in order to fill the Text property and add an item to the FillExpressions collection, for the Detail property."""
    FillHeaderCustomFormat: str
    """str: Specifies a custom expression that is used with the field defined by the FillHeaderFieldName property. For instance, the expression StrCopy(%s, 0, 1); displays the first character of the field in the header. This property is optional."""
    FillHeaderExpressions: FormatExpressions
    """FormatExpressions: Specifies a collection of expressions to fill a list header. This property is optional."""
    FillHeaderFieldName: str
    """str: Specifies the field to display in the list header. If FillBreakFieldName and FillBreakCustomFormat are blank, then the value determined using FillHeaderFieldName and FillBreakCustomFormat controls breaks. This is the only required field to cause breaking."""
    ListItemStyle: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    OnFilledList: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFilledListItem: Callable[[Object,IBindListEditorItem],None]
    """Callable[[Object, IBindListEditorItem], None]:"""
    OnFillingList: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFillingListItem: Callable[[Object,IBindListEditorItem],None]
    """Callable[[Object, IBindListEditorItem], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    UseEvalShortcuts: bool
    """bool: Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False)."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def ClearExpressionProperties(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Create(self, AOwner: Component) -> None:
        """TCustomLinkListControlToField.Create(AOwner: Component) -> None
        Creates an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkListControlToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
        Creates an instance of the TContainedBindComponent class."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkListControlToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
        Destroys an instance of the TContainedBindComponent class."""
    def FillList(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def GenerateExpressions(self, Sender: Component) -> None:
        """TCustomLinkListControlToField.GenerateExpressions(Sender: Component) -> None
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
        Data.Bind.Components.TCustomLinkListControlToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    def GetDelegates(self, *args, **kwargs) -> Any:
        """Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
        Data.Bind.Components.TCustomLinkListControlToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
        Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomLinkPropertyToField(LinkPropertyToFieldDelegate):
    """Represents the base class for linking a property of a component to a field.
    The TCustomLinkPropertyToField class implements the functionality for linking a property of a component to a field.
    
    Tip: The user input to this component is not monitored using an observer."""
    __hash__: ClassVar[None] = ...
    Active: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    BindLink: CustomBindLink
    """CustomBindLink: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupDataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Embarcadero Technologies does not currently have any additional information."""
    LookupKeyFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupValueFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def CanActivate(self, Sender: Component) -> bool:
        """TCustomLinkPropertyToField.CanActivate(Sender: Component) -> bool
        Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
        Data.Bind.Components.TCustomLinkPropertyToField.CanActivate inherits from Data.Bind.Components.TBindComponentDelegate.CanActivate. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.CanActivate.
        Lets the wrapper binding component indicate whether a delegate (or contained) binding component may be activated.
        The CanActivate method returns True if the delegate (or contained) binding component can be activated, False otherwise."""
    def ClearGeneratedExpressions(self, Sender: Component) -> None:
        """TCustomLinkPropertyToField.ClearGeneratedExpressions(Sender: Component) -> None
        Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto.
        Data.Bind.Components.TCustomLinkPropertyToField.ClearGeneratedExpressions inherits from Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.ClearGeneratedExpressions.
        Clears all the generated bindings expressions, at once, for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    def Create(self, AOwner: Component) -> None:
        """TCustomLinkPropertyToField.Create(AOwner: Component) -> None
        Creates an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkPropertyToField.Create inherits from Data.Bind.Components.TContainedBindComponent.Create. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Create.
        Creates an instance of the TContainedBindComponent class."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of the TContainedBindComponent class.
        Data.Bind.Components.TCustomLinkPropertyToField.Destroy inherits from Data.Bind.Components.TContainedBindComponent.Destroy. All content below this line refers to Data.Bind.Components.TContainedBindComponent.Destroy.
        Destroys an instance of the TContainedBindComponent class."""
    def GenerateExpressions(self, Sender: Component) -> None:
        """TCustomLinkPropertyToField.GenerateExpressions(Sender: Component) -> None
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto.
        Data.Bind.Components.TCustomLinkPropertyToField.GenerateExpressions inherits from Data.Bind.Components.TBindComponentDelegate.GenerateExpressions. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GenerateExpressions.
        Automatically generates the bindings expressions for the quick binding component this delegate wraps onto. For more information regarding the quick binding components, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    def GetDelegates(self, *args, **kwargs) -> Any:
        """Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input.
        Data.Bind.Components.TCustomLinkPropertyToField.GetDelegates inherits from Data.Bind.Components.TBindComponentDelegate.GetDelegates. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.GetDelegates.
        Gets the delegate (or contained) binding components that this wrapper binding component uses to execute expressions and respond to user input."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def Loaded(self, *args, **kwargs) -> Any:
        """Initializes the component after the form file has been read into memory.
        Data.Bind.Components.TCustomLinkPropertyToField.Loaded inherits from System.Classes.TComponent.Loaded. All content below this line refers to System.Classes.TComponent.Loaded.
        Initializes the component after the form file has been read into memory.
        Do not call the protected Loaded method. The streaming system calls this method after it loads the component's form from a stream.
        When the streaming system loads a form or data module from its form file, it first constructs the form component by calling its constructor, then reads its property values from the form file. After reading all the property values for all the components, the streaming system calls the Loaded methods of each component in the order the components were created. This gives the components a chance to initialize any data that depends on the values of other components or other parts of itself.
        
        Note:  All references to sibling components are resolved by the time Loaded is called. Loaded is the first place that sibling pointers can be used after being streamed in.
        As implemented in TComponent, Loaded clears the csLoading flag in the ComponentState property, indicating that the component is no longer loading.
        
        Warning: Loaded may be called multiple times on inherited forms. It is called every time a level of inheritance is streamed in. Do not allocate memory in an overridden Loaded method without first checking that the memory has not been allocated in a previous call."""
    def RequiresControlHandler(self, *args, **kwargs) -> Any:
        """Used internally for observing purposes.
        Data.Bind.Components.TCustomLinkPropertyToField.RequiresControlHandler inherits from Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler. All content below this line refers to Data.Bind.Components.TBindComponentDelegate.RequiresControlHandler.
        Used internally for observing purposes."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomListControl(WinControl):
    """Wrapper for Delphi TCustomListControl"""
    __hash__: ClassVar[None] = ...
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    ItemIndex: int
    """int:"""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AddItem(self, Item: str, AObject: Object) -> None:
        """TCustomListControl.AddItem(Item: str, AObject: Object) -> None"""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Clear(self, *args, **kwargs) -> Any: ...
    def ClearSelection(self, *args, **kwargs) -> Any: ...
    def CopySelection(self, Destination: CustomListControl) -> None:
        """TCustomListControl.CopySelection(Destination: CustomListControl) -> None"""
    def Create(self, AOwner: Component) -> None:
        """TCustomListControl.Create(AOwner: Component) -> None
        Creates an instance of TWinControl.
        Call Create to construct and initialize a new control and insert the newly-constructed control into its owner, as specified by the AOwner parameter. Create inserts the control in the owner by calling the owner's InsertComponent method. 
        Most controls override Create to initialize their unique properties. Objects that override the Create method must always call the inherited Create method first, and then proceed with the component-specific initialization. Specify the override directive when overriding the Create method.
        If a component's Create method allocates resources or memory, override the Destroy method to free those resources."""
    def DeleteSelected(self, *args, **kwargs) -> Any: ...
    def GetCount(self, *args, **kwargs) -> Any: ...
    def MoveSelection(self, Destination: CustomListControl) -> None:
        """TCustomListControl.MoveSelection(Destination: CustomListControl) -> None"""
    def SelectAll(self, *args, **kwargs) -> Any: ...
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomListView(CustomMultiSelectListControl):
    """Wrapper for Delphi TCustomListView"""
    __hash__: ClassVar[None] = ...
    BoundingRect: Rect
    """Rect:"""
    Canvas: Canvas
    """Canvas:"""
    Checkboxes: bool
    """bool:"""
    Column: ListColumn
    """ListColumn:"""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    DropTarget: ListItem
    """ListItem:"""
    FlatScrollBars: bool
    """bool:"""
    Focused: Any
    """Determines whether the control has input focus."""
    FullDrag: bool
    """bool:"""
    GridLines: bool
    """bool:"""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HotTrack: bool
    """bool:"""
    HotTrackStyles: ListHotTrackStyles
    """ListHotTrackStyles:"""
    ItemFocused: ListItem
    """ListItem:"""
    Items: ListItems
    """ListItems:"""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    RowSelect: bool
    """bool:"""
    SelCount: int
    """int:"""
    Selected: ListItem
    """ListItem:"""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TopItem: ListItem
    """ListItem:"""
    ViewOrigin: Point
    """Point:"""
    VisibleRowCount: int
    """int:"""
    WorkAreas: WorkAreas
    """WorkAreas:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AddItem(self, Item: str, AObject: Object) -> None:
        """TCustomListView.AddItem(Item: str, AObject: Object) -> None"""
    def AlphaSort(self, *args, **kwargs) -> Any: ...
    def Arrange(self, Code: ListArrangement) -> None:
        """TCustomListView.Arrange(Code: ListArrangement) -> None"""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Clear(self, *args, **kwargs) -> Any: ...
    def ClearSelection(self, *args, **kwargs) -> Any: ...
    def CopySelection(self, Destination: CustomListControl) -> None:
        """TCustomListView.CopySelection(Destination: CustomListControl) -> None"""
    def Create(self, AOwner: Component) -> None:
        """TCustomListView.Create(AOwner: Component) -> None
        Creates an instance of TWinControl.
        Call Create to construct and initialize a new control and insert the newly-constructed control into its owner, as specified by the AOwner parameter. Create inserts the control in the owner by calling the owner's InsertComponent method. 
        Most controls override Create to initialize their unique properties. Objects that override the Create method must always call the inherited Create method first, and then proceed with the component-specific initialization. Specify the override directive when overriding the Create method.
        If a component's Create method allocates resources or memory, override the Destroy method to free those resources."""
    def CustomSort(self, SortProc: Callable[[int,int,int],int], lParam: int) -> bool:
        """TCustomListView.CustomSort(SortProc: Callable[[int, int, int], int], lParam: int) -> bool"""
    def DeleteSelected(self, *args, **kwargs) -> Any: ...
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TWinControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TWinControl reference is not nil, and only then calls Destroy."""
    def FindCaption(self, StartIndex: int, Value: str, Partial: bool, Inclusive: bool, Wrap: bool) -> ListItem:
        """TCustomListView.FindCaption(StartIndex: int, Value: str, Partial: bool, Inclusive: bool, Wrap: bool) -> ListItem"""
    def FindData(self, StartIndex: int, Value: Pointer, Inclusive: bool, Wrap: bool) -> ListItem:
        """TCustomListView.FindData(StartIndex: int, Value: Pointer, Inclusive: bool, Wrap: bool) -> ListItem"""
    def GetCount(self, *args, **kwargs) -> Any: ...
    def GetDragImages(self, *args, **kwargs) -> Any:
        """Returns the control's image list containing the image to be displayed while dragging.
        Override GetDragImages to provide a custom image list for the control. As implemented in TControl, GetDragImages returns nil (Delphi) or NULL (C++)."""
    def GetHitTestInfoAt(self, X: int, Y: int) -> HitTests:
        """TCustomListView.GetHitTestInfoAt(X: int, Y: int) -> HitTests"""
    def GetItemAt(self, X: int, Y: int) -> ListItem:
        """TCustomListView.GetItemAt(X: int, Y: int) -> ListItem"""
    def GetNearestItem(self, Point: Point, Direction: SearchDirection) -> ListItem:
        """TCustomListView.GetNearestItem(Point: Point, Direction: SearchDirection) -> ListItem"""
    def GetNextItem(self, StartItem: ListItem, Direction: SearchDirection, States: ItemStates) -> ListItem:
        """TCustomListView.GetNextItem(StartItem: ListItem, Direction: SearchDirection, States: ItemStates) -> ListItem"""
    def GetSearchString(self, *args, **kwargs) -> Any: ...
    def IsEditing(self, *args, **kwargs) -> Any: ...
    def Scroll(self, DX: int, DY: int) -> None:
        """TCustomListView.Scroll(DX: int, DY: int) -> None"""
    def SelectAll(self, *args, **kwargs) -> Any: ...
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def StringWidth(self, S: str) -> int:
        """TCustomListView.StringWidth(S: str) -> int"""
    def UpdateItems(self, FirstIndex: int, LastIndex: int) -> None:
        """TCustomListView.UpdateItems(FirstIndex: int, LastIndex: int) -> None"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomMemo(CustomEdit):
    """TCustomMemo is the base type for memo components, which are multiline edit boxes, including TMemo and TDBMemo.
    TCustomMemo introduces new properties and methods to expand the capabilities of TCustomEdit for handling multiline edit boxes.
    Do not create instances of TCustomMemo. Use TCustomMemo as a base class when declaring control objects that implement a multiline edit control. Properties and methods of TCustomMemo provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior."""
    __hash__: ClassVar[None] = ...
    CaretPos: Point
    """Point: Indicates the position of the caret in the client area of the memo.
        Use CaretPos to determine the coordinates of the cursor. CaretPos defines a location onscreen, in characters, with the origin in the top left corner of the memo. X specifies the horizontal coordinate of the point, Y specifies the vertical coordinate.
        To determine the position of the caret in terms of characters of text only (rather than X/Y location), use the SelStart property."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    EditMargins: EditMargins
    """EditMargins: Embarcadero Technologies does not currently have any additional information."""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    Lines: Strings
    """Strings: Contains the individual lines of text in the memo control.
        Use Lines to manipulate text in an memo control on a line-by-line basis. Lines is a TStrings object, so the TStrings methods may be used for Lines to perform manipulations such as counting the lines of text, adding new lines, deleting lines, or replacing lines with new text. For example:
        
        MyMemo.Lines.Add(...);
        
        To work with all the text at once, use the Text property. To manipulate individual lines of text, the Lines property works better.
        
        Note:  Although Lines is implemented as a TStrings descendant, it does not implement the support for associating objects with the strings in the list."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    SelStart: Any
    """Returns/sets the position of the cursor."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCustomMemo.Create(AOwner: Component) -> None
        Creates and initializes an instance of TCustomMemo.
        Call Create to instantiate a TCustomMemo object.
        AOwner is the component, typically the form, that is responsible for freeing the memo object. This becomes the value of the Owner property.
        Derived objects that override the Create method should call the inherited Create before making any additional initializations."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TCustomMemo.
        Do not call Destroy directly in an application. Instead, call Free. Free checks that the TCustomMemo reference is not nil, and only then calls Destroy.
        Destroy frees the TStrings object that implements the Lines property before calling the inherited destructor."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomMemoryStream(Stream):
    """TCustomMemoryStream is an abstract base class used as the common ancestor for memory streams.
    Use TCustomMemoryStream as a base class when defining a stream object that can transfer data that is stored in memory. Memory streams are useful for providing file-like access to data that is stored in a less accessible medium. Data can be moved to an internal memory buffer when the memory stream is created. After manipulating the data in a memory stream, the data can be written out to its actual storage medium when the memory stream is destroyed.
    Do not instantiate an instance of TCustomMemoryStream. It is an abstract class that implements behavior common to all memory streams. To work with an instance of a memory stream, use one of the descendants of TCustomMemoryStream, such as TMemoryStream or TResourceStream."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    Memory: Pointer
    """Pointer: Provides direct access to the memory pool allocated for the memory stream.
        Use Memory to get access to the memory for the stream. The memory for the stream holds the data that is being transferred by means of the memory stream. Size is the number of bytes of Memory that were allocated, and Position is the current position within Memory.
        
        Note: Memory is a read-only property. Memory can be used to change the contents of the memory, but to set the actual memory the stream works with, descendants of TCustomMemoryStream must assign a pointer to a memory buffer by calling the SetPointer method."""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def Read(self, Buffer, Count: int) -> int:
        """TCustomMemoryStream.Read(Buffer, Count: int) -> int
        Reads up to Count bytes from the memory stream into Buffer and advances the current position of the stream by the number of bytes read.
        Use Read to read the contents of the memory stream into a buffer, starting at the current position. Read will read up to Count bytes from the current position in Memory. If Count bytes extends beyond the end of the memory buffer, Read will only transfer the data up to the end of the associated memory buffer. Read returns the number of bytes actually transferred to Buffer, and advances the current position accordingly. If the return value is less than Count, it means that reading reached the end of the stream data.
        All the other data-reading methods of the memory stream (ReadBuffer, ReadComponent) call Read to do the actual reading.
        
        Note: Read treats Count as an upper bound. The ReadBuffer method, by contrast, raises an exception if Count bytes cannot be read."""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SaveToFile(self, FileName: str) -> None:
        """TCustomMemoryStream.SaveToFile(FileName: str) -> None
        Writes the entire contents of the memory stream to the file with a given file name.
        Use SaveToFile to write the contents of Memory to a file. SaveToFile allows an application to write out the contents of the memory stream without having to explicitly create and free a file stream object. In case the file already exists, the current file contents will be completely replaced with the new. If the named file cannot be created or opened, SaveToFile raises an EFCreateError exception."""
    def SaveToStream(self, Stream: Stream) -> None:
        """TCustomMemoryStream.SaveToStream(Stream: Stream) -> None
        Writes the entire contents of the memory stream to the stream object specified by Stream.
        Use SaveToStream to copy data that is stored in memory into another storage medium. SaveToStream writes the entire contents of Memory into the indicated stream object, starting at the current position in the stream that was passed as a parameter.
        When the Stream parameter is a TFileStream object, SaveToStream does much the same thing as the SaveToFile method. However, SaveToStream writes to the current position in the target stream. Thus, for example, SaveToStream can be used to append the contents of Memory to a file stream, rather than replace the contents of the file the way SaveToFile does.
        If the entire contents of the memory stream cannot be written to the target stream, SaveToStream raises an EWriteError exception."""
    def Seek(self, Offset: int, Origin: SeekOrigin) -> int:
        """TCustomMemoryStream.Seek(Offset: int, Origin: SeekOrigin) -> int
        Moves the current position of the stream by Offset bytes, relative to the origin specified by Origin.
        Use Seek to move the current position within the memory stream by the indicated offset. Seek allows an application to read from or write to a particular location within the Memory associated with the memory stream.
        If Offset is a negative number, the seeking is backward from the specified origin. The following table shows the different values of Origin and their meanings for seeking:
        
        
        
        Value
        
        Meaning
        
        
        
        soBeginning
        
        
        
        Offset is from the beginning of Memory. Seek moves to the position Offset. Offset must be >= 0.
        
        
        
        
        soCurrent
        
        
        
        Offset is from the current position. Seek moves to Position + Offset.
        
        
        
        
        soEnd
        
        
        
        Offset is from the end of Memory. Offset must be <= 0 to indicate a number of bytes before the end of the memory buffer.
        
        
        Seek returns the new value of the Position property.
        
        Note: Seek does no error checking on the value provided for Offset. Do not call Seek with an offset that would move the current position less than 0 (before the start of Memory) or greater than Size (beyond the end of the memory buffer)."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomMultiSelectListControl(CustomListControl):
    """Wrapper for Delphi TCustomMultiSelectListControl"""
    __hash__: ClassVar[None] = ...
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    MultiSelect: bool
    """bool:"""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    SelCount: int
    """int:"""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomNumberBox(CustomEdit):
    """TCustomEdit is the base class from which all edit-box and memo controls are derived.
    Vcl.NumberBox.TCustomNumberBox inherits from Vcl.StdCtrls.TCustomEdit. All content below this line refers to Vcl.StdCtrls.TCustomEdit.
    TCustomEdit is the base class from which all edit-box and memo controls are derived.
    TCustomEdit encapsulates the behavior common to all components for editing text by introducing methods and properties that provide:
    Basic text editing functions such as selecting text, modifying selected text, and case conversions.
    Ability to respond to changes in the contents of the text.
    Access control of the text for making it read-only or introducing a password character to hide the actual value.
    Do not create instances of TCustomEdit. Use TCustomEdit as a base class when declaring control objects that permit the user to enter or modify text. Properties and methods of TCustomEdit provide basic behavior that descendant classes inherit as well as behavior that components can override to customize their behavior."""
    __hash__: ClassVar[None] = ...
    AcceptExpressions: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    CurrencyFormat: NumberBoxCurrencyFormat
    """NumberBoxCurrencyFormat: Embarcadero Technologies does not currently have any additional information."""
    CurrencyString: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Decimal: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    DisplayFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    LargeStep: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    MaxValue: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    MinValue: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    Mode: NumberBoxMode
    """NumberBoxMode: Embarcadero Technologies does not currently have any additional information."""
    NegativeValueColor: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    OnChangeValue: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnEvaluateExpression: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnValidateChar: Any
    """Callable[[unicodechr(str), bool], None]:"""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    SelStart: Any
    """Returns/sets the position of the cursor."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    SmallStep: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    SpinButtonOptions: NumberBoxSpinButtonOptions
    """NumberBoxSpinButtonOptions: Embarcadero Technologies does not currently have any additional information."""
    UseMouseWheel: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseNaNValue: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseUpDownKeys: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Value: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    ValueCurrency: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    ValueFloat: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    ValueInt: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    Wrap: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCustomNumberBox.Create(AOwner: Component) -> None
        Creates an instance of TCustomEdit.
        Vcl.NumberBox.TCustomNumberBox.Create inherits from Vcl.StdCtrls.TCustomEdit.Create. All content below this line refers to Vcl.StdCtrls.TCustomEdit.Create.
        Creates an instance of TCustomEdit.
        Call Create to create and initialize an instance of TCustomEdit.
        AOwner is another component, typically the form, that is responsible for freeing the edit control. It becomes the value of the Owner property.
        Derived objects that override the Create method should call the inherited Create before performing any additional initialization."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TWinControl.
        Vcl.NumberBox.TCustomNumberBox.Destroy inherits from Vcl.Controls.TWinControl.Destroy. All content below this line refers to Vcl.Controls.TWinControl.Destroy.
        Destroys an instance of TWinControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TWinControl reference is not nil, and only then calls Destroy."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomPrototypeBindSource(BaseObjectBindSource):
    """Is a base class that implements a bind source for creating sample data.
    If you want to create your own custom prototype bind source, then you should derive your class from TCustomPrototypeBindSource. When designing applications, TPrototypeBindSource is available from the Tool Palette."""
    __hash__: ClassVar[None] = ...
    AutoEdit: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoPost: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    DataGenerator: CustomDataGeneratorAdapter
    """CustomDataGeneratorAdapter: Embarcadero Technologies does not currently have any additional information."""
    FieldDefs: GeneratorFieldDefs
    """GeneratorFieldDefs: Embarcadero Technologies does not currently have any additional information."""
    Owner: Any
    """Returns the Component Owner"""
    RecordCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TCustomPrototypeBindSource.Create(AOwner: Component) -> None
        Allocates memory and constructs a safely initialized instance of a component.
        Data.Bind.ObjectScope.TCustomPrototypeBindSource.Create inherits from System.Classes.TComponent.Create. All content below this line refers to System.Classes.TComponent.Create.
        Allocates memory and constructs a safely initialized instance of a component.
        All objects have a Create method that constructs the object. TComponent redefines Create so that, for components, Create also:
        
        Establishes the relationship of a component and its Owner, as indicated by the AOwner parameter.
        Sets the ComponentStyle property to csInheritable, meaning that the component can be inherited by a descendent form type.
        It is not necessary to explicitly create components added in the Form Designer. These components are created automatically when the application is run, and they are destroyed when the application is closed.
        For components created programmatically, that is, not created in the Form Designer, call Create and pass in an owner component as the AOwner parameter. The owner disposes of the component when it is destroyed. If the component is not owned, then use Free when it needs to be destroyed.
        
        Tip:  When passing in Self as the Owner parameter, consider what Self references. If a component creates another component in one of its methods, then Self refers to the first component and not the component being created, which is then owned by the first component.
        Note:  The TComponent constructor is virtual in part to allow polymorphic instantiation of class references. This is critical to the streaming system and to the Form Designer. Do not forget to use the override directive when declaring a new component's Create constructor."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomStatusBar(WinControl):
    """TCustomStatusBar is the base class for objects that represent status bars.
    TCustomStatusBar component is the base class for status bar controls. Status bars consist of a row of panels, usually aligned at the bottom of a form, that display information about an application as it runs. Each panel is represented by a TStatusPanel object listed in the Panels property.
    TCustomStatusBar is intended only as a base class. To add a status bar to a form, use a TCustomStatusBar descendant such as TStatusBar."""
    __hash__: ClassVar[None] = ...
    AutoHint: bool
    """bool: Specifies whether the status bar's text is set automatically to the current hint.
        Use AutoHint to specify whether the status bar's text is set automatically to the current hint. When AutoHint is True, the status bar automatically responds to hint actions by displaying the long version of the hint's text in the first panel."""
    Canvas: Canvas
    """Canvas: Provides runtime access to the status bar's drawing surface.
        The read-only Canvas property provides access to the status bar's drawing surface that you can use when implementing a handler for the OnDrawPanel event."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnCreatePanelClass: Callable[[CustomStatusBar,StatusPanelClass],None]
    """Callable[[CustomStatusBar, StatusPanelClass], None]:"""
    OnDrawPanel: Callable[[CustomStatusBar,StatusPanel,Rect],None]
    """Callable[[CustomStatusBar, StatusPanel, Rect], None]:"""
    OnHint: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Panels: StatusPanels
    """StatusPanels: Lists the panels (TStatusPanel objects) in the status bar.
        The Panels property holds a TStatusPanels, that is, a collection of TStatusPanel objects. At design time, you can add, remove, or modify panels with the Panels editor. To open the Panels editor, select the Panels property in the Object Inspector, then double-click in the Value column to the right or click the ellipsis (...) button.
        At design time, you can add, remove, or modify panels with the Panels editor:
        
        To open the Panels editor from the the Object Inspector, select the Panels property and either double-click in the Value column to the right or click the ellipsis (...) button.
        To open the Panels editor from the Form Designer, right-click TStatusBar and select Panels editor from the context menu."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    SimplePanel: bool
    """bool: Determines whether the status bar displays a single panel or multiple panels.
        If SimplePanel is set to True, the status bar consists of a single panel displaying the text in SimpleText. If SimplePanel is set to False, the status bar displays a separate panel for each item in its Panels property.
        
        Note: When SimplePanel is False, you cannot use the SimpleText property to display text in the status bar. Instead, you must set the Text property on one of the panel objects."""
    SimpleText: str
    """str: Contains a text string to be displayed in the status panel when SimplePanel is True.
        
        Note: Microsoft Windows XP and earlier versions limited the size of the string to 127 chars. Under Microsoft Windows Vista, Windows 7, or later Windows operating systems, SimpleText has no such limit."""
    SizeGrip: bool
    """bool: Determines whether the status bar is resizable at run time.
        If SizeGrip is set to True, the status bar has a triangular grip on the lower right corner. The user can resize the status bar by dragging the grip with the mouse.
        A size grip will not be drawn unless the Parent property refers to the child of a TCustomForm descendant with a BorderStyle of bsSizeable or bsSizeToolWin.
        
        Note: If Align is set to alBottom, alRight, or alClient, the sizing grip will not work. If the Alignment property of the last panel in the status bar is set to taRightJustify, the sizing grip will truncate the panel's text."""
    UseSystemFont: bool
    """bool: Specifies whether the status bar uses the system font.
        UseSystemFont specifies whether the status bar uses the system font. To change fonts, use the Font property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCustomStatusBar.Create(AOwner: Component) -> None
        Creates and initializes a TCustomStatusBar component.
        The Create method creates a status bar along with its canvas and status panels.
        AOwner is a component, typically the form, that becomes the value of the Owner property."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys TCustomStatusBar and frees its memory.
        Do not call Destroy directly. Instead, use the Free method, which checks for a nil object before calling Destroy.
        The Destroy method destroys the status bar along with its canvas and status panels."""
    def ExecuteAction(self, Action: BasicAction) -> bool:
        """TCustomStatusBar.ExecuteAction(Action: BasicAction) -> bool
        Processes actions for the status bar.
        When an action executes, the application makes a series of calls to respond to that action. If, in the course of that processing, the application identifies the status bar as a potential target of the action, it calls the status bar's ExecuteAction method.
        If the action in a hint action (THintAction), ExecuteAction checks the AutoHint property, and if it is true, displays the hint and returns true. Otherwise, it allows the inherited method to respond to any other actions.
        The Action parameter specifies the action that was invoked.
        ExecuteAction returns true if the action was successfully dispatched, and false if the component could not handle the action."""
    def FlipChildren(self, AllLevels: bool) -> None:
        """TCustomStatusBar.FlipChildren(AllLevels: bool) -> None
        Reverses the positions of the status bar's panels.
        FlipChildren iterates through the panels of the status bar, reversing their order but otherwise leaving their properties intact. 
        AllLevels specifies whether FlipChildren should be called recursively on the control's children. TCustomStatusBar ignores this parameter when reversing the panels."""
    def SetBounds(self, ALeft: int, ATop: int, AWidth: int, AHeight: int) -> None:
        """TCustomStatusBar.SetBounds(ALeft: int, ATop: int, AWidth: int, AHeight: int) -> None
        Sets the Left, Top, Width, and Height properties all at once.
        TCustomStatusBar overrides SetBounds in order to update the size grip.
        ALeft, ATop, AWidth, and AHeight specify the new values for the Left, Top, Width, and Height properties, respectively."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomStyleServices(Object):
    """TCustomStyleServices is a class that provides access to style functionality.
    Use the methods and properties of TCustomStyleServices to get information about a style or to perform painting of custom controls. 
    Do not instantiate TCustomStyleServices; instead, call the StyleServices function to access the methods and properties of TCustomStyleServices."""
    __hash__: ClassVar[None] = ...
    Available: bool
    """bool: Determines whether the operating system supports styles.
        Use Available to check whether the operating system supports styles."""
    ClassName: Any
    """Returns the TObject.ClassName"""
    DesigningState: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Enabled: bool
    """bool: Determines whether styles are enabled for the current application.
        Use Enabled to check whether the current application has styles enabled."""
    Flags: CustomStyleServices.TStyleFlags
    """CustomStyleServices.TStyleFlags: Returns the flags set for the current style.
        Use Flags to obtain the flags that are set for the current style."""
    IsSystemStyle: bool
    """bool: Determines whether the current style is a system style.
        IsSystemStyle returns True if the current style is a default operating system style, and False if it is a custom style."""
    Name: str
    """str: Returns the name of the current style.
        Use Name to obtain a string that represents the name of the current style. This is the same name you can use with StyleManager.SetStyle to activate the style."""
    OnThemeChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Theme: int
    """int:"""
    ThemeForDPI: int
    """int:"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ApplyThemeChange(self, *args, **kwargs) -> Any:
        """Resets the application theme.
        ApplyThemeChange is called automatically by the TApplication object whenever the operating system theme is changed. 
        
        Note: ApplyThemeChange is used internally by the VCL and should not be called manually by applications."""
    def ColorToRGB(self, Color: int, Details: PhemedElementDetails) -> int:
        """TCustomStyleServices.ColorToRGB(Color: int, Details: PhemedElementDetails) -> int
        Gets the color reference for a specified TColor.
        Use ColorToRGB to convert the Color parameter to its RGB representation.
        If Details is not nil, the function returns the system color that is defined for Color under the current style. For example, if Color is clBtnFace, the function returns the system color defined for the button face in the current style, as a TColorRef value.\r
        Gets the color reference for a specified TColor.
        Use ColorToRGB to convert the Color parameter to its RGB representation.
        If Details is not nil, the function returns the system color that is defined for Color under the current style. For example, if Color is clBtnFace, the function returns the system color defined for the button face in the current style, as a TColorRef value."""
    def ContentRect(self, DC: int, Details: ThemedElementDetails, BoundingRect: Rect) -> Rect:
        """TCustomStyleServices.ContentRect(DC: int, Details: ThemedElementDetails, BoundingRect: Rect) -> Rect"""
    def Create(self, *args, **kwargs) -> Any:
        """Constructs an object and initializes its data before the object is first used.
        Vcl.Themes.TCustomStyleServices.Create inherits from System.TObject.Create. All content below this line refers to System.TObject.Create.
        Constructs an object and initializes its data before the object is first used.
        Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
        Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.
        
        Note: If an exception escapes from a constructor, the object's destructor is called to clean up the failed instance."""
    def DrawEdge(self, DC: int, Details: ThemedElementDetails, R: Rect, Edges: int, Flags: int, ContentRect: PRect) -> bool:
        """TCustomStyleServices.DrawEdge(DC: int, Details: ThemedElementDetails, R: Rect, Edges: int, Flags: int, ContentRect: PRect) -> bool
        Draws the edge or edges of the rectangle that contains the element in the current style.
        Call DrawEdge to draw one or more edges of the given element.
        Edge indicates the types of inner and outer edges and Flags specifies the types of borders.
        
        Note: The first overload of this method is deprecated; use the second overload instead.\r
        Draws the edge or edges of the rectangle that contains the element in the current style.
        Call DrawEdge to draw one or more edges of the given element.
        Edge indicates the types of inner and outer edges and Flags specifies the types of borders.
        
        Note: The first overload of this method is deprecated; use the second overload instead."""
    def DrawElement(self, DC: int, Details: ThemedElementDetails, R: Rect, ClipRect: Rect, DPI: int) -> bool:
        """TCustomStyleServices.DrawElement(DC: int, Details: ThemedElementDetails, R: Rect, ClipRect: Rect, DPI: int) -> bool
        Draws the specified element.
        Call DrawElement to draw the element specified by Details, using the current style.  
        R is the rectangle where the element is drawn and ClipRect is a clipping rectangle.\r
        Draws the specified element.
        Call DrawElement to draw the element specified by Details, using the current style.  
        R is the rectangle where the element is drawn and ClipRect is a clipping rectangle."""
    def DrawIcon(self, DC: int, Details: ThemedElementDetails, R: Rect, Images: int, Index: int) -> bool:
        """TCustomStyleServices.DrawIcon(DC: int, Details: ThemedElementDetails, R: Rect, Images: int, Index: int) -> bool
        Draws an icon over the given element.
        Call DrawIcon to draw the image that resides at the Index index in the image list specified by Images. The icon is drawn in the rectangle specified by R, over the element indicated by Details."""
    def DrawParentBackground(self, Window: int, Target: int, Details: PhemedElementDetails, OnlyIfTransparent: bool, Bounds: Rect) -> bool:
        """TCustomStyleServices.DrawParentBackground(Window: int, Target: int, Details: PhemedElementDetails, OnlyIfTransparent: bool, Bounds: Rect) -> bool
        Draws the background of the given user interface element's parent.
        Call DrawParentBackground to draw the background of a user interface element's parent, using the current style.
        If OnlyIfTransparent is True, the drawing is performed only if the element is transparent in the current style. Bounds represents the area to be drawn.\r
        Draws the background of the given user interface element's parent.
        Call DrawParentBackground to draw the background of a user interface element's parent, using the current style.
        If OnlyIfTransparent is True, the drawing is performed only if the element is transparent in the current style. Bounds represents the area to be drawn.\r
        Draws the background of the given user interface element's parent.
        Call DrawParentBackground to draw the background of a user interface element's parent, using the current style.
        If OnlyIfTransparent is True, the drawing is performed only if the element is transparent in the current style. Bounds represents the area to be drawn."""
    def DrawText(self, DC: int, Details: ThemedElementDetails, S: str, R: Rect, Flags: int, Flags2: int, DPI: int) -> bool:
        """TCustomStyleServices.DrawText(DC: int, Details: ThemedElementDetails, S: str, R: Rect, Flags: int, Flags2: int, DPI: int) -> bool
        Draws text over an element, using the current style.
        Call DrawText to draw the S string in the rectangle specified by R. The S string has the format and additional options indicated by the Flags and Options parameters. The drawing is performed with the settings of the current style.
        
        Note: The first overload of this function is deprecated. Use the following two overloads that use TTextFormat to specify the text formatting.\r
        Draws text over an element, using the current style.
        Call DrawText to draw the S string in the rectangle specified by R. The S string has the format and additional options indicated by the Flags and Options parameters. The drawing is performed with the settings of the current style.
        
        Note: The first overload of this function is deprecated. Use the following two overloads that use TTextFormat to specify the text formatting.\r
        Draws text over an element, using the current style.
        Call DrawText to draw the S string in the rectangle specified by R. The S string has the format and additional options indicated by the Flags and Options parameters. The drawing is performed with the settings of the current style.
        
        Note: The first overload of this function is deprecated. Use the following two overloads that use TTextFormat to specify the text formatting."""
    def GetElementColor(self, Details: ThemedElementDetails, ElementColor: ElementColor, Color: int) -> bool:
        """TCustomStyleServices.GetElementColor(Details: ThemedElementDetails, ElementColor: ElementColor, Color: int) -> bool
        Determines the color of the element specified by Details.
        GetElementColor determines the color value used for the property determined by ElementColor."""
    def GetElementContentRect(self, DC: int, Details: ThemedElementDetails, BoundingRect: Rect, ContentRect: Rect) -> bool:
        """TCustomStyleServices.GetElementContentRect(DC: int, Details: ThemedElementDetails, BoundingRect: Rect, ContentRect: Rect) -> bool
        Gets the background rectangle of the content area of the element.
        Call GetElementContentRect to retrieve the rectangle that contains the background area of a control, when styles are enabled. 
        Details represents the user interface element from which the information is being retrieved."""
    def GetElementMargins(self, DC: int, Details: ThemedElementDetails, ElementMargin: ElementMargin, Margins: _MARGINS, DPI: int) -> bool:
        """TCustomStyleServices.GetElementMargins(DC: int, Details: ThemedElementDetails, ElementMargin: ElementMargin, Margins: _MARGINS, DPI: int) -> bool
        Determines the margins of the element in the current style.
        Call GetElementMargins to retrieve the margins of the control specified by Details.\r
        Determines the margins of the element in the current style.
        Call GetElementMargins to retrieve the margins of the control specified by Details."""
    def GetElementRegion(self, Details: ThemedElementDetails, Rect: Rect, Region: int) -> bool:
        """TCustomStyleServices.GetElementRegion(Details: ThemedElementDetails, Rect: Rect, Region: int) -> bool
        Determines the region of the element in the current style.
        Call GetElementRegion to obtain the region of the element, bounded by the given rectangle.\r
        Determines the region of the element in the current style.
        Call GetElementRegion to obtain the region of the element, bounded by the given rectangle."""
    def GetElementSize(self, DC: int, Details: ThemedElementDetails, ElementSize: ElementSize, Size: Size, DPI: int) -> bool:
        """TCustomStyleServices.GetElementSize(DC: int, Details: ThemedElementDetails, ElementSize: ElementSize, Size: Size, DPI: int) -> bool
        Determines the size for the specified part of a control.
        Call GetElementSize to obtain the size of the rectangle that contains the part of the control specified by Details.
        ElementSize represents the type of size to be returned: minimum, actual, or stretch.\r
        Determines the size for the specified part of a control.
        Call GetElementSize to obtain the size of the rectangle that contains the part of the control specified by Details.
        ElementSize represents the type of size to be returned: minimum, actual, or stretch."""
    def GetStyleColor(self, Color: StyleColor) -> int:
        """TCustomStyleServices.GetStyleColor(Color: StyleColor) -> int
        Returns the color defined in the style for the element specified by Color.
        Use GetStyleColor to obtain the color defined for a certain control.
        For example, if Color is scButtonPressed, GetStyleColor returns the color assigned for the button when it is pressed.
        The style colors give you access to the colors used for controls in the current style. There are two categories of style colors. The first category includes colors used for control parts that are rendered directly from an image. In this case, the style color offers you a way to access the color of that image and is purely informational. The second category includes the colors used for controls that are rendered from code at run time (Panel, ListBox, Grid, and so on)."""
    def GetStyleFontColor(self, Font: StyleFont) -> int:
        """TCustomStyleServices.GetStyleFontColor(Font: StyleFont) -> int
        Returns the font color for the element specified by Font.
        Call GetStyleFontColor to obtain the font color defined in the current style for a specific part and state of a control.
        For example, if Font is sfEditBoxDisabled, GetStyleFontColor returns the color of the text in an edit box, when the edit box is disabled."""
    def GetSystemColor(self, Color: int) -> int:
        """TCustomStyleServices.GetSystemColor(Color: int) -> int
        Returns the system color defined in the current style.
        The current style has a set of colors defined for system color constants that resemble the style colors. For instance, you can call GetSystemColor with clBtnFace to obtain the styled color of a button face."""
    def GetTextExtent(self, DC: int, Details: ThemedElementDetails, Text: str, Flags: TextFormat, ExtentRect: Rect) -> bool:
        """TCustomStyleServices.GetTextExtent(DC: int, Details: ThemedElementDetails, Text: str, Flags: TextFormat, ExtentRect: Rect) -> bool
        Returns the rectangle that contains the given text, drawn in the current style.
        Call GetTextExtent to obtain the rectangle required to draw the given text with the specified formatting in the current style.\r
        Returns the rectangle that contains the given text, drawn in the current style.
        Call GetTextExtent to obtain the rectangle required to draw the given text with the specified formatting in the current style."""
    def GetTheme(self, Element: ThemedElement) -> int:
        """TCustomStyleServices.GetTheme(Element: ThemedElement) -> int"""
    def GetThemeForDPI(self, Element: ThemedElement, DPI: int) -> int:
        """TCustomStyleServices.GetThemeForDPI(Element: ThemedElement, DPI: int) -> int"""
    def HasElementFixedPosition(self, Details: ThemedElementDetails) -> bool:
        """TCustomStyleServices.HasElementFixedPosition(Details: ThemedElementDetails) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def HasTransparentParts(self, Details: ThemedElementDetails) -> bool:
        """TCustomStyleServices.HasTransparentParts(Details: ThemedElementDetails) -> bool
        Determines whether the given element has transparent parts.
        Call HasTransparentParts to check whether the element specified by Details has transparent parts in the current style."""
    @classmethod
    def IsValidStyle(cls, Stream: Stream) -> bool:
        """TCustomStyleServices.IsValidStyle(Stream: Stream) -> bool
        Checks whether the provided style is a valid style.
        Call IsValidStyle to verify whether the style specified by Stream is a valid style.\r
        Checks whether the provided style is a valid style.
        Call IsValidStyle to verify whether the style specified by Stream is a valid style."""
    @classmethod
    def LoadFromFile(cls, FileName: str) -> CustomStyleServices:
        """TCustomStyleServices.LoadFromFile(FileName: str) -> CustomStyleServices
        Loads a style from the specified file.
        Call LoadFromFile to load a style from the specified file."""
    def PaintBorder(self, Control: WinControl, EraseLRCorner: bool) -> None:
        """TCustomStyleServices.PaintBorder(Control: WinControl, EraseLRCorner: bool) -> None
        Draws the border of a control.
        Call PaintBorder to draw the border of a control using the current style."""
    def SaveToFile(self, FileName: str) -> None:
        """TCustomStyleServices.SaveToFile(FileName: str) -> None
        Saves the current style settings to the specified file.
        Call SaveToFile to save the current style in the specified filename."""
    def ThemesAvailable(self, *args, **kwargs) -> Any: ...
    def ThemesEnabled(self, *args, **kwargs) -> Any: ...
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomTabControl(WinControl):
    """TCustomTabControl is the base type for tab control components such as TTabControl and TPageControl.
    Use TCustomTabControl as a base class when defining a control that includes a set of notebook style tabs across the top. TCustomTabControl introduces many properties, methods, and events to manage appearance and behavior of the tabs, and to respond when the user selects one of the tabs.
    
    Note:  When using one of the page controls, if you want to restrict a user from switching to a tab, you cannot set TTabSheet.Enabled to false to accomplish that restriction. Instead, use the OnChanging event to prevent the user from selecting a tab."""
    __hash__: ClassVar[None] = ...
    Canvas: Canvas
    """Canvas: Gives access to the tab control's canvas.
        Use Canvas to paint to the tab control's canvas during the OnDrawTab event."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TCustomTabControl.Create(AOwner: Component) -> None
        Creates and initializes an instance of TCustomTabControl.
        Call Create to instantiate a tab control at runtime. Tab controls placed on forms at design time are created automatically. Create calls the inherited Create method and sets the initial values for the tab control, including the creation of a tab list that contains the text strings for the tabs.
        AOwner is a component, typically the form, that is responsible for freeing the tab control. It becomes the value of the Owner property."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TCustomTabControl.
        Do not call Destroy directly in an application. Instead, use Free. Free checks that the tab control is not nil, and only then calls Destroy. Destroy frees the tab list that holds the list of text strings for the tabs and calls the inherited destructor."""
    def GetHitTestInfoAt(self, X: int, Y: int) -> HitTests:
        '''TCustomTabControl.GetHitTestInfoAt(X: int, Y: int) -> HitTests
        Returns information about the location of a point relative to the client area of the tab control.
        Call GetHitTestInfoAt to determine what portion of the tab control, if any, sits under the point specified by the X and Y parameters.
        GetHitTestInfo returns a THitTests type. This set describes the possible elements under the mouse. When interpreting these values, each tab can be considered an "item" of the tab control.'''
    def IndexOfTabAt(self, X: int, Y: int) -> int:
        """TCustomTabControl.IndexOfTabAt(X: int, Y: int) -> int
        Indicates the index of the tab at a specified point.
        Use IndexOfTabAt to locate which tab is at the point specified by X and Y. If the point with X-coordinate X and Y-coordinate Y is over a tab, IndexOfTabAt returns the 0-offset index of that tab in the Tabs property (TTabControl) or in the Pages property (TPageControl). If the point defined by X and Y is not over a tab, IndexOfTabAt returns 1."""
    def RowCount(self, *args, **kwargs) -> Any:
        """Sets TabIndex property.
        RowCount is called to change the value of the TabIndex property. Descendant classes should override RowCount to provide special implementations of this property."""
    def ScrollTabs(self, Delta: int) -> None:
        """TCustomTabControl.ScrollTabs(Delta: int) -> None
        Scrolls the tabs that are visible when the tab control is not multi-line.
        Call ScrollTabs to change the tabs that are visible in the tab control. When Delta is positive, Delta additional tabs to the right are scrolled into view. When Delta is negative, the tabs to the left are scrolled into view, with the absolute value of Delta indicating how many tabs are scrolled. If there are fewer than the absolute value of Delta tabs in the indicated direction, ScrollTabs scrolls as far as possible.
        ScrollTabs has no effect if there are no scrolled tabs, either because the control is wide enough to display all tabs or because the MultiLine property is true. 
        
        Note: ScrollTabs scrolls the visible tabs. It does not change the current selection. Calling ScrollTabs may scroll the selected tab out of view."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def TabRect(self, Index: int) -> Rect:
        """TCustomTabControl.TabRect(Index: int) -> Rect
        Returns the bounding rectangle for a specified tab.
        Use TabRect to determine the current position of the tab with the specified index. Index is the 0-offset index of a tab in the Tabs property (TTabControl) or in the Pages property (TPageControl). TabRect returns the bounding rectangle (in client coordinates) of the specified tab."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomToggleSwitch(CustomControl):
    """The base class for TToggleSwitch.
    TToggleSwitch implements a clickable control that allows a user to toggle between an On state and an Off state."""
    __hash__: ClassVar[None] = ...
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    Parent: Any
    """Returns/Sets the Control Parent"""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TCustomToggleSwitch.Create(AOwner: Component) -> None
        Creates an instance of the TCustomToggleSwitch.
        Create sets the default values for all the toggle switch properties."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TCustomControl.
        Vcl.WinXCtrls.TCustomToggleSwitch.Destroy inherits from Vcl.Controls.TCustomControl.Destroy. All content below this line refers to Vcl.Controls.TCustomControl.Destroy.
        Destroys an instance of TCustomControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy. 
        Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
        As the control is destroyed, it destroys the TCanvas object in its Canvas property. 
        Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method. 
        When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents."""
    def GetControlsAlignment(self, *args, **kwargs) -> Any:
        """Indicates how text is aligned within the control.
        Vcl.WinXCtrls.TCustomToggleSwitch.GetControlsAlignment inherits from Vcl.Controls.TControl.GetControlsAlignment. All content below this line refers to Vcl.Controls.TControl.GetControlsAlignment.
        Indicates how text is aligned within the control.
        Use GetControlsAlignment to determine the alignment of the control. For controls that do not have an Alignment property, GetControlsAlignment returns taLeftJustify.
        
        Note: GetControlsAlignment returns the alignment of text before it is altered by the BiDiMode property. To check whether the alignment should be reversed to reflect the BiDiMode property, call UseRightToLeftAlignment."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def IsOn(self, *args, **kwargs) -> Any:
        """Indicates whether the toggle switch is in the On state."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class CustomTreeView(WinControl):
    __hash__: ClassVar[None] = ...
    Canvas: Canvas
    """Canvas:"""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    DropTarget: TreeNode
    """TreeNode:"""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    Selected: TreeNode
    """TreeNode:"""
    SelectionCount: int
    """int:"""
    Selections: TreeNode
    """TreeNode:"""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TopItem: TreeNode
    """TreeNode:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AlphaSort(self, ARecurse: bool) -> bool:
        """TCustomTreeView.AlphaSort(ARecurse: bool) -> bool"""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def ClearSelection(self, KeepPrimary: bool) -> None:
        """TCustomTreeView.ClearSelection(KeepPrimary: bool) -> None"""
    def Create(self, AOwner: Component) -> None:
        """TCustomTreeView.Create(AOwner: Component) -> None
        Creates an instance of TWinControl.
        Call Create to construct and initialize a new control and insert the newly-constructed control into its owner, as specified by the AOwner parameter. Create inserts the control in the owner by calling the owner's InsertComponent method. 
        Most controls override Create to initialize their unique properties. Objects that override the Create method must always call the inherited Create method first, and then proceed with the component-specific initialization. Specify the override directive when overriding the Create method.
        If a component's Create method allocates resources or memory, override the Destroy method to free those resources."""
    def CustomSort(self, SortProc: Callable[[int,int,int],int], Data: int, ARecurse: bool) -> bool:
        """TCustomTreeView.CustomSort(SortProc: Callable[[int, int, int], int], Data: int, ARecurse: bool) -> bool"""
    def Deselect(self, Node: TreeNode) -> None:
        """TCustomTreeView.Deselect(Node: TreeNode) -> None"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TWinControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TWinControl reference is not nil, and only then calls Destroy."""
    def FindNextToSelect(self, *args, **kwargs) -> Any: ...
    def FullCollapse(self, *args, **kwargs) -> Any: ...
    def FullExpand(self, *args, **kwargs) -> Any: ...
    def GetDragImages(self, *args, **kwargs) -> Any:
        """Returns the control's image list containing the image to be displayed while dragging.
        Override GetDragImages to provide a custom image list for the control. As implemented in TControl, GetDragImages returns nil (Delphi) or NULL (C++)."""
    def GetHitTestInfoAt(self, X: int, Y: int) -> HitTests:
        """TCustomTreeView.GetHitTestInfoAt(X: int, Y: int) -> HitTests"""
    def GetNodeAt(self, X: int, Y: int) -> TreeNode:
        """TCustomTreeView.GetNodeAt(X: int, Y: int) -> TreeNode"""
    def GetSelections(self, AList: List) -> TreeNode:
        """TCustomTreeView.GetSelections(AList: List) -> TreeNode"""
    def IsEditing(self, *args, **kwargs) -> Any: ...
    def LoadFromFile(self, FileName: str) -> None:
        """TCustomTreeView.LoadFromFile(FileName: str) -> None"""
    def LoadFromStream(self, Stream: Stream) -> None:
        """TCustomTreeView.LoadFromStream(Stream: Stream) -> None"""
    def SaveToFile(self, FileName: str) -> None:
        """TCustomTreeView.SaveToFile(FileName: str) -> None"""
    def SaveToStream(self, Stream: Stream) -> None:
        """TCustomTreeView.SaveToStream(Stream: Stream) -> None"""
    def Select(self, Node: TreeNode, ShiftState: ShiftState) -> None:
        """TCustomTreeView.Select(Node: TreeNode, ShiftState: ShiftState) -> None"""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def Subselect(self, Node: TreeNode, Validate: bool) -> None:
        """TCustomTreeView.Subselect(Node: TreeNode, Validate: bool) -> None"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class DateTimePicker(WinControl):
    """TDateTimePicker displays a list box for entering dates or times.
    TDateTimePicker is a visual component designed specifically for entering dates or times. In dmComboBox date mode, it resembles a list box or combo box, except that the drop-down list is replaced with a calendar illustration; users can select a date from the calendar. Dates or times can also be selected by scrolling with Up and Down arrows and by typing.
    Date-time picker ignores the BiDiMode setting for right-to-left reading, displaying dates according to the system locale.
    TDateTimePicker formats date and time values according to the date and time settings in the Regional Settings of the Control panel on the user's system. Because TDateTimePicker is a wrapper for a Windows control, these formats can't be changed by changing the formatting variables in the SysUtils unit. However, you can use the Windows API call DateTime_SetFormat to programmatically specify these settings.
    
    Note: The underlying Windows control is known to behave unpredictably when used to set dates in 1752, the year English-speaking countries changed to the Gregorian calendar. Similar problems may appear for different dates when a non-English locale is used. If an application might be used to specify dates on or before the changeover in the current locale (for example, 1918 or before in Russian locales), be sure to test the application using the dates affected."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BevelWidth: int
    """int: Specifies the width of the inner and outer bevels.
        Use BevelWidth to specify the width, in pixels, of the inner and outer bevels."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    CalAlignment: DTCalAlignment
    """DTCalAlignment: Determines the alignment of the drop-down calendar.
        Set CalAlignment to dtaLeft or dtaRight to align the drop-down calendar on the left or right side of the component. This property is applicable only if the Kind property is dtkDate and the DateMode property is dmComboBox."""
    CalColors: MonthCalColors
    """MonthCalColors:"""
    Checked: bool
    """bool: Indicates whether the check box next to the date or time is selected.
        Checked is true if the check box in the TDateTimePicker component is selected. Setting Checked to true at design time makes the check box appear selected by default."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Date: float
    """float:"""
    DateFormat: DTDateFormat
    """DTDateFormat: Specifies format in which the date is presented.
        If DateFormat is set to dfShort, the date is formatted using the short date format specified in the Windows control panel. By default, it appears like this: 3/21/97. 
        If DateFormat is set to dfLong, the date is formatted using the long date format specified in the Windows control panel. By default, it appears like this: Friday, March 21, 1997. (Applies only when Kind is dtkDate.)
        For custom date formats, set the Format property."""
    DateMode: DTDateMode
    """DTDateMode: Determines the method of date selection used by the component.
        If DateMode is dmComboBox, the component has a drop-down calendar illustration from which the user can select a date. If DateMode is dmUpDown, the component has Up/Down arrows with which the user can adjust the date. (Applies only when Kind is dtkDate.)"""
    DateTime: float
    """float:"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    DroppedDown: bool
    """bool: Specifies whether the date time picker control is dropped down.
        DroppedDown specifies whether the date time picker control is dropped down."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Format: str
    '''str: Specify format for date-time string.
        Format specifies custom format string for the date-time display, overriding the control panel strings. A custom format can include both date and time fields, but time fields are not editable unless the Kind property is dtkTime. The following format characters are understood.
        
        
        
        
        
        Element
        
        Description
        
        
        
        d
        
        
        
        The one- or two-digit day.
        
        
        
        
        dd
        
        
        
        The two-digit day. Single-digit day values are preceded by a zero.
        
        
        
        
        ddd
        
        
        
        The three-character weekday abbreviation.
        
        
        
        
        dddd
        
        
        
        The full weekday name.
        
        
        
        
        h
        
        
        
        The one- or two-digit hour in 12-hour format.
        
        
        
        
        hh
        
        
        
        The two-digit hour in 12-hour format. Single-digit values are preceded by a zero.
        
        
        
        
        H
        
        
        
        The one- or two-digit hour in 24-hour format.
        
        
        
        
        HH
        
        
        
        The two-digit hour in 24-hour format. Single-digit values are preceded by a zero.
        
        
        
        
        m
        
        
        
        The one- or two-digit minute.
        
        
        
        
        mm
        
        
        
        The two-digit minute. Single-digit values are preceded by a zero.
        
        
        
        
        M
        
        
        
        The one- or two-digit month number.
        
        
        
        
        MM
        
        
        
        The two-digit month number. Single-digit values are preceded by a zero.
        
        
        
        
        MMM
        
        
        
        The three-character month abbreviation.
        
        
        
        
        MMMM
        
        
        
        The full month name.
        
        
        
        
        t
        
        
        
        The one-letter AM/PM abbreviation (that is, AM is displayed as "A").
        
        
        
        
        tt
        
        
        
        The two-letter AM/PM abbreviation (that is, AM is displayed as "AM").
        
        
        
        
        yy
        
        
        
        The last two digits of the year (that is, 2001 would be displayed as "01").
        
        
        
        
        yyyy
        
        
        
        The full year (that is, 2001 would be displayed as "2001").
        
        
        
        
        To include literal strings in the format, enclose them in single quotes. Failing to quote literal strings can have unpredictable results, even if they do not include formatting codes. Use two single quotes to represent one single quote character in a literal string. For example,
        Today\'s date: MMM dd, yyyy
        entered in the property editor, produces the following results for April 1, 2001:
        "Today\'s date: Apr 01, 2001"
        
        Note:  When setting Format programmatically in Delphi code, double each single quote again:
        
        
        
        DateTimePicker1.Format := \'\'\'Today\'\'\'\'s date:\'\' MMM dd, yyyy\';'''
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    ImeMode: ImeMode
    """ImeMode: Determines the behavior of the input method editor (IME).
        Set ImeMode to configure the way an IME processes user keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application. 
        ImeMode allows a control to influence the type of conversion performed by the IME so that it is appropriate for the input expected by the control. For example, a control that only accepts numeric input might specify an ImeMode of imClose, as no conversion is necessary for numeric input.
        
        Note:  The value of ImeMode only takes effect when the control receives focus. To change the value of ImeMode when the control already has input focus, call the SetIme method."""
    ImeName: str
    """str: Specifies the input method editor (IME) to use for converting keyboard input to Asian language characters.
        Set ImeName to specify which IME to use for converting keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application.
        ImeName must specify one of the IMEs that has been installed through the Windows control panel. The property inspector provides a drop-down list of all currently installed IMEs on the system. At runtime, applications can obtain a list of currently installed IMEs from the global Screen variable.
        If ImeName specifies an unavailable IME, the IME that was active when the application started is used instead. No exception is generated.
        
        Note:  The value of ImeName only takes effect when the control receives focus. To change the value of ImeName after the control has input focus, call the SetIme method."""
    Kind: DateTimeKind
    """DateTimeKind: Determines whether the component is a date selector or a time selector.
        If the Kind property is dtkDate, the control is configured to support date editing. The default format gives only the date portion of the control value, and a drop-down calendar is available if the DateMode property is dmComboxBox.
        If the Kind property is dtkTime, the control is configured to support time editing. The default format give only the time portion of the control value, but the date portion can also be edited if the Format property includes date field codes.."""
    MaxDate: float
    """float:"""
    MinDate: float
    """float:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCloseUp: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDropDown: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnUserInput: Callable[[Object,str,float,bool],None]
    """Callable[[Object, str, float, bool], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    ParseInput: bool
    """bool: Enables the OnUserInput event.
        If ParseInput is True, the OnUserInput event occurs whenever the user types into the component's edit box."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowCheckbox: bool
    """bool: Displays a check box next to the date or time.
        Set ShowCheckbox to true to display a check box in the TDateTimePicker component."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Time: float
    """float: Indicates the time entered by the user.
        Time represents the time entered by the user. Set Time in program code or in the Object Inspector to determine which time is selected by default. (Applies only when Kind = dtkTime.)"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TDateTimePicker.Create(AOwner: Component) -> None
        Creates and initializes a TDateTimePicker instance.
        Create calls the inherited constructor method and initializes the Date and Time properties to the current date and time. It also sets the following ControlStyle flags: csCaptureMouse, csOpaque, csClickEvents, csDoubleClicks, and csFixedHeight."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class DelphiDefaultContainer:
    """Abstract Container type for Delphi"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __delitem__(self, other) -> Any:
        """Delete self[key]."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""
    def __setitem__(self, index, object) -> None:
        """Set self[key] to value."""

class DelphiDefaultIterator:
    """Iterator for Abstract Containers"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __next__(self) -> Any:
        """Implement next(self)."""

class DelphiDefaultMapping:
    """Abstract Mapping type for Delphi"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __delitem__(self, other) -> Any:
        """Delete self[key]."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""
    def __setitem__(self, index, object) -> None:
        """Set self[key] to value."""

class DelphiMethod:
    """Wrapper for Delphi methods"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __call__(self, *args, **kwargs) -> Any:
        """Call self as a function."""

class DragImageList(CustomImageList):
    """Wrapper for Delphi TDragImageList"""
    __hash__: ClassVar[None] = ...
    ColorDepth: ColorDepth
    """ColorDepth:"""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    DragCursor: int
    """int:"""
    DragHotspot: Point
    """Point:"""
    Dragging: bool
    """bool:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BeginDrag(self, Window: int, X: int, Y: int) -> bool:
        """TDragImageList.BeginDrag(Window: int, X: int, Y: int) -> bool"""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def DragLock(self, Window: int, XPos: int, YPos: int) -> bool:
        """TDragImageList.DragLock(Window: int, XPos: int, YPos: int) -> bool"""
    def DragMove(self, X: int, Y: int) -> bool:
        """TDragImageList.DragMove(X: int, Y: int) -> bool"""
    def DragUnlock(self, *args, **kwargs) -> Any: ...
    def EndDrag(self, *args, **kwargs) -> Any: ...
    def GetHotSpot(self, *args, **kwargs) -> Any: ...
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def HideDragImage(self, *args, **kwargs) -> Any: ...
    def SetDragImage(self, Index: int, HotSpotX: int, HotSpotY: int) -> bool:
        """TDragImageList.SetDragImage(Index: int, HotSpotX: int, HotSpotY: int) -> bool"""
    def ShowDragImage(self, *args, **kwargs) -> Any: ...
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class DrawGrid(CustomDrawGrid):
    """TDrawGrid represents a grid control that displays information in column and row format.
    Add a TDrawGrid object to a form to present arbitrary information in a tabular format. TDrawGrid provides many properties to control the appearance of the grid, as well as events and methods that take advantage of the tabular organization of the grid in responding to user actions. 
    TDrawGrid introduces several events and methods to allow applications to customize the appearance and behavior of the grid. 
    If the cells of the grid contain text strings that represent objects, consider using a TStringGrid object instead. If the grid displays field values from the records in a dataset, use TDBGrid instead."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BevelWidth: int
    """int: Specifies the width of the inner and outer bevels.
        Use BevelWidth to specify the width, in pixels, of the inner and outer bevels."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: BorderStyle
    """BorderStyle: Determines whether a single line border is drawn around the grid.
        Set BorderStyle to bsSingle to add a single line border around the grid's image. Set BorderStyle to bsNone to omit the border."""
    Canvas: Any
    """Specifies the TCanvas object that presents a drawing surface for the control."""
    Col: Any
    """Specifies the index of the column that contains the selected cell."""
    ColCount: int
    """int: Specifies the number of columns in the grid.
        Read ColCount to determine the number entries in the ColWidths array. Set ColCount to add or delete columns at the right side of the grid. The value of ColCount includes any fixed columns at the left of the grid as well as the scrollable columns in the body of the grid."""
    ColWidths: Any
    """Specifies column widths of the grid"""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DefaultColAlignment: Alignment
    """Alignment: DefaultColAlignment is the default text alignment for all columns where alignment is not explicitly specified using TCustomGrid.ColAlignments."""
    DefaultColWidth: int
    """int: Determines the width (in pixels) of all columns that have not been explicitly resized.
        Set DefaultColWidth to change the size of all columns in the grid. When DefaultColWidth is set, columns that have been resized using the mouse or by setting the ColWidths property are given the DefaultColWidth as well. 
        When new columns are added to the grid using the ColCount property, they are created with a width of DefaultColWidth."""
    DefaultDrawing: bool
    """bool: Determines whether the Cells are painted when the grid is drawn.
        Set DefaultDrawing to true to have the grid automatically paint the cells in the grid, including adding the background color, the 3-D effects on the fixed cells, and the focus rectangle around the selected cell. Set DefaultDrawing to false to skip the painting of the cells when the grid is drawn.
        When DefaultDrawing is false, the cells should be painted using the DrawCell method. For TCustomGrid, DrawCell is an abstract method. Descendants of TCustomGrid use DrawCell to provide their own customized drawing code, or to generate an OnDrawCell event."""
    DefaultRowHeight: int
    """int: Specifies the height (in pixels) of all rows that have not been explicitly resized.
        Set DefaultRowHeight to change the size of all rows in the grid. When DefaultRowHeight is set, rows that have been resized using the mouse or by setting the RowHeights property are given the DefaultRowHeight as well. 
        When new rows are added to the grid using the RowCount property, they are created with a height of DefaultRowHeight."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    DrawingStyle: GridDrawingStyle
    """GridDrawingStyle: Determines the style used when drawing the grid.
        DrawingStyle determines the style used to draw the grid. The following table lists the possible values of DrawingStyle. 
        
        
        
        
        Value
        
        Meaning
        
        
        
        gdsClassic
        
        
        
        The grid control uses the standard, unthemed style.
        
        
        
        
        gdsThemed
        
        
        
        The grid control uses the current operating system theme.
        
        
        
        
        gdsGradient
        
        
        
        The grid control uses gradients for styling.
        
        
        
        
        Notes about DrawingStyle for Vcl.Grids.TStringGrid:
        Setting FixedColor has no effect unless you also set DrawingStyle to gdsClassic.
        Setting GradientStartColor and GradientEndColor has no effect unless you set the value of DrawingStyle to gdsGradient."""
    EditorMode: Any
    """Determines whether the current cell can be edited."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    FixedColor: int
    """int: Specifies the background color of the fixed rows and columns in the grid.
        Set FixedColor to specify the color for the nonscrolling cells in the grid. The scrolling region of the grid is drawn using the Color property."""
    FixedCols: int
    """int: Specifies the number of columns on the left of the grid that cannot be scrolled.
        Set FixedCols to create or get rid of nonscrolling columns. Nonscrolling columns appear at the left of the grid, and are always visible, even when the user scrolls the other columns in the grid. Use nonscrolling columns for displaying row titles or row numbers, or to implement a scroll lock that the user can set.
        Nonscrolling columns are visually distinct from the scrollable columns in the grid. They are painted with a separate background color, and their cells have a raised, 3-D look.
        
        Note:  Grids must include at least one scrolling column. Do not set FixedCols to a value greater than ColCount - 1."""
    FixedRows: int
    """int: Specifies the number of rows on the top of the grid that cannot be scrolled.
        Set FixedRows to create or get rid of nonscrolling rows. Nonscrolling rows appear at the top of the grid, and are always visible, even when the user scrolls the other rows in the grid. Use nonscrolling rows for displaying column titles or column numbers.
        Nonscrolling rows are visually distinct from the scrollable rows in the grid. They are painted with a separate background color, and their cells have a raised, 3-D look.
        
        Note:  Grids must include at least one scrolling row. Do not set FixedRows to a value greater than RowCount - 1."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    GradientEndColor: int
    """int: Determines the ending gradient color.
        GradientEndColor determines the ending gradient color. GradientEndColor is used when the value of DrawingStyle is gdsGradient. GradientEndColor and GradientStartColor define the color range used when drawing individual cells within the grid control."""
    GradientStartColor: int
    """int: Determines the starting gradient color.
        GradientStartColor determines the starting gradient color. GradientStartColor is used when the value of DrawingStyle is gdsGradient. GradientEndColor and GradientStartColor define a color range used when drawing individual cells within the grid control."""
    GridHeight: Any
    """Specifies the height of the grid in pixels."""
    GridLineWidth: int
    """int: Specifies the width (in pixels) of the lines that separate the cells of the grid.
        Set GridLineWidth to make the lines that separate the cells in the grid heavier or lighter. When GridLineWidth is zero, no separators are drawn between the cells of the grid.
        GridLineWidth will have no effect if the Options property does not include goFixedHorzLine, goFixedVertLine, goHorzLine, or goVertLine.
        
        Note: Values greater than 3 pixels are not recommended for applications that run on Windows 9x or Windows ME because of distortions that can appear."""
    GridWidth: Any
    """Specifies the width of the grid in pixels."""
    LeftCol: Any
    """Specifies the index of the first visible scrollable column in the grid."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnColumnMoved: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDrawCell: Callable[[Object,int,int,Rect,GridDrawState],None]
    """Callable[[Object, int, int, Rect, GridDrawState], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFixedCellClick: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetEditMask: Callable[[Object,int,int,str],None]
    """Callable[[Object, int, int, str], None]:"""
    OnGetEditText: Callable[[Object,int,int,str],None]
    """Callable[[Object, int, int, str], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseWheelDown: Callable[[Object,ShiftState,Point,bool],None]
    """Callable[[Object, ShiftState, Point, bool], None]:"""
    OnMouseWheelUp: Callable[[Object,ShiftState,Point,bool],None]
    """Callable[[Object, ShiftState, Point, bool], None]:"""
    OnRowMoved: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnSelectCell: Callable[[Object,int,int,bool],None]
    """Callable[[Object, int, int, bool], None]:"""
    OnSetEditText: Callable[[Object,int,int,str],None]
    """Callable[[Object, int, int, str], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnTopLeftChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Options: GridOptions
    """GridOptions: Specifies various display and behavioral properties of the grid.
        Set Options to include the desired properties for the grid. See the type Vcl.Grids.TGridOptions for definitions of these properties."""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    Row: Any
    """Specifies the index of the row that contains the selected cell."""
    RowCount: int
    """int: Specifies the number of rows in the grid.
        Read RowCount to determine the number of entries in the RowHeights array. Set RowCount to add or delete rows at the bottom of the grid. The value of RowCount includes any fixed rows at the top of the grid as well as the scrollable rows in the body of the grid."""
    RowHeights: Any
    """Specifies row heights of the grid"""
    ScrollBars: ScrollStyle
    """ScrollStyle: Specifies whether the grid includes horizontal and vertical scroll bars.
        Use ScrollBars to give the grid horizontal or vertical scroll bars.
        
        Note:  If all the cells in the grid fit in the ClientWidth, no horizontal scroll bar appears, even if ScrollBars is ssHorizontal or ssBoth. If all the cells fit in the ClientHeight, no vertical scroll bar appears, even if ScrollBars is ssVertical or ssBoth."""
    Selection: Any
    """Indicates the boundaries of the current selection."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TopRow: Any
    """Specifies the index of the first visible scrollable row in the grid."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    VisibleColCount: int
    """int: Indicates the number of scrollable columns visible in the grid.
        Use VisibleColCount to determine the number of scrollable columns fully visible in the grid. VisibleColCount does not include the fixed columns counted by the FixedCols property. It does not include any partially visible columns on the right edge of the grid."""
    VisibleRowCount: int
    """int: Indicates the number of scrollable rows visible in the grid.
        Use VisibleRowCount to determine the number of scrollable rows fully visible in the grid. VisibleRowCount does not include the fixed rows counted by the FixedRows property. It does not include any partially visible rows on the bottom of the grid."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Edit(CustomEdit):
    """TEdit is a wrapper for a Windows single-line edit control.
    Use a TEdit object to put a standard Windows edit control on a form. Edit controls are used to retrieve text that users type. Edit controls can also display text to the user. 
    When only displaying text to the user, choose an edit control to allow users to select text and copy it to the Clipboard. Choose a label object if the selection capabilities of an edit control are not needed.
    TEdit implements the generic behavior introduced in TCustomEdit. TEdit publishes many of the properties inherited from TCustomEdit, but does not introduce any new behavior. For specialized edit controls, use other descendant classes of TCustomEdit or derive from it."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: Alignment
    """Alignment: Determines how the text is aligned within the text edit control.
        Use Alignment to change the way the text is formatted in the text edit control. Alignment can take one of the following values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        taLeftJustify
        
        
        
        Align text to the left side of the control
        
        
        
        
        taCenter
        
        
        
        Center text horizontally in the control.
        
        
        
        
        taRightJustify
        
        
        
        Align text to the right side of the control."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSelect: bool
    """bool: Determines whether all the text in the edit control is automatically selected when the control gets focus.
        Set AutoSelect to select all the text when the edit control gets focus. AutoSelect only applies to single-line edit controls.
        Use AutoSelect when the user is more likely to replace the text in the edit control than to append to it."""
    AutoSize: bool
    """bool: Determines whether the height of the edit control automatically resizes to accommodate the text.
        Use AutoSize to make the edit control adjust its size automatically so the client area accommodates the height of the text. When AutoSize is false, the edit control has a fixed height. When AutoSize is true, the size of the control is readjusted whenever a change occurs that could affect the height of the control, such as a change to the font or border style.
        
        Note: AutoSize only adjusts the height of the edit control. Even with AutoSize set to true, text in the edit control may appear truncated if it extends beyond the width of the control."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BevelWidth: int
    """int: Specifies the width of the inner and outer bevels.
        Use BevelWidth to specify the width, in pixels, of the inner and outer bevels."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: BorderStyle
    """BorderStyle: Determines whether the edit control has a single line border around the client area.
        Use BorderStyle to affect the sharpness with which the client area of the edit control stands out. BorderStyle can have a value of either bsSingle or bsNone. If BorderStyle is bsSingle, the edit control has a single-line border around the client area. If BorderStyle is bsNone, there will be no border."""
    CanUndoSelText: bool
    """bool: When set to True, it allows you to call or invoke an Undo operation in order to undo a change previously made by using SetSelText or SetSelTextBuf. By default it is set to false."""
    CharCase: EditCharCase
    """EditCharCase: Determines the case of the text within the edit control.
        Use CharCase to force the contents of the edit control to assume a particular case.
        When CharCase is set to ecLowerCase or ecUpperCase, the case of characters is converted as the user types them into the edit control. Changing the CharCase property to ecLowerCase or ecUpperCase changes the actual contents of the text, not just the appearance. Any case information is lost and can't be recaptured by changing CharCase to ecNormal."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HideSelection: bool
    """bool: Determines whether the visual indication of the selected text remains when focus shifts to another control.
        Set HideSelection to false to provide visual feedback of the selected portion of the text even when the edit control does not have focus. Set HideSelection to true to show the selection only when the edit control has focus. HideSelection does not affect the actual value of the selection, only the visual indication. Always setting HideSelection to false can make forms with many edit controls look too busy."""
    ImeMode: ImeMode
    """ImeMode: Determines the behavior of the input method editor (IME).
        Set ImeMode to configure the way an IME processes user keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application. 
        ImeMode allows a control to influence the type of conversion performed by the IME so that it is appropriate for the input expected by the control. For example, a control that only accepts numeric input might specify an ImeMode of imClose, as no conversion is necessary for numeric input.
        
        Note:  The value of ImeMode only takes effect when the control receives focus. To change the value of ImeMode when the control already has input focus, call the SetIme method."""
    ImeName: str
    """str: Specifies the input method editor (IME) to use for converting keyboard input to Asian language characters.
        Set ImeName to specify which IME to use for converting keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application.
        ImeName must specify one of the IMEs that has been installed through the Windows control panel. The property inspector provides a drop-down list of all currently installed IMEs on the system. At runtime, applications can obtain a list of currently installed IMEs from the global Screen variable.
        If ImeName specifies an unavailable IME, the IME that was active when the application started is used instead. No exception is generated.
        
        Note:  The value of ImeName only takes effect when the control receives focus. To change the value of ImeName after the control has input focus, call the SetIme method."""
    MaxLength: int
    """int: Specifies the maximum number of characters the user can enter into the edit control.
        Use MaxLength to limit the number of characters that can be entered into the edit control. A value of 0 indicates that there is no application-defined limit on the length.
        Use MaxLength to limit the length of the text in an edit control if that text will be copied into a fixed-length buffer.
        
        Note:  Setting MaxLength will not truncate the existing text, it merely prevents the user from adding more text after reaching the limit of MaxLength characters.
        Note:  Even when MaxLength is 0, there may be limitations imposed by the operating system on the number of characters that may be entered into an edit control.
        Note:  The unit of MaxLength is characters (not bytes) if the application is using themes."""
    NumbersOnly: bool
    """bool: Allows only numbers to be typed into the text edit.
        Use NumbersOnly to prohibit entry of non-numeric characters in the textfield. Note, however, that a user can paste non-numeric characters in the textfield even when this property is set.
        
        Code Examples
        StdCtrlsProp (Delphi)
        StdCtrlsProp (C++)"""
    OEMConvert: bool
    """bool: Determines whether characters typed in the edit control are converted from ANSI to OEM and then back to ANSI.
        To ensure that any characters typed in the edit control can be unambiguously converted to the OEM character set, set OEMConvert to true. This causes all characters to be converted from ANSI to OEM and then back to ANSI as they are typed. Set OEMConvert to false to avoid the overhead of this conversion when it does not matter whether the text can be unambiguously mapped to an OEM string.
        OEMConvert is most useful for edit controls used to enter file names when the application does not use Unicode file names."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PasswordChar: Any
    """unicodechr(str): Indicates the character, if any, to display in place of the actual characters typed in the control.
        Use the PasswordChar property to create an edit control that displays a special character in place of any entered text. If PasswordChar is set to the null character (ANSI character zero), the edit control displays its text normally. If PasswordChar is any other character, the edit control displays PasswordChar in place of each character typed. PasswordChar affects the appearance of the edit control only. The value of the Text property reflects the actual characters that are typed."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ReadOnly: bool
    """bool: Determines whether the user can change the text of the edit control.
        To restrict the edit control to display only, set the ReadOnly property to true. Set ReadOnly to false to allow the contents of the edit control to be edited.
        Setting ReadOnly to true ensures that the text is not altered, while still allowing the user to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    SelStart: Any
    """Returns/sets the position of the cursor."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Text: str
    """str: Contains a text string associated with the control.
        Use the Text property to read the Text of the control or to specify a new string for the Text value. By default, Text is the control name. For edit controls and memos, the Text appears within the control. For combo boxes, the Text is the content of the edit control portion of the combo box. 
        
        Note:  Controls that display text use either the Caption property or the Text property to specify the text value. Which property is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control."""
    TextHint: str
    """str: A hint or message to be displayed when the Text property is empty.
        Use TextHint to cue the user on what kind of entry is expected in the text field. Runtime themes must be enabled.
        
        Code Examples
        StdCtrlsProp (Delphi)
        StdCtrlsProp (C++)"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FileOpenDialog(Component):
    """Class for Vista and newer Windows operating systems style file open dialogs.
    This class extends TCustomFileOpenDialog. It allows creating Microsoft Windows Vista (or newer Windows operating systems) style file open dialogs CLSID_FileOpenDialog and implements the IFileOpenDialog interface."""
    __hash__: ClassVar[None] = ...
    ClientGuid: str
    """str:"""
    DefaultExtension: str
    """str:"""
    DefaultFolder: str
    """str:"""
    FavoriteLinks: FavoriteLinkItems
    """FavoriteLinkItems:"""
    FileName: Any
    FileNameLabel: str
    """str:"""
    FileTypeIndex: int
    """int:"""
    FileTypes: FileTypeItems
    """FileTypeItems:"""
    OkButtonLabel: str
    """str:"""
    OnExecute: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFileOkClick: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnFolderChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFolderChanging: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnSelectionChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnShareViolation: Callable[[Object,FileDialogShareViolationResponse],None]
    """Callable[[Object, FileDialogShareViolationResponse], None]:"""
    OnTypeChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Options: FileDialogOptions
    """FileDialogOptions:"""
    Title: str
    """str:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TFileOpenDialog.Execute()
        Displays the dialog"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class FileStream(HandleStream):
    """TFileStream enables applications to read from and write to a file on disk.
    Use TFileStream to access the information in disk files. TFileStream will open a named file and provide methods to read from or write to it. If an application already has a handle to the file, opened in the appropriate mode, use THandleStream instead."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    FileName: str
    """str: Preserves the file name of the file associated with the file stream.
        Use FileName to display the name of the file that TFileStream has accessed from disk. This is a read only property."""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AFileName: str, Mode: int) -> None:
        """TFileStream.Create(AFileName: str, Mode: int) -> None
        Creates an instance of TFileStream.
        Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
        The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or'ed together. The open mode must be one of the following values:
        
        
        
        Value
        
        Meaning
        
        Declared In
        
        
        
        fmCreate
        
        
        
        Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.
        
        
        
        System.Classes
        
        
        
        
        fmOpenRead
        
        
        
        Open the file for reading only.
        
        
        
        System.SysUtils
        
        
        
        
        fmOpenWrite
        
        
        
        Open the file for writing only. Writing to the file completely replaces the current contents.
        
        
        
        System.SysUtils
        
        
        
        
        fmOpenReadWrite
        
        
        
        Open the file to modify the current contents rather than replace them.
        
        
        
        System.SysUtils
        
        
        
        The share mode must be one of the following values:
        
        
        
        Value
        
        Meaning
        
        Declared In
        
        
        
        fmShareCompat
        
        
        
        Sharing is compatible with the way FCBs are opened.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareExclusive
        
        
        
        Other applications cannot open the file for any reason.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyWrite
        
        
        
        Other applications can open the file for reading but not for writing.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyRead
        
        
        
        Other applications can open the file for writing but not for reading.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyNone
        
        
        
        No attempt is made to prevent other applications from reading from or writing to the file.
        
        
        
        System.SysUtils
        
        
        Note: On Windows, the Rights parameter is ignored.
        If the file cannot be opened, Create raises an exception.\r
        Creates an instance of TFileStream.
        Call Create to instantiate a file stream for reading from or writing to the named file. Specify the name of the file and the way the file should be opened as parameters. 
        The Mode parameter indicates how the file is to be opened. The Mode parameter consists of an open mode and (possibly) a share mode or'ed together. The open mode must be one of the following values:
        
        
        
        Value
        
        Meaning
        
        Declared In
        
        
        
        fmCreate
        
        
        
        Create a file with the given name. If a file with the given name exists, override the existing file and open it in write mode.
        
        
        
        System.Classes
        
        
        
        
        fmOpenRead
        
        
        
        Open the file for reading only.
        
        
        
        System.SysUtils
        
        
        
        
        fmOpenWrite
        
        
        
        Open the file for writing only. Writing to the file completely replaces the current contents.
        
        
        
        System.SysUtils
        
        
        
        
        fmOpenReadWrite
        
        
        
        Open the file to modify the current contents rather than replace them.
        
        
        
        System.SysUtils
        
        
        
        The share mode must be one of the following values:
        
        
        
        Value
        
        Meaning
        
        Declared In
        
        
        
        fmShareCompat
        
        
        
        Sharing is compatible with the way FCBs are opened.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareExclusive
        
        
        
        Other applications cannot open the file for any reason.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyWrite
        
        
        
        Other applications can open the file for reading but not for writing.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyRead
        
        
        
        Other applications can open the file for writing but not for reading.
        
        
        
        System.SysUtils
        
        
        
        
        fmShareDenyNone
        
        
        
        No attempt is made to prevent other applications from reading from or writing to the file.
        
        
        
        System.SysUtils
        
        
        Note: On Windows, the Rights parameter is ignored.
        If the file cannot be opened, Create raises an exception."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TFileStream.
        Do not call Destroy directly in an application. Instead, call Free, which checks that the TFileStream reference is not nil and only then calls Destroy.
        Destroy closes the Handle for the file stream before freeing the object."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Form(CustomForm):
    """TForm represents a standard application window (form).
    When you create forms in the Form designer at design time, they are implemented as descendants of TForm. Forms can represent the application's main window, or dialog boxes, or MDI children. A form can contain other objects, such as TButton, TCheckBox, and TComboBox objects.
    Examples of forms include TLoginDialog and TPasswordDialog objects."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    ActiveControl: WinControl
    """WinControl: Specifies the control that has focus on the form.
        Use ActiveControl to get or set the control that has focus on the form. Only one control can have focus at a given time in an application.
        If the form does not have focus, ActiveControl is the control on the form that will receive focus when the form receives focus.
        
        Note:  When focus shifts to another control, ActiveControl is updated before the OnExit event occurs."""
    ActiveMDIChild: Form
    """Form: Specifies the MDI child that has focus.
        Use ActiveMDIChild to get the MDI child that has focus.
        If the form is not an MDI parent (that is, if the FormStyle property of the form is not fsMDIForm), ActiveMDIChild returns nil (Delphi) or NULL (C++)."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    AlphaBlend: bool
    """bool: Specifies whether the form is translucent.
        Set AlphaBlend to specify that the form represents a layered window that allows a translucent color. The AlphaBlendValue property specifies the degree of translucency.
        
        Note: AlphaBlend does not work on all systems. The application must be running under Windows 2000 or better, and the machine must be a P90 or better."""
    AlphaBlendValue: int
    """int: Specifies the degree of translucency on a translucent form.
        Set AlphaBlendValue to a value between 0 and 255 to indicate the degree of translucency when the AlphaBlend property is true. A value of 0 indicates a completely transparent window. A value of 255 indicates complete opacity.
        
        Note: AlphaBlendValue only has an effect when the AlphaBlend property is true."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoScroll: bool
    """bool: Indicates whether scroll bars appear automatically on the scrolling windowed control if it is not large enough to display all of its controls.
        If AutoScroll is true, the scroll bars appear automatically when necessary. For example, if the user resizes the control so that some of its controls are partially obscured, scroll bars appear.
        If AutoScroll is false, scroll bars don't appear automatically. In this case, use the HorzScrollBar and VertScrollBar properties to make scroll bars appear."""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderIcons: BorderIcons
    """BorderIcons: Specifies which icons appear on the title bar of the form.
        Use BorderIcons to get or set the icons that appear on the title bar of the form. BorderIcons can include any of the following TBorderIcons values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        biSystemMenu
        
        
        
        The form has a Control menu (also known as a System menu).
        
        
        
        
        biMinimize
        
        
        
        The form has a Minimize button
        
        
        
        
        biMaximize
        
        
        
        The form has a Maximize button
        
        
        
        
        biHelp
        
        
        
        If BorderStyle is bsDialog or biMinimize and biMaximize are excluded, a question mark appears in the form's title bar and when clicked, the cursor changes to crHelp; otherwise,no question mark appears.
        
        
        
        
        
        Note:  Certain combinations of the BorderIcons and BorderStyle properties are mutually exclusive. For example, BorderIcons biMax, biMin with BorderStyle of bsDialog are mutually exclusive."""
    BorderStyle: FormBorderStyle
    """FormBorderStyle: Specifies the appearance and behavior of the form border.
        Use BorderStyle to get or set the appearance and behavior of the form border. BorderStyle can be any of the following TForm BorderStyle values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        bsDialog
        
        
        
        Not resizable; no minimize/maximize menu
        
        
        
        
        bsSingle
        
        
        
        Not resizable; minimize/maximize menu
        
        
        
        
        bsNone
        
        
        
        Not resizable; no visible border line
        
        
        
        
        bsSizeable
        
        
        
        Standard resizable border
        
        
        
        
        bsToolWindow
        
        
        
        like bsSingle but with a smaller caption
        
        
        
        
        bsSizeToolWin
        
        
        
        like bsSizeable with a smaller caption
        
        
        
        
        
        Note:  Changing the border style of an MDI child form to bsDialog or bsNone has no effect."""
    BorderWidth: int
    """int: Specifies the width of the control's border.
        Use BorderWidth to get or set the width of the control's border. Graphics or text drawn by the control is clipped to the area within the border."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    ClientHandle: int
    """int: Provides access to the handle of the form's internal MDI client window.
        Use ClientHandle to get the handle for the form's internal MDI client window.
        ClientHandle is meaningful only if the form is an MDI parent (that is, if the form's FormStyle property is set to fsMDIForm).
        
        Note:  Use the Handle property instead to get the handle to the form window itself."""
    ClientHeight: int
    """int: Specifies the height of the control's client area in pixels.
        Use ClientHeight to read or change the height of the control's client area.
        For TControl, ClientHeight is the same as Height. Derived classes may implement a ClientHeight property that differs from Height. For example, the ClientHeight of a form is the value of the Height property minus the height of the title bar, resize border, and scroll bars."""
    ClientWidth: int
    """int: Specifies the horizontal size of the control's client area in pixels.
        Use ClientWidth to read or change the width of the control's client area. ClientWidth is equivalent to ClientRect.Right.
        For TControl, ClientWidth is the same as Width. Derived classes may implement a ClientWidth property that differs from Width. For example, the ClientWidth of a form is the value of the Width property minus the width of the resize border and scroll bars."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    CustomTitleBar: TitleBar
    """TitleBar: Embarcadero Technologies does not currently have any additional information."""
    DefaultMonitor: DefaultMonitor
    """DefaultMonitor: Specifies the monitor on which the form appears.
        Use DefaultMonitor to associate a form with a particular monitor in a multi-monitor application. The following table lists the possible values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        dmDesktop
        
        
        
        No attempt is made to position the form on a specific monitor.
        
        
        
        
        dmPrimary
        
        
        
        The form is positioned on the first monitor listed in the global screen object's Monitors property.
        
        
        
        
        dmMainForm
        
        
        
        The form appears on the same monitor as the application's main form.
        
        
        
        
        dmActiveForm
        
        
        
        The form appears on the same monitor as the currently active form.
        
        
        
        
        
        Note: DefaultMonitor has no effect if the application does not have a main form."""
    DockManager: IDockManager
    """IDockManager: Specifies the control's docking manager interface.
        Use DockManager to specify the control's docking manager. The docking manager handles the layout of docking zones (where controls are docked) and any painting associated with docking zones.
        If you set DockSite and UseDockManager to true, but do not assign a value to DockManager, the windowed control generates a default docking manager, using the global DefaultDockTreeClass variable."""
    DockSite: bool
    """bool: Specifies whether the control can be the target of drag-and-dock operations.
        Set DockSite to true to allow other controls to be docked to this windowed control.
        
        Code Examples
        Docking (Delphi)
        Docking (C++)"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    FormStyle: FormStyle
    """FormStyle: Determines the form's style.
        Use FormStyle to get or set the form's style. FormStyle is one of the following values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        fsNormal
        
        
        
        The form is neither an MDI parent window nor an MDI child window.
        
        
        
        
        fsMDIChild
        
        
        
        The form is an MDI child window.
        
        
        
        
        fsMDIForm
        
        
        
        The form is an MDI parent window.
        
        
        
        
        fsStayOnTop
        
        
        
        This form remains on top of the desktop and of other forms in the project, except any others that also have FormStyle set to fsStayOnTop. If one fsStayOnTop form launches another, neither form will consistently remain on top.
        
        
        
        
        If the form is the main form of an MDI application, its FormStyle property must be set to fsMDIForm.
        
        Note:  It is not advisable to change FormStyle at runtime.
        Warning:  TGraphicControl descendants placed in the client area of a form with FormStyle set to fsMDIForm will not paint."""
    GlassFrame: GlassFrame
    """GlassFrame: Accesses the Glass Frame under Windows Vista, Windows 7, or later Windows operating systems.
        Use GlassFrame to make your forms Windows Vista or Windows 7 Aero-compatible, displaying a glass effect. 
        GlassFrame is a property of a TGlassFrame object created automatically for any form. 
        
        Note: The property is only available for Windows Vista or Windows 7 with Aero. Otherwise, the Glass Frame is ignored."""
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    HelpFile: str
    """str: Specifies the name of the Help file the form uses to display the Help from.
        If your form should have a Help file different from the default Help file of the application specified using the TApplication.HelpFile property of the global TApplication type object, then use the HelpFile property of the form to specify the name of the Help file the form will use to display the Help from. 
        The Help system specified by TApplication.HelpSystem displays Help topics from the Help file specified by the HelpFile property of the form when the form has the focus."""
    HorzScrollBar: ControlScrollBar
    """ControlScrollBar: Represents the horizontal scroll bar for the scrolling windowed control.
        Use HorzScrollBar to hide, show, or manipulate the horizontal scroll bar for the scrolling windowed control."""
    Icon: Icon
    """Icon: Specifies the icon that appears when the form is minimized.
        Set the Icon property to provide an icon for the form. If Icon is not set, the system provides a default icon when the form is minimized."""
    KeyPreview: bool
    """bool: Specifies whether the form should receive keyboard events before the active control.
        If KeyPreview is true, keyboard events occur on the form before they occur on the active control. (The active control is specified by the ActiveControl property.) 
        If KeyPreview is false, keyboard events occur only on the active control.
        Navigation keys (Tab, BackTab, the arrow keys, and so on) are unaffected by KeyPreview because they do not generate keyboard events. Similarly, when a button has focus or when its Default property is true, the Enter key is unaffected by KeyPreview because it does not generate a keyboard events.
        KeyPreview is false by default."""
    MDIChildCount: int
    """int: Specifies the number of open MDI child forms.
        Use MDIChildCount to get the number of open MDI child forms.
        MDIChildCount is meaningful only if the form is an MDI parent (that is, if the form's FormStyle property is set to fsMDIForm)."""
    MDIChildren: Form
    """Form:"""
    Menu: MainMenu
    """MainMenu: Specifies the form's main menu.
        Use Menu to get or set the form's main menu. At design time, Menu is set to the first TMainMenu component added to the form."""
    ModalResult: Any
    """Represents the return value of a form that is used as a modal dialog."""
    ObjectMenuItem: MenuItem
    """MenuItem: Represents an OLE object menu item that reacts to selections of OLE objects.
        Use ObjectMenuItem to get or set a menu item that becomes enabled or disabled when an OLE object on the form is selected or unselected respectively.
        The OLE object menu item can be used for standard OLE commands, such as Activate or Convert. (The implementations of these commands are provided by the OLE server.)"""
    OnActivate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnAfterMonitorDpiChanged: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnAlignInsertBefore: Callable[[WinControl,Control,Control],bool]
    """Callable[[WinControl, Control, Control], bool]:"""
    OnAlignPosition: Callable[[WinControl,Control,int,int,int,int,Rect,AlignInfo],None]
    """Callable[[WinControl, Control, int, int, int, int, Rect, AlignInfo], None]:"""
    OnBeforeMonitorDpiChanged: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnCanResize: Callable[[Object,int,int,bool],None]
    """Callable[[Object, int, int, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClose: Callable[[Object,CloseAction],None]
    """Callable[[Object, CloseAction], None]:"""
    OnCloseQuery: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnConstrainedResize: Callable[[Object,int,int,int,int],None]
    """Callable[[Object, int, int, int, int], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnCreate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDeactivate: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDestroy: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDockDrop: Callable[[Object,DragDockObject,int,int],None]
    """Callable[[Object, DragDockObject, int, int], None]:"""
    OnDockOver: Callable[[Object,DragDockObject,int,int,DragState,bool],None]
    """Callable[[Object, DragDockObject, int, int, DragState, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetSiteInfo: Callable[[Object,Control,Rect,Point,bool],None]
    """Callable[[Object, Control, Rect, Point, bool], None]:"""
    OnHelp: Callable[[int,int,bool],bool]
    """Callable[[int, int, bool], bool]:"""
    OnHide: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseWheel: Callable[[Object,ShiftState,int,Point,bool],None]
    """Callable[[Object, ShiftState, int, Point, bool], None]:"""
    OnMouseWheelDown: Callable[[Object,ShiftState,Point,bool],None]
    """Callable[[Object, ShiftState, Point, bool], None]:"""
    OnMouseWheelUp: Callable[[Object,ShiftState,Point,bool],None]
    """Callable[[Object, ShiftState, Point, bool], None]:"""
    OnPaint: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnShortCut: Callable[[WMKey,bool],None]
    """Callable[[WMKey, bool], None]:"""
    OnShow: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnUnDock: Callable[[Object,Control,WinControl,bool],None]
    """Callable[[Object, Control, WinControl, bool], None]:"""
    Padding: Padding
    """Padding: Specifies the padding of a control.
        Use Padding to specify the padding of a control. This value is an instance of the class TPadding."""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    PopupMode: PopupMode
    '''PopupMode: Controls how the top-level form behaves with respect to Window\'s WS_POPUP style.
        The PopupMode property controls how the top-level form behaves with respect to Window\'s WS_POPUP style. A window that has the WS_POPUP style is always above its "owner" in Z-order. You can use the PopupMode property in conjunction with the PopupParent property to avoid the appearance of a hung application caused by a modal dialog showing up behind another form on the screen.
        
        Note: Using the PopupMode property is similar to specifying fsStayOnTop for the FormStyle property, but allows better control over the layering. 
        The PopupMode property is automatically set to pmAuto when the ShowModal method is called. However, this causes the window handle to be recreated, which is not usually desirable. To avoid the re-creation of window handles, you can explicitly set the PopupMode property to pmAuto prior to calling the ShowModal method (such as at design time). 
        Set the PopupMode property to pmExplicit for non-modal design windows such as tool palettes and other floating tool windows. This causes the windows to always remain on top of the main form. In the case of a snapped together design (in which the window is docked to the main form), the design window remains on top of the designer.
        
        Note: For undocked windows, the design window remains above the main form, allowing other top-level forms to obscure the design window. 
        Set the PopupMode property to pmNone if you want the pop-up window to have the pre-Delphi 8 behavior (except for the ShowModal item mentioned above).
        You can force the Z-Ordering of your forms and create a "stacked" appearance that the user cannot change by setting the PopupParent property to an explicit TCustomForm. If the PopupMode property is pmExplicit and PopupParent is nil, then the Application.MainForm is implicitly used as the PopupParent. If no Application.MainForm is assigned, then Application.Handle is used as the PopupParent. If the PopupMode property is set to pmAuto, Screen.ActiveForm is used as the PopupParent.'''
    PopupParent: CustomForm
    """CustomForm: Sets an order for stacked forms that users cannot change.
        If the PopupMode property is set to pmExplicit and PopupParent is nil, then the Application.MainForm is implicitly used as the PopupParent. If no Application.MainForm is assigned, then Application.Handle is used as the PopupParent.
        If the PopupMode property is set to pmAuto, Screen.ActiveForm is used as the PopupParent property."""
    Position: Position
    """Position: Represents the size and placement of the form.
        Use Position to get or set the size and placement of the form. Position can have one of the following TPosition values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        poDesigned
        
        
        
        The form appears positioned on the screen and with the same height and width as it had at design time.
        
        
        
        
        poDefault
        
        
        
        The form appears in a position on the screen and with a height and width determined by the operating system. Each time you run the application, the form moves slightly down and to the right. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen's resolution.
        The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of bsDialog or bsNone, for example), the window is positioned in the upper-left corner of the screen.
        
        
        
        
        poDefaultPosOnly
        
        
        
        The form displays with the size you created it at design time, but the operating system chooses its position on the screen. Each time you run the application, the form moves slightly down and to the right. When the form can no longer move down and to the right and keep the same size while remaining entirely visible on the screen, the form displays at the upper-left corner of the screen.
        The operating system only supports this for overlapped windows. For a pop-up or child window (that has a BorderStyle of bsDialog or bsNone, for example), the window is positioned in the upper-left corner of the screen.
        
        
        
        
        poDefaultSizeOnly
        
        
        
        The form appears in the position you left it at design time, but the operating system chooses its size. The right side of the form is always near the rightmost side of the screen, and the bottom of the form is always near the bottom of the screen, regardless of the screen's resolution.
        
        
        
        
        poScreenCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the screen. In multi-monitor applications, the form may be moved from this center position so that it falls entirely on one monitor, as specified by the DefaultMonitor property. 
        
        
        
        
        poDesktopCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the screen. No adjustments are made for multi-monitor applications.
        
        
        
        
        poMainFormCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the application's main form. No adjustments are made for multi-monitor applications. This position should only be used with secondary forms. If set for a main form, it acts like poScreenCenter.
        
        
        
        
        poOwnerFormCenter
        
        
        
        The form remains the size you left it at design time, but is positioned in the center of the form specified by the Owner property. If the Owner property does not specify a form, this position acts like poMainFormCenter.
        
        
        
        
        Note that if Position is set to poDefault, poDefaultPosOnly or poDefaultSizeOnly, and BorderStyle is set to bsDialog or bsNone, the form will be positioned at (0,0)."""
    PrintScale: PrintScale
    """PrintScale: Represents the proportions of a printed form.
        Use PrintScale to get or set the proportions of the printed form. PrintScale can have one of the following TPrintScale values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        poNone
        
        
        
        No special scaling occurs; therefore, the printed form and how the form appears onscreen may appear squished or stretched.
        
        
        
        
        poProportional
        
        
        
        The form is printed so that the printed image is approximately the same visible size as on the screen (WYSIWYG). The form image is scaled so that the printed image is approximately the same visible size as on the screen.
        
        
        
        
        poPrintToFit
        
        
        
        The form is printed using the same screen proportions, but in a size that just fits the printed page."""
    Scaled: bool
    """bool: Specifies whether the form is sized according to the value of the PixelsPerInch property.
        Scaled determines whether the form adjusts itself to differences between the font used at design time and the current system font used by a system at runtime. If Scaled is true, the form resizes itself and all its child controls to maintain the relationship between the size of controls and the height of text displayed in the default font. If Scaled is false, no such resizing occurs.
        By setting Scaled to true, the form can adjust to fonts that are not scalable (that is, fonts that only supply discrete point sizes) or to differences such as forms designed using small fonts at design time that are run on systems that use large fonts.
        The degree of resizing is determined by the PixelsPerInch property, which measures the proportion of the font on the system used when designing the form."""
    ScreenSnap: bool
    """bool: Specifies whether form snaps to edge of screen.
        ScreenSnap determines whether the edges of the form snap to the edge of the screen when the user moves the form. To control the snap distance, set the SnapBuffer property."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    SnapBuffer: int
    """int: Specifies distance for screen snap.
        If ScreenSnap is true, SnapBuffer determines the maximum number of pixels that be between the form edge and the screen edge before the form snaps to the screen edge."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TileMode: TileMode
    """TileMode: Represents how MDI child forms are arranged when the Tile method is called.
        TileMode can have one of the following TTileMode values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        tbHorizontal
        
        
        
        Each form stretches across the width of the parent form
        
        
        
        
        tbVertical
        
        
        
        Each form stretches along the height of the parent form
        
        
        
        
        TileMode is meaningful only if the form is an MDI child (that is, if the form's FormStyle property is set to fsMDIChild)."""
    TipMode: TipMode
    """TipMode: TipMode indicates whether TabTip (onscreen keyboard equivalent) opens or closes when the control receives focus or if it receives a gesture. 
        For example, in controls derived from TButtonControl the default mode is tipClose, so TabTip is instructed to disappear when the control receives focus or a gesture. The default for controls derived from TCustomEdit is tipOpen.
        
        Note: The above applies only to devices that have touch screen support"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    TransparentColor: bool
    """bool: Specifies whether a color on the form appears transparent.
        Use TransparentColor to indicate that one of the colors on the form should be treated as transparent, allowing windows behind the form to completely show through. The TransparentColorValue property indicates the color that appears completely transparent.
        
        Note:  To make the entire form transparent, or to make it translucent rather than transparent, use the AlphaBlend and AlphaBlendValue properties.
        Note: TransparentColor does not work on all systems. The application must be running under Windows 2000 or better, with adequate hardware."""
    TransparentColorValue: int
    """int: Indicates the color on the form that appears transparent when TransparentColor is true.
        Use TransparentColorValue to indicate the color that appears transparent when the TransparentColor property is true.
        
        Note:  If the application uses a 16-bit color palette, TransparentColorValue must be a basic color."""
    UseDockManager: bool
    """bool: Specifies whether the docking manager is used in drag-and-dock operations.
        Use UseDockManager to get or set whether a docking manager is used in drag-and-dock operations. 
        The docking manager handles the positioning of docked controls and any painting of docking zones around those controls. If you do not use a docking manager, docked controls are aligned to the windowed control based on the closest edge to where they are released. When you do not use a docking manager, there is no region for a user to grab to automatically undock a docked control."""
    VertScrollBar: ControlScrollBar
    """ControlScrollBar: Represents the vertical scroll bar for the scrolling windowed control.
        Use VertScrollBar to hide, show, or manipulate the vertical scroll bar for the scrolling windowed control."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    WindowMenu: MenuItem
    """MenuItem: Specifies the Window menu for an MDI parent form.
        Use WindowMenu to get or set the Window menu for an MDI parent form. The Window menu is a standard menu in MDI applications. It contains commands that let the user manage the windows in the application. Menu items usually include Cascade, Arrange Icons, Tile, and so on. 
        The Window menu also lists (at the bottom) the child windows that are currently open in the application. When the user selects one of these windows from the menu, the window becomes the active window in the application.
        Although this menu is commonly called the Window menu, it can have any name that corresponds to an existing menu item on the menu bar. The names of open child forms are merged onto the menu automatically at run-time.
        WindowMenu is meaningful only if the form is an MDI parent (that is, if the form's FormStyle property is set to fsMDIForm)."""
    WindowState: WindowState
    """WindowState: Represents how the form appears on the screen.
        Set WindowState to minimize, maximize, or restore the form window. Read WindowState to determine whether the form is minimized, maximized, or in a normal state."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def ArrangeIcons(self, *args, **kwargs) -> Any:
        """Arranges the icons of minimized MDI child forms.
        Use ArrangeIcons to arrange the icons of minimized MDI child forms so they are evenly spaced and don't overlap.
        ArrangeIcons works only if the form is an MDI parent form (that is, if the form's FormStyle property is fsMDIForm)."""
    def Cascade(self, *args, **kwargs) -> Any:
        """Arranges MDI child forms so they overlap.
        Use Cascade to arrange MDI child forms so they overlap.
        Cascade works only if the form is an MDI parent form (that is, if the form's FormStyle property is fsMDIForm)."""
    def Close(self) -> Any:
        """TForm.Close()
        Closes the wrapped Form"""
    def CloseQuery(self) -> Any:
        """TForm.CloseQuery()
        Asked the wrapped Form if it can close"""
    def LoadProps(self) -> Any:
        """TForm.LoadProps()
        Load properties from a .pydfm file"""
    def Next(self, *args, **kwargs) -> Any:
        """Activates the next child form in the form sequence.
        Use Next to change the active child form of an MDI parent. For example, if you have three child forms within a parent form and Form2 is the active form, the Next method makes Form3 the active form. Calling Next again makes Form4 active. The next time your application calls Next, the sequence starts over again and Form2 becomes the active form once again.
        The Next method applies only to forms that are MDI parent forms (have a FormStyle property value of fsMDIForm)."""
    def Previous(self, *args, **kwargs) -> Any:
        """Activates the previous MDI child form in the form sequence.
        Use Previous to change the active child form of an MDI parent. For example, if you have three child forms within a parent form and Form4 is the active form, the Previous method makes Form3 the active form. Calling Previous again makes Form2 active. The next time your application calls Previous, the sequence starts over again and Form4 becomes the active form once again.
        The Previous method applies only to forms that are MDI parent forms (have a FormStyle property value of fsMDIForm)."""
    def Release(self) -> Any:
        """TForm.Release()
        Releases (destroys) the wrapped Form"""
    def ShowModal(self) -> Any:
        """TForm.ShowModal()
        Shows the wrapped Form as a modal form"""
    def Tile(self, *args, **kwargs) -> Any:
        """Arranges MDI child forms so that they are all the same size.
        Use Tile to arrange MDI child forms so that they are all the same size. Tiled forms completely fill up the client area of the parent form. How the forms arrange themselves depends upon the values of their TileMode properties.
        Tile works only if the form is an MDI parent form (that is, if the form's FormStyle property is fsMDIForm)."""
    def get_MDIChildren(self, I: int) -> Form:
        """TForm.get_MDIChildren(I: int) -> Form
        Embarcadero Technologies does not currently have any additional information."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Graphic(Persistent):
    """TGraphic is the abstract base class type for objects such as icons, bitmaps, and metafiles that can store and display visual images.
    TGraphic is an abstract class that cannot be instantiated. Descendant graphics objects override many of the methods of TGraphic to address the needs of their particular file format and graphical characteristics. TGraphic also introduces methods that work with TPicture objects and the Clipboard. Properties of TGraphic provide information about the state and size of the graphic image.
    When the type of graphic is known, store the graphic in its specific type object. Otherwise, use a TPicture object that can hold any type of TGraphic."""
    __hash__: ClassVar[None] = ...
    Empty: Any
    Height: Any
    Modified: Any
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnProgress: Callable[[Object,ProgressStage,int,bool,Rect,str],None]
    """Callable[[Object, ProgressStage, int, bool, Rect, str], None]:"""
    Palette: Any
    PaletteModified: Any
    ScaledDrawer: ScaledGraphicDrawer
    """ScaledGraphicDrawer: Returns the reference to the scaled drawer.
        When the scaled drawer is enabled for graphic, then the ScaledDrawer property returns the reference to it. 
        
        See also
        EnableScaledDrawer"""
    SupportsPartialTransparency: bool
    """bool: Indicate whether graphic supports partial transparency or an alpha channel.
        SupportsPartialTransparency indicates whether the graphic supports partial transparency or an alpha channel.
        Some TGraphic descendants, such as TBitmap and TPngImage, can support partial transparency or an alpha channel. When a graphic that supports partial transparency is drawn on a canvas using DrawTransparent, it should be blended with the pixels on the canvas based on the value of the alpha channel."""
    Transparent: Any
    Width: Any
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    @classmethod
    def CanLoadFromStream(cls, Stream: Stream) -> bool:
        """TGraphic.CanLoadFromStream(Stream: Stream) -> bool
        CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
        The method uses current stream position, it does not change current stream position."""
    def Create(self, *args, **kwargs) -> Any:
        """Create TGraphic object.
        This method creates and intializes a TGraphic object."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TPersistent instance and frees its memory.
        Vcl.Graphics.TGraphic.Destroy inherits from System.Classes.TPersistent.Destroy. All content below this line refers to System.Classes.TPersistent.Destroy.
        Destroys the TPersistent instance and frees its memory.
        Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy."""
    def DisableScaledDrawer(self, *args, **kwargs) -> Any:
        """DisableScaledDrawer Disables scaled drawer for a graphic.
        
        See also
        ScaledDrawer
        EnableScaledDrawer"""
    def EnableScaledDrawer(self, AGraphicScalerClass: ScaledGraphicDrawerClass, AInitialize: bool) -> None:
        """TGraphic.EnableScaledDrawer(AGraphicScalerClass: ScaledGraphicDrawerClass, AInitialize: bool) -> None
        EnableScaledDrawer Enables scaled drawer for a graphic, which is used to scale the graphic.
        AGraphicScalerClass specifies the scaled drawer class, for example TWICScaledGraphicDrawer. 
        
        See also
        ScaledDrawer
        DisableScaledDrawer"""
    def Equals(self, Obj: Object) -> bool:
        """TGraphic.Equals(Obj: Object) -> bool
        Compare graphic to another TGraphic object and return true if objects contain same graphic.
        Equals compares the contents of two TGraphic objects. Equals returns false if the TGraphic are different classes or if they contain different graphical data.
        
        Code Examples
        TGraphic (Delphi)
        TGraphic (C++)\r
        Compare graphic to another TGraphic object and return true if objects contain same graphic.
        Equals compares the contents of two TGraphic objects. Equals returns false if the TGraphic are different classes or if they contain different graphical data.
        
        Code Examples
        TGraphic (Delphi)
        TGraphic (C++)"""
    def LoadFromClipboardFormat(self) -> Any:
        """TGraphic.LoadFromClipboardFormat()"""
    def LoadFromFile(self) -> Any:
        """TGraphic.LoadFromFile()"""
    def LoadFromStream(self) -> Any:
        """TGraphic.LoadFromStream()"""
    def SaveToClipboardFormat(self) -> Any:
        """TGraphic.SaveToClipboardFormat()"""
    def SaveToFile(self) -> Any:
        """TGraphic.SaveToFile()"""
    def SaveToStream(self) -> Any:
        """TGraphic.SaveToStream()"""
    def SetSize(self, AWidth: int, AHeight: int) -> None:
        """TGraphic.SetSize(AWidth: int, AHeight: int) -> None
        Specifies the size of the graphic.
        Use the SetSize method to set both the height and width of the graphic. This results in better performance than setting the height and width separately."""
    def UpdateScaledDrawer(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class GroupBox(CustomControl):
    """TGroupBox represents a Windows group box.
    The TGroupBox component represents a standard Windows group box, used to group related controls on a form. When another control component is placed within a group box, the group box becomes the parent of that component."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DefaultHeaderFont: bool
    """bool:"""
    DockSite: bool
    """bool: Specifies whether the control can be the target of drag-and-dock operations.
        Set DockSite to true to allow other controls to be docked to this windowed control.
        
        Code Examples
        Docking (Delphi)
        Docking (C++)"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HeaderFont: Font
    """Font:"""
    OnAlignInsertBefore: Callable[[WinControl,Control,Control],bool]
    """Callable[[WinControl, Control, Control], bool]:"""
    OnAlignPosition: Callable[[WinControl,Control,int,int,int,int,Rect,AlignInfo],None]
    """Callable[[WinControl, Control, int, int, int, int, Rect, AlignInfo], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDockDrop: Callable[[Object,DragDockObject,int,int],None]
    """Callable[[Object, DragDockObject, int, int], None]:"""
    OnDockOver: Callable[[Object,DragDockObject,int,int,DragState,bool],None]
    """Callable[[Object, DragDockObject, int, int, DragState, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetSiteInfo: Callable[[Object,Control,Rect,Point,bool],None]
    """Callable[[Object, Control, Rect, Point, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnUnDock: Callable[[Object,Control,WinControl,bool],None]
    """Callable[[Object, Control, WinControl, bool], None]:"""
    Padding: Padding
    """Padding: Specifies the padding of a control.
        Use Padding to specify the padding of a control. This value is an instance of the class TPadding."""
    ParentBackground: bool
    """bool: Determines whether the control uses its parent's theme background.
        If ParentBackground is True, the control uses the parent's theme background to draw its own background. 
        If  ParentBackground is False, the control uses its own properties, such as Color, to draw its background.
        ParentBackground has no effect unless XP themes are enabled."""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowFrame: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class HandleStream(Stream):
    """THandleStream enables applications to read from and write to communications resources identified by a handle.
    Use THandleStream to access files, sockets, named pipes, mailslots, or other communications resources that provide a handle when opened. For example, the FileOpen function provides a handle for a file on disk. THandleStream allows applications to use a uniform stream interface when performing I/O using a handle.
    To avoid the overhead of managing file handles, use TFileStream to work with disk files."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    Handle: int
    """int: Specifies the handle for the communications resource the stream reads from and writes to.
        Read Handle to get the handle for file management functions. To read from or write to the resource, use the methods of the THandleStream object.
        Handle is a read-only property. The handle property cannot be changed to allow the handle stream to switch from reading to writing or vice versa. For example, to change from a file handle that is opened in read-only mode to one that is opened in write mode:
        
        Free the stream object.
        Call FileClose to close the file.
        Reopen the file in write mode and use the handle to create a new instance of a handle stream. Alternately, open a TFileStream object for the file, specifying a write mode for the stream.
        Note: Do not call the FileClose function on the Handle until after the THandleStream object has been destroyed."""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AHandle: int) -> None:
        """THandleStream.Create(AHandle: int) -> None
        Creates an instance of THandleStream.
        Call Create to instantiate a THandleStream for a given handle.
        The handle must be obtained by opening or creating the resource in the appropriate mode. For example, to create a handle stream for reading from a file, obtain the file handle by opening the file with an fmOpenRead or fmOpenReadWrite mode. To create a handle stream for writing to a file, obtain the file handle by opening the file with an fmOpenWrite or fmOpenReadWrite mode."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def Read(self, Buffer, Count: int) -> int:
        """THandleStream.Read(Buffer, Count: int) -> int
        Reads up to Count bytes of data from the resource associated with the handle stream into Buffer.
        Use Read to read data from the resource associated with the handle stream when the number of bytes in the file is not known. Read transfers up to Count bytes from the resource, starting at the current position, and then advances the current position in the resource by the number of bytes actually transferred. Read returns the number of bytes actually transferred, which may be less than Count if the end of file marker is encountered.
        All other data-reading methods of a handle stream (ReadBuffer, ReadComponent) call Read to do the actual reading."""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def Seek(self, Offset: int, Origin: SeekOrigin) -> int:
        """THandleStream.Seek(Offset: int, Origin: SeekOrigin) -> int
        Resets the current position of the handle stream.
        Use Seek to move the current position within the resource associated with the handle stream by the indicated offset. Seek allows an application to read from or write to a particular location within the resource.
        The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        soFromBeginning
        
        
        
        Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be >= 0.
        
        
        
        
        soFromCurrent
        
        
        
        Offset is from the current position in the resource. Seek moves to Position + Offset.
        
        
        
        
        soFromEnd
        
        
        
        Offset is from the end of the resource. Offset must be <= 0 to indicate a number of bytes before the end of the file.
        
        
        Or you can also use TSeekOrigin and its values to indicate where to start a seek operation.
        Seek returns the new value of the Position property, the new current position in the resource."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """THandleStream.Write(Buffer, Count: int) -> int
        Writes Count bytes from the Buffer to the current position in the resource.
        Use Write to write Count bytes to the resource associated with the handle stream, starting at the current position. After writing to the resource, Write advances the current position by the number bytes written, and returns the number of bytes written.
        All other data-writing methods of a handle stream (WriteBuffer, WriteComponent) call Write to do the actual writing."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Header(CustomControl):
    """THeader is a sectioned visual control that displays text and allows each section to be resized with the mouse.
    THeader is provided for backward compatibility. New applications should use THeaderControl instead."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    AllowResize: bool
    """bool: Determines if the user can modify the size of the header at runtime with the mouse.
        If AllowResize is false, the sections within a header can't be resized. If AllowResize is true, clicking a border of a header section and dragging it left or right changes the width of the section. The default value is true."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BorderStyle: BorderStyle
    """BorderStyle: Determines whether the header control has a border.
        These are the possible values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        bsNone
        
        
        
        No visible border
        
        
        
        
        bsSingle
        
        
        
        Single-line border"""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnSized: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnSizing: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    SectionWidth: int
    """int:"""
    Sections: Strings
    """Strings: Lists the strings that contain the text for the sections of a header.
        The number of lines of the string list determines the number of sections of the header. If the string list is empty, the header has one blank section. If this string list contains one or more lines, the text of each line is in its own section. The first line is in the leftmost section, the second line is in the next section to the right, and so on."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """THeader.Create(AOwner: Component) -> None
        Creates a new THeader object.
        Call Create to instantiate a header at runtime. Headers added to forms at design time are created automatically.
        The AOwner parameter initializes the Owner property of the header."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Frees the memory associated with the THeader object.
        Do not call Destroy directly. Instead, use the Free method, which checks whether the THeader reference is nil before calling Destroy."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Icon(Graphic):
    """TIcon is an encapsulation of a Windows icon.
    Use TIcon to represent one of the icons in an image list. Assign an icon to objects that have an Icon property, such as TForm or TPicture. 
    Icon objects represent the value loaded from a Windows icon file (.ICO file). Draw an icon on a canvas, using the Draw method of the TCanvas object. Icons do not stretch, so do not use StretchDraw (TCanvas) with an icon.
    
    Note: TIcon can be used to display the value of a multi-resolution (>16 color) icon. However, it can not support the creation of multi-resolution icons, nor the resizing of the image after it is loaded from a file or stream."""
    __hash__: ClassVar[None] = ...
    Handle: Any
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, Source: Persistent) -> None:
        """TIcon.Assign(Source: Persistent) -> None
        Copies an icon image from another TIcon object.
        Call Assign to copy another icon object. Assign copies the icon image from the Source parameter if it is another TIcon object. Otherwise, Assign calls the inherited method, which copies the icon image from any source object that specifies how to copy to a TIcon in its AssignTo method."""
    def AssignTo(self, Dest: Persistent) -> None:
        """TIcon.AssignTo(Dest: Persistent) -> None
        Copies an icon image to a TBitmap graphical object.
        Call AssignTo to copy an icon to a TBitmap object. AssignTo copies the icon image to the Dest parameter if it is a TBitmap object. Otherwise, AssignTo fails. 
        The preferred way to copy an icon image to a bitmap is to use the Assign method of the TBitmap class, passing the icon object as the Source parameter.
        
        Note:  The bitmap resulted after a call to AssignTo always has alpha channel (transparency) information and a 32-bit color depth."""
    @classmethod
    def CanLoadFromStream(cls, Stream: Stream) -> bool:
        """TIcon.CanLoadFromStream(Stream: Stream) -> bool
        Vcl.Graphics.TIcon.CanLoadFromStream inherits from Vcl.Graphics.TGraphic.CanLoadFromStream. All content below this line refers to Vcl.Graphics.TGraphic.CanLoadFromStream.
        CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
        The method uses current stream position, it does not change current stream position."""
    def Create(self, *args, **kwargs) -> Any:
        """Creates an instance of TIcon.
        Call Create to create an empty icon object. Once an image has been read into the icon from a file or stream, or by assigning another icon object, the icon can be drawn on a canvas or added to an image list. Do not create an icon object for setting the icon property of a form or picture. These objects create a TIcon object in their own constructors. Instead, use the LoadFromFile, LoadFromStream, or LoadFromClipboardFormat method on the TIcon object that you can obtain by reading the Icon property."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TIcon.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TIcon reference is not nil, and only then calls Destroy."""
    def HandleAllocated(self, *args, **kwargs) -> Any:
        """Indicates whether the TIcon object has acquired a handle to the underlying GDI object.
        Use HandleAllocated to determine whether the Handle property is set to an HICON value. HandleAllocated indicates whether the underlying GDI object has already been created. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, it automatically creates an icon and returns its handle if the underlying GDI object does not already exist."""
    def LoadFromClipboardFormat(self, AFormat: int, AData: int, APalette: int) -> None:
        """TIcon.LoadFromClipboardFormat(AFormat: int, AData: int, APalette: int) -> None
        Prevents applications from loading icons from the clipboard.
        LoadFromClipboardFormat is overridden in TIcon because the clipboard format is not supported."""
    def LoadFromResourceID(self, Instance: int, ResID: int) -> None:
        """TIcon.LoadFromResourceID(Instance: int, ResID: int) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def LoadFromResourceName(self, Instance: int, ResName: str) -> None:
        """TIcon.LoadFromResourceName(Instance: int, ResName: str) -> None
        Loads an icon resource into the icon object.
        LoadFromResourceName loads the specified icon resource from a module's executable file.
        Instance is the handle of the module that contains the resource.
        ResName is the name of the resource to load."""
    def LoadFromStream(self, Stream: Stream) -> None:
        """TIcon.LoadFromStream(Stream: Stream) -> None
        Loads the icon from a stream.
        Use LoadFromStream to read the icon image from a stream. Set the Stream parameter to a stream object that provides access to the memory image of the icon. To load the icon from a .ico file, use the LoadFromFile method. To load the icon from the Clipboard, use the LoadFromClipboardFormat method."""
    def ReleaseHandle(self) -> Any:
        """TIcon.ReleaseHandle()"""
    def SaveToClipboardFormat(self, Format: int, Data: int, APalette: int) -> None:
        """TIcon.SaveToClipboardFormat(Format: int, Data: int, APalette: int) -> None
        Prevents applications from saving icons to the clipboard.
        SaveToClipboardFormat is overridden in TIcon because the format is not supported for the Clipboard."""
    def SaveToStream(self, Stream: Stream) -> None:
        """TIcon.SaveToStream(Stream: Stream) -> None
        Saves the icon to a stream.
        Use SaveToStream to write the icon image to a stream. Specify the Stream parameter as the stream object that receives the memory image of the icon. To write the icon to a .ico file, use the SaveToFile method. To write the icon to the Clipboard, use the SaveToClipboardFormat method."""
    def SetSize(self, AWidth: int, AHeight: int) -> None:
        """TIcon.SetSize(AWidth: int, AHeight: int) -> None
        Specifies the size of the icon.
        Use the SetSize method to set both the height and width of the icon. This results in better performance than setting the height and width separately."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Image(Control):
    """Wrapper for Delphi TImage"""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    Canvas: Canvas
    """Canvas:"""
    Center: bool
    """bool:"""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    IncrementalDisplay: bool
    """bool:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnFindGraphicClass: Callable[[Object,FindGraphicClassContext,GraphicClass],None]
    """Callable[[Object, FindGraphicClassContext, GraphicClass], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnProgress: Callable[[Object,ProgressStage,int,bool,Rect,str],None]
    """Callable[[Object, ProgressStage, int, bool, Rect, str], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    Picture: Picture
    """Picture:"""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    Proportional: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Stretch: bool
    """bool:"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Transparent: bool
    """bool:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TImage.Create(AOwner: Component) -> None
        Creates an instance of TControl.
        Calling Create constructs and initializes an instance of TControl. However, you should never attempt to instantiate a TControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants.
        Create calls the parent constructor and initializes the control. 
        When overriding Create, always call the inherited Create method first, then proceed with the control's initialization. Remember to specify the override directive when overriding the Create method.
        
        Note:  If a control's constructor allocates resources or memory, also override the destructor to free those resources."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy.
        Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
        As the control is destroyed, it:
        
        Frees the TFont object in its Font property.
        Calls its inherited destructor.
        Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method.
        When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ImageList(DragImageList):
    """Wrapper for Delphi TImageList"""
    __hash__: ClassVar[None] = ...
    AllocBy: int
    """int:"""
    BkColor: int
    """int:"""
    BlendColor: int
    """int:"""
    ColorDepth: ColorDepth
    """ColorDepth:"""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    DrawingStyle: DrawingStyle
    """DrawingStyle:"""
    GrayscaleFactor: int
    """int:"""
    Height: int
    """int:"""
    ImageType: ImageType
    """ImageType:"""
    Masked: bool
    """bool:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    ShareImages: bool
    """bool:"""
    Width: int
    """int:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Label(Control):
    """TLabel is a nonwindowed control that displays text on a form.
    Use TLabel to add text that the user cannot edit on a form. This text can be used to label another control, and can set focus to that control when the user types an accelerator key. The Caption property can be used to define an accelerator key to a label control. 
    Because TLabel is not a descendant of TWinControl, it does not have its own window and cannot receive direct input from the keyboard. To add an object to a form that can respond to keyboard input (other than setting focus to another object when an accelerator key is typed) in addition to displaying text, use TStaticText.
    To add an object to a form that displays text that a user can scroll or edit, use TEdit."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: Alignment
    """Alignment:"""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    EllipsisPosition: EllipsisPosition
    """EllipsisPosition:"""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    FocusControl: WinControl
    """WinControl:"""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    GlowSize: int
    """int:"""
    Layout: TextLayout
    """TextLayout:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowAccelChar: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Transparent: bool
    """bool:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    WordWrap: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LabeledEdit(CustomEdit):
    """TLabeledEdit is an edit control that has an associated label.
    Use TLabeledEdit to add an edit control with a label to a form. TLabeledEdit works with an associated label control, which is the value of its EditLabel property. The position of that label relative to the edit control is determined by the LabelPosition and LabelSpacing properties.
    Use the Text property to work with the text in the control, and the label's Caption property to work with the text in the label."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: Alignment
    """Alignment: Determines how the text is aligned within the text edit control.
        Use Alignment to change the way the text is formatted in the text edit control. Alignment can take one of the following values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        taLeftJustify
        
        
        
        Align text to the left side of the control
        
        
        
        
        taCenter
        
        
        
        Center text horizontally in the control.
        
        
        
        
        taRightJustify
        
        
        
        Align text to the right side of the control."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSelect: bool
    """bool: Determines whether all the text in the edit control is automatically selected when the control gets focus.
        Set AutoSelect to select all the text when the edit control gets focus. AutoSelect only applies to single-line edit controls.
        Use AutoSelect when the user is more likely to replace the text in the edit control than to append to it."""
    AutoSize: bool
    """bool: Determines whether the height of the edit control automatically resizes to accommodate the text.
        Use AutoSize to make the edit control adjust its size automatically so the client area accommodates the height of the text. When AutoSize is false, the edit control has a fixed height. When AutoSize is true, the size of the control is readjusted whenever a change occurs that could affect the height of the control, such as a change to the font or border style.
        
        Note: AutoSize only adjusts the height of the edit control. Even with AutoSize set to true, text in the edit control may appear truncated if it extends beyond the width of the control."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BevelWidth: int
    """int: Specifies the width of the inner and outer bevels.
        Use BevelWidth to specify the width, in pixels, of the inner and outer bevels."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: BorderStyle
    """BorderStyle: Determines whether the edit control has a single line border around the client area.
        Use BorderStyle to affect the sharpness with which the client area of the edit control stands out. BorderStyle can have a value of either bsSingle or bsNone. If BorderStyle is bsSingle, the edit control has a single-line border around the client area. If BorderStyle is bsNone, there will be no border."""
    CharCase: EditCharCase
    """EditCharCase: Determines the case of the text within the edit control.
        Use CharCase to force the contents of the edit control to assume a particular case.
        When CharCase is set to ecLowerCase or ecUpperCase, the case of characters is converted as the user types them into the edit control. Changing the CharCase property to ecLowerCase or ecUpperCase changes the actual contents of the text, not just the appearance. Any case information is lost and can't be recaptured by changing CharCase to ecNormal."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    EditLabel: BoundLabel
    """BoundLabel:"""
    EditMask: str
    """str:"""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HideSelection: bool
    """bool: Determines whether the visual indication of the selected text remains when focus shifts to another control.
        Set HideSelection to false to provide visual feedback of the selected portion of the text even when the edit control does not have focus. Set HideSelection to true to show the selection only when the edit control has focus. HideSelection does not affect the actual value of the selection, only the visual indication. Always setting HideSelection to false can make forms with many edit controls look too busy."""
    ImeMode: ImeMode
    """ImeMode: Determines the behavior of the input method editor (IME).
        Set ImeMode to configure the way an IME processes user keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application. 
        ImeMode allows a control to influence the type of conversion performed by the IME so that it is appropriate for the input expected by the control. For example, a control that only accepts numeric input might specify an ImeMode of imClose, as no conversion is necessary for numeric input.
        
        Note:  The value of ImeMode only takes effect when the control receives focus. To change the value of ImeMode when the control already has input focus, call the SetIme method."""
    ImeName: str
    """str: Specifies the input method editor (IME) to use for converting keyboard input to Asian language characters.
        Set ImeName to specify which IME to use for converting keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application.
        ImeName must specify one of the IMEs that has been installed through the Windows control panel. The property inspector provides a drop-down list of all currently installed IMEs on the system. At runtime, applications can obtain a list of currently installed IMEs from the global Screen variable.
        If ImeName specifies an unavailable IME, the IME that was active when the application started is used instead. No exception is generated.
        
        Note:  The value of ImeName only takes effect when the control receives focus. To change the value of ImeName after the control has input focus, call the SetIme method."""
    LabelPosition: LabelPosition
    """LabelPosition:"""
    LabelSpacing: int
    """int:"""
    MaxLength: int
    """int: Specifies the maximum number of characters the user can enter into the edit control.
        Use MaxLength to limit the number of characters that can be entered into the edit control. A value of 0 indicates that there is no application-defined limit on the length.
        Use MaxLength to limit the length of the text in an edit control if that text will be copied into a fixed-length buffer.
        
        Note:  Setting MaxLength will not truncate the existing text, it merely prevents the user from adding more text after reaching the limit of MaxLength characters.
        Note:  Even when MaxLength is 0, there may be limitations imposed by the operating system on the number of characters that may be entered into an edit control.
        Note:  The unit of MaxLength is characters (not bytes) if the application is using themes."""
    NumbersOnly: bool
    """bool: Allows only numbers to be typed into the text edit.
        Use NumbersOnly to prohibit entry of non-numeric characters in the textfield. Note, however, that a user can paste non-numeric characters in the textfield even when this property is set.
        
        Code Examples
        StdCtrlsProp (Delphi)
        StdCtrlsProp (C++)"""
    OEMConvert: bool
    """bool: Determines whether characters typed in the edit control are converted from ANSI to OEM and then back to ANSI.
        To ensure that any characters typed in the edit control can be unambiguously converted to the OEM character set, set OEMConvert to true. This causes all characters to be converted from ANSI to OEM and then back to ANSI as they are typed. Set OEMConvert to false to avoid the overhead of this conversion when it does not matter whether the text can be unambiguously mapped to an OEM string.
        OEMConvert is most useful for edit controls used to enter file names when the application does not use Unicode file names."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PasswordChar: Any
    """unicodechr(str): Indicates the character, if any, to display in place of the actual characters typed in the control.
        Use the PasswordChar property to create an edit control that displays a special character in place of any entered text. If PasswordChar is set to the null character (ANSI character zero), the edit control displays its text normally. If PasswordChar is any other character, the edit control displays PasswordChar in place of each character typed. PasswordChar affects the appearance of the edit control only. The value of the Text property reflects the actual characters that are typed."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ReadOnly: bool
    """bool: Determines whether the user can change the text of the edit control.
        To restrict the edit control to display only, set the ReadOnly property to true. Set ReadOnly to false to allow the contents of the edit control to be edited.
        Setting ReadOnly to true ensures that the text is not altered, while still allowing the user to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Text: str
    """str: Contains a text string associated with the control.
        Use the Text property to read the Text of the control or to specify a new string for the Text value. By default, Text is the control name. For edit controls and memos, the Text appears within the control. For combo boxes, the Text is the content of the edit control portion of the combo box. 
        
        Note:  Controls that display text use either the Caption property or the Text property to specify the text value. Which property is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control."""
    TextHint: str
    """str: A hint or message to be displayed when the Text property is empty.
        Use TextHint to cue the user on what kind of entry is expected in the text field. Runtime themes must be enabled.
        
        Code Examples
        StdCtrlsProp (Delphi)
        StdCtrlsProp (C++)"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkControlDelegate(BindComponentDelegate):
    """Is a binding component that wraps another binding component and references a control.
    The TLinkControlDelegate class implements a binding component that wraps another binding component and references a control.
    For more information regarding the delegates, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def CanSetControlComponent(self, Value: Component) -> bool:
        """TLinkControlDelegate.CanSetControlComponent(Value: Component) -> bool
        Returns whether the given parameter can be used as the control component of this binding component.
        CanSetControlComponent returns whether the given Value (that is itself a TComponent) can be used as the control component of this binding component."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkControlToField(CustomLinkControlToField):
    """Links a list control to a field.
    The TLinkListControlToField class extends TCustomLinkListControlToField with published properties.
    
    Tip: If the direction is bidirectional, then the control must support the IEditLinkObserver interface."""
    __hash__: ClassVar[None] = ...
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Control: Component
    """Component: Embarcadero Technologies does not currently have any additional information."""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    CustomParse: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TBaseLinkingBindSource object to which this delegate component links.
        Use DataSource to determine or set the TBaseLinkingBindSource object that connects to a specific dataset."""
    Direction: LinkControlToFieldDirection
    """LinkControlToFieldDirection: Embarcadero Technologies does not currently have any additional information."""
    FieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupDataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Embarcadero Technologies does not currently have any additional information."""
    LookupKeyFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupValueFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    OnActivated: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnActivating: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnAssignedValue: Callable[[Object,BindingAssignValueRec,Value],None]
    """Callable[[Object, BindingAssignValueRec, Value], None]:"""
    OnAssigningValue: Callable[[Object,BindingAssignValueRec,Value,bool],None]
    """Callable[[Object, BindingAssignValueRec, Value, bool], None]:"""
    OnEvalError: Callable[[Object,Exception],None]
    """Callable[[Object, Exception], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    Track: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseEvalShortcuts: bool
    """bool: Determines whether this binding component delegate uses evaluation shortcuts (True) or not (False)."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkControlToFieldDelegate(LinkControlDelegate):
    """Is a binding component that wraps another binding component and references a control, data source, and field.
    The TLinkControlToFieldDelegate class implements a binding component that wraps another binding component and references a control, a data source, and a field.
    For more information regarding the delegates, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TBaseLinkingBindSource object to which this delegate component links.
        Use DataSource to determine or set the TBaseLinkingBindSource object that connects to a specific dataset."""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkLabel(CustomLinkLabel):
    """Wrapper for Delphi TLinkLabel"""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: CustomLinkLabel.TLinkAlignment
    """CustomLinkLabel.TLinkAlignment:"""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnLinkClick: Callable[[Object,str,SysLinkType],None]
    """Callable[[Object, str, SysLinkType], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    UseVisualStyle: bool
    """bool:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkListControlToField(CustomLinkListControlToField):
    """Links a list control to a field.
    The TLinkListControlToField class extends TCustomLinkListControlToField with published properties.
    
    Tip: If the direction is bidirectional, then the control must support the IEditLinkObserver interface."""
    __hash__: ClassVar[None] = ...
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Control: Component
    """Component: Embarcadero Technologies does not currently have any additional information."""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TBaseLinkingBindSource object to which this delegate component links.
        Use DataSource to determine or set the TBaseLinkingBindSource object that connects to a specific dataset."""
    FieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    FillBreakCustomFormat: str
    """str: Specifies a custom expression that is used with the field defined by the FillBreakFieldName property. For instance, the expression StrCopy(%s, 0, 1); causes a break when the first character of the field is different. This property is optional."""
    FillBreakFieldName: str
    """str: Specifies the field used to determine a break. This property is optional."""
    FillBreakGroups: FillBreakGroups
    """FillBreakGroups: Specifies a collection of break value ranges. The break value falls within an item in this collection. The display value associated with the item is displayed in the header. This property is optional."""
    FillExpressions: FormatExpressions
    """FormatExpressions: Specifies additional optional expressions to use when filling the list control. Use this collection when multiple expressions are needed to fill an item in the list.
        For instance, you can use FillExpressions in order to populate a FireMonkey list box item Text and Detail properties. Use the FillDisplayCustomFormat and FillDisplayCustomFormat properties in order to fill the Text property and add an item to the FillExpressions collection, for the Detail property."""
    FillHeaderCustomFormat: str
    """str: Specifies a custom expression that is used with the field defined by the FillHeaderFieldName property. For instance, the expression StrCopy(%s, 0, 1); displays the first character of the field in the header. This property is optional."""
    FillHeaderExpressions: FormatExpressions
    """FormatExpressions: Specifies a collection of expressions to fill a list header. This property is optional."""
    FillHeaderFieldName: str
    """str: Specifies the field to display in the list header. If FillBreakFieldName and FillBreakCustomFormat are blank, then the value determined using FillHeaderFieldName and FillBreakCustomFormat controls breaks. This is the only required field to cause breaking."""
    ListItemStyle: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    OnActivated: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnActivating: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnAssignedValue: Callable[[Object,BindingAssignValueRec,Value],None]
    """Callable[[Object, BindingAssignValueRec, Value], None]:"""
    OnAssigningValue: Callable[[Object,BindingAssignValueRec,Value,bool],None]
    """Callable[[Object, BindingAssignValueRec, Value, bool], None]:"""
    OnEvalError: Callable[[Object,Exception],None]
    """Callable[[Object, Exception], None]:"""
    OnFilledList: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFilledListItem: Callable[[Object,IBindListEditorItem],None]
    """Callable[[Object, IBindListEditorItem], None]:"""
    OnFillingList: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFillingListItem: Callable[[Object,IBindListEditorItem],None]
    """Callable[[Object, IBindListEditorItem], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkPropertyToField(CustomLinkPropertyToField):
    """Links the property of a component to a field.
    The TLinkPropertyToField class extends TCustomLinkPropertyToField with published properties.
    
    Tip: The user input to this component is not monitored using an observer."""
    __hash__: ClassVar[None] = ...
    AutoActivate: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Component: Component
    """Component: Specifies the component that this wrapping binding component references."""
    ComponentCount: Any
    """Returns the owned component count"""
    ComponentProperty: str
    """str: Specifies the name of the property of the component that this wrapping binding component references."""
    Components: Any
    """Returns an iterator over the owned components"""
    CustomFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TDataSource object to which this delegate component links.
        Use DataSource to determine or set the TDataSource object that connects to a specific dataset."""
    FieldName: str
    """str: Specifies the field name that this wrapping binding component references."""
    LookupDataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Embarcadero Technologies does not currently have any additional information."""
    LookupKeyFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    LookupValueFieldName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    OnActivated: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnActivating: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnAssignedValue: Callable[[Object,BindingAssignValueRec,Value],None]
    """Callable[[Object, BindingAssignValueRec, Value], None]:"""
    OnAssigningValue: Callable[[Object,BindingAssignValueRec,Value,bool],None]
    """Callable[[Object, BindingAssignValueRec, Value, bool], None]:"""
    OnEvalError: Callable[[Object,Exception],None]
    """Callable[[Object, Exception], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class LinkPropertyToFieldDelegate(BindComponentDelegate):
    """Is a binding component that wraps another binding component and references a component property, data source, and field name.
    The TLinkPropertyToFieldDelegate class implements a binding component that wraps another binding component and references a component property, a data source, and a field name.
    For more information regarding the delegates, please refer to the New LiveBinding topic, the Quick Binding Components Reference section."""
    __hash__: ClassVar[None] = ...
    Component: Component
    """Component: Specifies the component that this wrapping binding component references."""
    ComponentCount: Any
    """Returns the owned component count"""
    ComponentProperty: str
    """str: Specifies the name of the property of the component that this wrapping binding component references."""
    Components: Any
    """Returns an iterator over the owned components"""
    DataSource: BaseLinkingBindSource
    """BaseLinkingBindSource: Specifies a TDataSource object to which this delegate component links.
        Use DataSource to determine or set the TDataSource object that connects to a specific dataset."""
    FieldName: str
    """str: Specifies the field name that this wrapping binding component references."""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ListBox(CustomMultiSelectListControl):
    """TListBox displays a collection of items in a scrollable list.
    Use TListBox to display a scrollable list of items that users can select, add, or delete. TListBox is a wrapper for the Windows listbox control. For specialized list boxes, use other descendant classes of TCustomListBox or derive your own class from TCustomListBox.
    TListBox implements the generic behavior introduced in TCustomListBox. TListBox publishes many of the properties inherited from TCustomListBox, but does not introduce any new behavior."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoComplete: bool
    """bool:"""
    AutoCompleteDelay: int
    """int:"""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BevelWidth: int
    """int: Specifies the width of the inner and outer bevels.
        Use BevelWidth to specify the width, in pixels, of the inner and outer bevels."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: BorderStyle
    """BorderStyle:"""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Columns: int
    """int:"""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    ExtendedSelect: bool
    """bool:"""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    ImeMode: ImeMode
    """ImeMode: Determines the behavior of the input method editor (IME).
        Set ImeMode to configure the way an IME processes user keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application. 
        ImeMode allows a control to influence the type of conversion performed by the IME so that it is appropriate for the input expected by the control. For example, a control that only accepts numeric input might specify an ImeMode of imClose, as no conversion is necessary for numeric input.
        
        Note:  The value of ImeMode only takes effect when the control receives focus. To change the value of ImeMode when the control already has input focus, call the SetIme method."""
    ImeName: str
    """str: Specifies the input method editor (IME) to use for converting keyboard input to Asian language characters.
        Set ImeName to specify which IME to use for converting keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application.
        ImeName must specify one of the IMEs that has been installed through the Windows control panel. The property inspector provides a drop-down list of all currently installed IMEs on the system. At runtime, applications can obtain a list of currently installed IMEs from the global Screen variable.
        If ImeName specifies an unavailable IME, the IME that was active when the application started is used instead. No exception is generated.
        
        Note:  The value of ImeName only takes effect when the control receives focus. To change the value of ImeName after the control has input focus, call the SetIme method."""
    IntegralHeight: bool
    """bool:"""
    ItemHeight: int
    """int:"""
    ItemIndex: Any
    """Indicates the position of the selected item."""
    Items: Strings
    """Strings:"""
    MultiSelect: bool
    """bool:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnData: Callable[[WinControl,int,str],None]
    """Callable[[WinControl, int, str], None]:"""
    OnDataFind: Callable[[WinControl,str],int]
    """Callable[[WinControl, str], int]:"""
    OnDataObject: Callable[[WinControl,int,Object],None]
    """Callable[[WinControl, int, Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDrawItem: Callable[[WinControl,int,Rect,OwnerDrawState],None]
    """Callable[[WinControl, int, Rect, OwnerDrawState], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMeasureItem: Callable[[WinControl,int,int],None]
    """Callable[[WinControl, int, int], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ScrollWidth: int
    """int:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    Sorted: bool
    """bool:"""
    Style: ListBoxStyle
    """ListBoxStyle:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    TabWidth: int
    """int:"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ListItem(Persistent):
    """Wrapper for Delphi TListItem"""
    __hash__: ClassVar[None] = ...
    Caption: str
    """str:"""
    Checked: bool
    """bool:"""
    ClassName: Any
    """Returns the TObject.ClassName"""
    Cut: bool
    """bool:"""
    Data: Pointer
    """Pointer:"""
    Deleting: bool
    """bool:"""
    DropTarget: bool
    """bool:"""
    Focused: bool
    """bool:"""
    GroupID: int
    """int:"""
    Handle: int
    """int:"""
    ImageIndex: int
    """int:"""
    Indent: int
    """int:"""
    Index: int
    """int:"""
    Left: int
    """int:"""
    ListView: CustomListView
    """CustomListView:"""
    OverlayIndex: int
    """int:"""
    Owner: ListItems
    """ListItems:"""
    Position: Point
    """Point:"""
    Selected: bool
    """bool:"""
    StateIndex: int
    """int:"""
    SubItemImages: int
    """int:"""
    SubItems: Strings
    """Strings:"""
    Top: int
    """int:"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, persistent) -> Any:
        """TPersistent.Assign(persistent)
        Assigns to this object the values of another TPersistent object"""
    def CancelEdit(self, *args, **kwargs) -> Any: ...
    def Create(self, AOwner: ListItems) -> None:
        """TListItem.Create(AOwner: ListItems) -> None
        Constructs an object and initializes its data before the object is first used.
        Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
        Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.
        
        Note: If an exception escapes from a constructor, the object's destructor is called to clean up the failed instance."""
    def Delete(self, *args, **kwargs) -> Any: ...
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TPersistent instance and frees its memory.
        Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy."""
    def DisplayRect(self, Code: DisplayCode) -> Rect:
        """TListItem.DisplayRect(Code: DisplayCode) -> Rect"""
    def EditCaption(self, *args, **kwargs) -> Any: ...
    def GetNamePath(self) -> Any:
        """TPersistent.GetNamePath()
        Returns the name of the object as it appears in the Object Inspector."""
    def GetPosition(self, *args, **kwargs) -> Any: ...
    def MakeVisible(self, PartialOK: bool) -> None:
        """TListItem.MakeVisible(PartialOK: bool) -> None"""
    def SetPosition(self, Value: Point) -> None:
        """TListItem.SetPosition(Value: Point) -> None"""
    def Update(self, *args, **kwargs) -> Any: ...
    def WorkArea(self, *args, **kwargs) -> Any: ...
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ListView(CustomListView):
    """Wrapper for Delphi TListView"""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    AllocBy: int
    """int:"""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BevelWidth: int
    """int: Specifies the width of the inner and outer bevels.
        Use BevelWidth to specify the width, in pixels, of the inner and outer bevels."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: BorderStyle
    """BorderStyle:"""
    BorderWidth: int
    """int: Specifies the width of the control's border.
        Use BorderWidth to get or set the width of the control's border. Graphics or text drawn by the control is clipped to the area within the border."""
    Checkboxes: bool
    """bool:"""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    ColumnClick: bool
    """bool:"""
    Columns: ListColumns
    """ListColumns:"""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    FlatScrollBars: bool
    """bool:"""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    FullDrag: bool
    """bool:"""
    GridLines: bool
    """bool:"""
    GroupHeaderImages: CustomImageList
    """CustomImageList:"""
    GroupView: bool
    """bool:"""
    Groups: ListGroups
    """ListGroups:"""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HideSelection: bool
    """bool:"""
    HotTrack: bool
    """bool:"""
    HotTrackStyles: ListHotTrackStyles
    """ListHotTrackStyles:"""
    HoverTime: int
    """int:"""
    IconOptions: IconOptions
    """IconOptions:"""
    Items: ListItems
    """ListItems:"""
    LargeImages: CustomImageList
    """CustomImageList:"""
    MultiSelect: bool
    """bool:"""
    OnAdvancedCustomDraw: Callable[[CustomListView,Rect,CustomDrawStage,bool],None]
    """Callable[[CustomListView, Rect, CustomDrawStage, bool], None]:"""
    OnAdvancedCustomDrawItem: Callable[[CustomListView,ListItem,CustomDrawState,CustomDrawStage,bool],None]
    """Callable[[CustomListView, ListItem, CustomDrawState, CustomDrawStage, bool], None]:"""
    OnAdvancedCustomDrawSubItem: Callable[[CustomListView,ListItem,int,CustomDrawState,CustomDrawStage,bool],None]
    """Callable[[CustomListView, ListItem, int, CustomDrawState, CustomDrawStage, bool], None]:"""
    OnChange: Callable[[Object,ListItem,ItemChange],None]
    """Callable[[Object, ListItem, ItemChange], None]:"""
    OnChanging: Callable[[Object,ListItem,ItemChange,bool],None]
    """Callable[[Object, ListItem, ItemChange, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnColumnClick: Callable[[Object,ListColumn],None]
    """Callable[[Object, ListColumn], None]:"""
    OnColumnDragged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnColumnRightClick: Callable[[Object,ListColumn,Point],None]
    """Callable[[Object, ListColumn, Point], None]:"""
    OnCompare: Callable[[Object,ListItem,ListItem,int,int],None]
    """Callable[[Object, ListItem, ListItem, int, int], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnCreateItemClass: Callable[[CustomListView,ListItemClass],None]
    """Callable[[CustomListView, ListItemClass], None]:"""
    OnCustomDraw: Callable[[CustomListView,Rect,bool],None]
    """Callable[[CustomListView, Rect, bool], None]:"""
    OnCustomDrawItem: Callable[[CustomListView,ListItem,CustomDrawState,bool],None]
    """Callable[[CustomListView, ListItem, CustomDrawState, bool], None]:"""
    OnCustomDrawSubItem: Callable[[CustomListView,ListItem,int,CustomDrawState,bool],None]
    """Callable[[CustomListView, ListItem, int, CustomDrawState, bool], None]:"""
    OnData: Callable[[Object,ListItem],None]
    """Callable[[Object, ListItem], None]:"""
    OnDataFind: Callable[[Object,ItemFind,str,Point,Pointer,int,SearchDirection,bool,int],None]
    """Callable[[Object, ItemFind, str, Point, Pointer, int, SearchDirection, bool, int], None]:"""
    OnDataHint: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnDataStateChange: Callable[[Object,int,int,ItemStates,ItemStates],None]
    """Callable[[Object, int, int, ItemStates, ItemStates], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDeletion: Callable[[Object,ListItem],None]
    """Callable[[Object, ListItem], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDrawItem: Callable[[CustomListView,ListItem,Rect,OwnerDrawState],None]
    """Callable[[CustomListView, ListItem, Rect, OwnerDrawState], None]:"""
    OnEdited: Callable[[Object,ListItem,str],None]
    """Callable[[Object, ListItem, str], None]:"""
    OnEditing: Callable[[Object,ListItem,bool],None]
    """Callable[[Object, ListItem, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetImageIndex: Callable[[Object,ListItem],None]
    """Callable[[Object, ListItem], None]:"""
    OnGetSubItemImage: Callable[[Object,ListItem,int,int],None]
    """Callable[[Object, ListItem, int, int], None]:"""
    OnInfoTip: Callable[[Object,ListItem,str],None]
    """Callable[[Object, ListItem, str], None]:"""
    OnInsert: Callable[[Object,ListItem],None]
    """Callable[[Object, ListItem], None]:"""
    OnItemChecked: Callable[[Object,ListItem],None]
    """Callable[[Object, ListItem], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnSelectItem: Callable[[Object,ListItem,bool],None]
    """Callable[[Object, ListItem, bool], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OwnerData: bool
    """bool:"""
    OwnerDraw: bool
    """bool:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ReadOnly: bool
    """bool:"""
    RowSelect: bool
    """bool:"""
    ShowColumnHeaders: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    ShowWorkAreas: bool
    """bool:"""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    SmallImages: CustomImageList
    """CustomImageList:"""
    SortType: SortType
    """SortType:"""
    StateImages: CustomImageList
    """CustomImageList:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    ViewStyle: ViewStyle
    """ViewStyle:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MainMenu(Menu):
    """TMainMenu encapsulates a menu bar and its accompanying drop-down menus for a form.
    Use TMainMenu to provide the main menu for a form. To begin designing a menu, add a main menu to a form, and double-click the component. 
    TMainMenu introduces properties and methods for merging the drop-down menus of the main menu with the main menu of another form.
    TMainMenu introduces properties and methods for assisting in the menu negotiation process of an OLE container.
    
    Tip:  To create a menu that users can configure at runtime, use the TActionMainMenuBar component with an action manager instead."""
    __hash__: ClassVar[None] = ...
    AutoHotkeys: MenuAutoFlag
    """MenuAutoFlag: Determines whether the accelerator keys for menu items can be reset automatically.
        Set AutoHotkeys to indicate whether the menu should automatically ensure that accelerator keys for its items are reset if necessary so that every menu item has an accelerator key and no two items have the same accelerator key. This ensures that menu items added dynamically at runtime can have accelerator keys that do not introduce conflicts. TMenu tries to preserve all existing accelerator key mappings when adjusting the accelerator keys, but may be forced to change some in order to ensure that every item has a unique accelerator.
        Before the menu is displayed, the menu checks and adjusts the accelerator key mappings if AutoHotkeys is maAutomatic. When AutoHotkeys is maManual, the menu does not alter the top-level menu items, but may adjust the accelerator keys for submenus, depending on the AutoHotkeys property of the menu item that is the parent of the submenu.
        When AutoHotkeys is maManual, an application can still adjust the menu items by calling the Items property's RethinkHotkeys method. AutoHotkeys merely controls whether this adjustment occurs automatically.
        
        Note:  The AutoHotkeys property of a menu is linked to the AutoHotkeys property of the TMenuItems object that implements its Items property. Setting one sets the other."""
    AutoLineReduction: MenuAutoFlag
    """MenuAutoFlag: Determines whether redundant separator bars are automatically removed from the menu.
        Set AutoLineReduction to indicate whether the menu should automatically ensure that the menu does not start or end with a separator bar and that two separator bars do not appear next to each other. This ensures that menus built dynamically at runtime do not have separator bars in undesired positions.
        Before the menu is displayed, it removes superfluous separator bars when AutoLineReduction is maAutomatic. When AutoLineReduction is maManual, the menu does not remove separators from the top-level menu items, but may remove superfluous separators from submenus, depending on the AutoLineReduction property of the menu item that is the parent of the submenu.
        When AutoLineReduction is maManual, an application can still remove superfluous separators by calling the Items property's RethinkLines method. AutoLineReduction merely determines whether this adjustment occurs automatically.
        
        Note:  The AutoLineReduction property of a menu is linked to the AutoLineReduction property of the TMenuItems object that implements its Items property. Setting one sets the other."""
    AutoMerge: bool
    """bool: Determines if the main menus of secondary forms merge with the main menu of the main form in non-MDI applications at runtime.
        To merge a form's menus with the main menu in the main form, set the AutoMerge property of each main menu you want merged to true. Make sure that the AutoMerge property of the main menu of the main form (the one other menus are merged into) remains false. How menus merge depends on the value of the GroupIndex property for each menu item.
        If the application is an MDI application (the FormStyle properties are set so the main form is a parent form and subsequent forms are child forms), menu merging occurs automatically without using the AutoMerge property."""
    BiDiMode: BiDiMode
    """BiDiMode: Determines the layout of the menu in Middle East locales.
        Set BiDiMode to control the layout of menu items. BiDiMode controls whether the menu items read from left to right or right to left."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Images: CustomImageList
    """CustomImageList: Lists the images that can appear beside individual menu items.
        Use Images to hold the set of images that can appear beside menu items in the menu. Individual menu items set their ImageIndex property to indicate which image in the list appears to the left of the menu item caption.
        Images in the list should be 16x16.
        
        Tip:  If the application uses action lists, this property should be the value of the action list's Images property. This way, menu items and buttons that do the same thing can display the same image."""
    OnChange: Callable[[Object,MenuItem,bool],None]
    """Callable[[Object, MenuItem, bool], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    OwnerDraw: bool
    """bool: Specifies whether the menu items are drawn by the application.
        Set OwnerDraw to true to indicate that the application will draw menu items in an OnDrawItem event handler. When OwnerDraw is true, menu items receive an OnMeasureItem and an OnDrawItem event when they need to be rendered on screen.
        Set OwnerDraw to false to accept the default drawing. When OwnerDraw is false, menu items display the caption with an optional image to the left (If the Images and ImageIndex properties are set).
        Owner-draw menus are useful for displaying the value that appears when selecting a menu item. For example, in a menu that allows users to choose a color, an owner-draw menu could display rectangles drawn in the designated color, rather than color names."""
    ParentBiDiMode: bool
    """bool: Indicates whether the BiDiMode property is inherited from the control that uses the menu.
        By default, ParentBiDiMode is true, indicating that the layout of menu items follows the BiDiMode setting of the associated form or control. Change ParentBiDiMode to false to override the default BiDiMode setting and control the menu's layout independently."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetOle2AcceleratorTable(self, AccelTable: int, AccelCount: int, Groups: int) -> None:
        """TMainMenu.GetOle2AcceleratorTable(AccelTable: int, AccelCount: int, Groups: int) -> None
        Returns the main menu's accelerator table.
        Call GetOle2AcceleratorTable to obtain a handle to an accelerator table for all menu items with a GroupIndex value that appears in the Groups parameter. The AccelTable parameter is set to the accelerator table handle, and the AccelCount is set to the number of entries in the table. GetOle2AcceleratorTable is used by OLE containers when merging menus."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def Merge(self, Menu: MainMenu) -> None:
        """TMainMenu.Merge(Menu: MainMenu) -> None
        Combines the main menu of one form with the main menu of another in non-MDI applications.
        Call Merge to merge another main menu with this one. Specify the menu you want merged with this menu as the Menu parameter.
        For example, to use the main menu of the first form in an application as the main menu for the application, call Merge to merge the main menu of any additional forms in the application with the main menu of the first form. 
        Depending on the value of the GroupIndex property of menu items on the main menu, the merged menu items can replace menu items on the menu bar, or insert menu items into the menu bar. See GroupIndex for information on how to do these things.
        To merge and unmerge main menus automatically when other forms are displayed, change the value of the AutoMerge property to true on all forms whose menus should be merged in."""
    def PopulateOle2Menu(self, SharedMenu: int, Groups: int, Widths: int) -> None:
        """TMainMenu.PopulateOle2Menu(SharedMenu: int, Groups: int, Widths: int) -> None
        Populates an OLE menu with items from the main menu.
        Call PopulateOle2Menu to merge the menu items with GroupIndex values specified by the Groups parameter into the menu that uses the SharedMenu handle. PopulateOle2Menu appends all menu items in the specified groups to the menu, and increments the corresponding entries in the Widths array for every menu item appended. PopulateOle2Menu is used by OLE containers when merging menus.
        
        Note: PopulateOle2Menu populates the menu specified by the SharedMenu parameter but does not set this as the OLE menu associated with the menu."""
    def SetOle2MenuHandle(self, Handle: int) -> None:
        """TMainMenu.SetOle2MenuHandle(Handle: int) -> None
        Associates the handle for an OLE menu with the main menu.
        Call SetOle2MenuHandle to temporarily replace the menu of a form with the menu represented by the Handle parameter. To restore the original menu, call SetOle2MenuHandle with the Handle parameter set to 0. SetOle2MenuHandle allows an OLE container to use menu items provided by an OLE server."""
    def Unmerge(self, Menu: MainMenu) -> None:
        """TMainMenu.Unmerge(Menu: MainMenu) -> None
        Reverses the merging of two menus in a non-MDI application.
        Call Unmerge to remove items from another main menu that were added using the Merge method. The Menu parameter is the merged menu whose items should be removed from the main menu."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MediaPlayer(CustomControl):
    """TMediaPlayer controls devices that provide a Media Control Interface (MCI) driver.
    The TMediaPlayer component includes a set of buttons (Play, Stop, Eject, and so on) that control a multimedia device such as a CD-ROM drive, MIDI sequencer, or VCR. A multimedia device may be hardware or software.
    The media player component contains of multiple buttons. These buttons can be clicked with the mouse, but are not separate objects or button components.
    
    
    
    
    
    Button
    
    Value
    
    Action
    
    
    
    Play
    
    
    
    btPlay
    
    
    
    Plays the media player
    
    
    
    
    Pause
    
    
    
    btPause
    
    
    
    Pauses playing or recording. If already paused when clicked, resumes playing or recording.
    
    
    
    
    Stop
    
    
    
    btStop
    
    
    
    Stops playing or recording
    
    
    
    
    Next
    
    
    
    btNext
    
    
    
    Skips to the next track, or to the end if the medium doesn't use tracks
    
    
    
    
    Prev
    
    
    
    btPrev
    
    
    
    Skips to the previous track, or to the beginning if the medium doesn't use tracks
    
    
    
    
    Step
    
    
    
    btStep
    
    
    
    Moves forward a number of frames
    
    
    
    
    Back
    
    
    
    btBack
    
    
    
    Moves backward a number of frames
    
    
    
    
    Record
    
    
    
    btRecord
    
    
    
    Starts recording
    
    
    
    
    Eject
    
    
    
    btEject
    
    
    
    Ejects the medium
    
    
    
    
    The multimedia device is played, paused, stopped, and so on when the user clicks the corresponding button on the TMediaPlayer component. The device can also be controlled by the control methods that correspond to the buttons (Play, Pause, Stop, Next, Previous, Step, Back, StartRecording, and Eject).
    The type of multimedia device (such as dtWaveAudio or dtVideodisc) is specified by the DeviceType property. If the device stores its media in a file, the name of the media file is specified by the FileName property. If DeviceType is dtAutoSelect, the media player attempts to determine the type of device from the extension of the file specified by FileName.
    To have the media player attempt to open the device specified by DeviceType automatically when the media player component is created at runtime, set the AutoOpen property to true."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoEnable: bool
    """bool: Determines whether the media player automatically enables and disables individual buttons in the component.
        Use AutoEnable to automatically enable or disable the control buttons on the media player. If AutoEnable is true, the media player automatically enables or disables its control buttons. The media player determines which buttons to enable or disable by the current mode specified in the Mode property, and the current multimedia device type specified in the DeviceType property.
        AutoEnable overrides the EnabledButtons property. The buttons enabled or disabled automatically by the media player supersede any buttons enabled or disabled with EnabledButtons.
        If AutoEnable is false, the media player does not enable or disable buttons. The buttons must enabled or disabled with the EnabledButtons property.
        The following table shows whether buttons are automatically enabled or disabled for each device mode:
        
        
        
        
        
        Button
        
        Play
        
        Record
        
        Pause
        
        Stop
        
        Not Open
        
        
        
        Back
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Disabled
        
        
        
        
        Eject
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Disabled
        
        
        
        
        Next
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Disabled
        
        
        
        
        Pause
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Disabled
        
        
        
        Disabled
        
        
        
        
        Play
        
        
        
        Disabled
        
        
        
        Disabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Disabled
        
        
        
        
        Prev
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Disabled
        
        
        
        
        Record
        
        
        
        Disabled
        
        
        
        Disabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Disabled
        
        
        
        
        Step
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Disabled
        
        
        
        
        Stop
        
        
        
        Enabled
        
        
        
        Enabled
        
        
        
        Disabled
        
        
        
        Disabled
        
        
        
        Disabled"""
    AutoOpen: bool
    """bool: Determines if the media player is opened automatically when the application is run.
        Use AutoOpen to have the media player automatically open at runtime.
        If AutoOpen is true, the media player attempts to open the multimedia device specified by the DeviceType property (or FileName if DeviceType is dtAutoSelect) when the form containing the media player component is created at runtime. 
        If AutoOpen is false, the device must be opened with a call to the Open method.
        If an error occurs when opening the device, an exception of type EMCIDeviceError exception is raised that contains the error message. Upon completion, a numerical error code is stored in the Error property, and the corresponding error message is stored in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before opening the multimedia device. The Notify property determines whether opening the device generates an OnNotify event."""
    AutoRewind: bool
    """bool: Determines if the media player control rewinds before playing or recording.
        If AutoRewind is true and the current position is at the end of the medium, Play or StartRecording moves the current position to the beginning of the medium before playing or recording. If AutoRewind is false, the user must click the Prev button or write code to call Previous to move to the beginning.
        If values have been assigned to StartPos or EndPos or if the multimedia device uses tracks, AutoRewind has no effect on playing or recording. When calling Play or StartRecording, the current position remains at the end of the medium."""
    Capabilities: MPDevCapsSet
    """MPDevCapsSet: Determines the capabilities of the open multimedia device.
        The various capabilities specified in Capabilities are determined when the device is opened with the Open method.
        
        Note:  Currently, there is no way to check whether a device can step forward or backward. Capabilities includes mpCanStep only if the device type (specified in the DeviceType property) is Animation, AVI Video, Digital Video, Overlay, or VCR."""
    ColoredButtons: ButtonSet
    """ButtonSet: Determines which buttons on the media player control have color.
        ColoredButtons controls which buttons on the media player are colored.
        If a button is not colored with ColoredButtons, it appears in black-and-white when visible. All media player control buttons are colored by default."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    DeviceID: int
    """int: Specifies the device ID for the currently open multimedia device.
        The value of DeviceID is determined when a device is opened with the Open method. If no device is open, DeviceID is 0."""
    DeviceType: MPDeviceTypes
    """MPDeviceTypes: Specifies a multimedia device type to open with the media player.
        DeviceType specifies a multimedia device type to open with the Open method. The default is dtAutoSelect.
        If DeviceType is dtAutoSelect, the device type is determined by the file extension specified in the FileName property. If no device type is associated with the extension, the correct device type must be explicitly specified by setting DeviceType to a value other than dtAutoSelect.
        A multimedia device is typically associated with an appropriate file name extension when the device is installed. Associations are specified in the registry or SYSTEM.INI file. See the documentation for the specific device for instructions about how to associate file name extensions with the device."""
    Display: WinControl
    """WinControl: Specifies the display window for a multimedia device that uses a window for output.
        To use Display, assign the name of a windowed control such as a form or panel to Display to display output in that control.
        The default value of Display is nil (Delphi) or NULL (C++), meaning that the device creates its own window to display output. Also, by freeing the control assigned to Display after the device has been opened, video output will be in its own default window.
        Examples of multimedia devices that use a window to display output are Animation, AVI Video, Digital Video, Overlay, and VCR."""
    DisplayRect: Rect
    """Rect: Specifies a rectangular area in the control specified by the Display property that is used to display output from a multimedia device.
        To display output in a specific rectangle area on a form assign a TRect record to DisplayRect. The Rect function can be used to create a TRect record.
        Media that use a rectangle to display output usually perform best if the default DisplayRect size is used. To set DisplayRect to the default size, position the rectangle in the upper left corner and use 0, 0 for the lower right corner.
        DisplayRect is ignored if Display is nil (Delphi) or NULL (C++).
        Examples of multimedia devices that use a window to display output are Animation, AVI Video, Digital Video, Overlay, and VCR.
        
        Note: DisplayRect can be set only after the media device is opened."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    EnabledButtons: ButtonSet
    """ButtonSet: Determines which buttons on the media player are usable.
        EnabledButtons controls which buttons on the media player are enabled and usable.
        An enabled button is colored and usable. A disabled button is dimmed and not usable. If a button is not enabled with EnabledButtons, it is disabled. By default, all buttons are enabled.
        If the AutoEnable property is true, AutoEnable supersedes EnabledButtons. The buttons automatically enabled or disabled by the media player override any buttons enabled or disabled with the EnabledButtons property."""
    EndPos: int
    """int: Specifies the position within the currently loaded medium at which to stop playing or recording.
        EndPos is specified using the current time format, which is specified in the TimeFormat property.
        The EndPos property affects only the next Play or StartRecording method called after setting EndPos. Reset EndPos to affect any subsequent calls to Play or StartRecording."""
    Error: int
    """int: Specifies the MCI error code returned by the media control method.
        Error specifies the MCI error code returned by the most recent media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop). The ErrorMessage property describes the Error.
        The error code returned by media control methods are the same error code returned by the mciSendCommand function. The message describing the error code is stored in the ErrorMessage property.
        The value of Error is zero if the most recent media control method didn't cause an error. If a method results in an error, a value other than zero is stored in Error. If the error occurs during the opening of the device, an EMCIDeviceError exception occurs."""
    ErrorMessage: str
    """str: Describes the error code stored in the Error property.
        ErrorMessage specifies the error message that describes the error code returned from the most recent media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop). 
        The error code described by the message is stored in the Error property."""
    FileName: str
    """str: Specifies the opened or saved media file.
        FileName specifies the media file to be opened by the Open method, or the file to save by the Save method.
        At design time, use a file open dialog box to specify the FileName property by clicking the ellipsis button (...) in the Object Inspector."""
    Frames: int
    """int: Specifies the number of frames moved forward or backward.
        Frames specifies the number of frames the Step method steps forward or the Back method steps backward. Frames defaults to ten percent of the length of the currently loaded medium, which is specified by the Length property.
        The definition of a frame varies by multimedia device. For display media, a frame is one still image."""
    Length: int
    """int: Specifies the length of the medium in the open multimedia device.
        Length is specified using the current time format, which is specified by the TimeFormat property."""
    Mode: MPModes
    """MPModes: Indicates the state of the currently open multimedia device.
        Mode specifies the current state or mode of the currently open multimedia device.
        The TMPModes type defines the modes for a multimedia device used with a TMediaPlayer."""
    Notify: bool
    """bool: Determines whether an OnNotify event is generated.
        Notify determines whether the next call to a media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop) generates an OnNotify event when the method has completed.
        If Notify is true, the next media control method generates OnNotify event upon completion and stores the notification message in the NotifyValue property. If Notify is false, the method does not generate an OnNotify event and NotifyValue remains unchanged.
        Notify affects only the next call to a media control method. After an OnNotify event, Notify must be reset to affect any subsequent media control methods.
        By default, Play and StartRecording function as if Notify is true. Set Notify to false before calling Play or StartRecording to prevent an OnNotify event from being generated when playing or recording has finished. By default, all other media control methods function as if Notify is false.
        
        Tip:  Set Notify to true if the next media control is expected to take a long time, so the application is notified when the media control method has completed. If Notify is set to true, it is recommended to set Wait to false so that control returns to the application before the media control method is finished.
        Note:  When trying to resume a device that doesn't support Resume, the device is resumed as if the Play method was called. If Notify was assigned true before calling Resume (or any other media control method), Notify doesn't affect the call to Resume. Resume does not generate an OnNotify event upon completion, and NotifyValue remains unchanged."""
    NotifyValue: MPNotifyValues
    """MPNotifyValues: Indicates the result of the last media control method that requested a notification.
        NotifyValue reports the result of the last media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop) that requested a notification.
        To request notification, set Notify to true before calling a media control method."""
    OnClick: Callable[[Object,MPBtnType,bool],None]
    """Callable[[Object, MPBtnType, bool], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnNotify: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnPostClick: Callable[[Object,MPBtnType],None]
    """Callable[[Object, MPBtnType], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    Position: int
    """int: Specifies the current position within the currently loaded medium.
        The value of Position is specified according to the current time format, which is specified in the TimeFormat property.
        Position defaults to the beginning of the medium. If the medium supports multiple tracks, Position defaults to the beginning of the first track."""
    Shareable: bool
    """bool: Determines whether more than one application can share a multimedia device.
        If Shareable is false, no other components or applications can access the device. If Shareable is true, more than one component or application can access the device. Shareable defaults to false.
        Be sure to set Shareable before opening a device.
        Some devices are not shareable. If Shareable is set to true for a device that isn't shareable, the Open method fails and the error code is returned to the Error property."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Start: int
    """int: Specifies the starting position within the currently loaded medium.
        Start is the beginning of the medium for devices that don't use tracks, or the beginning of the first track for devices that use tracks. Start is defined when a multimedia device is opened with the Open method. Start is specified according to the current time format, which is stored in the TimeFormat property. Start is read-only at runtime and is unavailable at design time."""
    StartPos: int
    """int: Specifies the position within the currently loaded medium from which to begin playing or recording.
        StartPos is specified using the current time format, which is specified in the TimeFormat property.
        The StartPos property affects only the next Play or StartRecording method called after setting StartPos. Reset must be set to StartPos to affect any subsequent calls to Play or StartRecording.
        StartPos does not affect the current position of the medium (specified in the Position property) until the next Play or StartRecording method is called."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    TimeFormat: MPTimeFormats
    """MPTimeFormats: Determines the format used to specify position information.
        TimeFormat determines how the StartPos, Length, Position, Start, and EndPos properties are interpreted. For example, if Position is 180 and TimeFormat is tfMilliseconds, the current position is 180 milliseconds into the medium. If Position is 180 and TimeFormat is tfMSF, the current position is 180 minutes into the medium.
        Not all formats are supported by every device. When trying to set an unsupported format, the assignment is ignored.
        The current timing information is always passed in a 4-byte integer. In some formats, the timing information returned is not really one integer, but single bytes of information packed in the long integer."""
    TrackLength: int
    """int:"""
    TrackPosition: int
    """int:"""
    Tracks: int
    """int: Specifies the number of playable tracks on the open multimedia device.
        Tracks indicates how many of playable tracks are available on the open multimedia device.
        Tracks is undefined for devices that don't use tracks."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    VisibleButtons: ButtonSet
    """ButtonSet: Indicates which of the buttons on the media player are visible.
        VisibleButtons determines which buttons on the media player that are visible. If a button is not made visible with VisibleButtons, it does not appear on the media player control. By default, all buttons are visible when a media player component is added to a form."""
    Wait: bool
    """bool: Determines whether a media control method returns control to the application only after it has been completed.
        Wait determines whether a media control method (Back, Close, Eject, Next, Open, Pause, PauseOnly, Play, Previous, StartRecording, Resume, Rewind, Step, or Stop) returns control to the application only after it has been completed.
        Wait is unavailable at design time.
        If Wait is true, the media player component waits until the next media control method has completed before returning control to the application. If Wait is false, the application won't wait for the next media control method to finish before continuing.
        Wait affects only the next media control method called after setting Wait. Wait must be reset to affect any subsequent call to a media control method.
        By default, Play and StartRecording function as if Wait is false. Wait must be set to true before calling Play or StartRecording to prevent control from returning to the application before playing or recording has finished. By default, all other media control methods function as if Wait is true.
        
        Note: Wait is usually set to false only if the next media control is expected to take a long time, so that the application can execute other code before the media control method has completed. If Wait is set to false, you should set Notify to true so the application is notified when the media control method completes."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Back(self, *args, **kwargs) -> Any:
        """Steps backward a number of frames (determined by the value of the Frames property) in the currently loaded medium.
        Back is called when the Back button on the media player control is clicked at runtime.
        Upon completion, Back stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Back method has been completed. The Notify property determines whether Back generates an OnNotify event."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Close(self, *args, **kwargs) -> Any:
        """Closes the open multimedia device.
        Upon completion, Close stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Close method is completed. The Notify property determines whether Close generates an OnNotify event.
        Close is called automatically when the application is terminated."""
    def Create(self, AOwner: Component) -> None:
        """TMediaPlayer.Create(AOwner: Component) -> None
        Creates a media player object.
        Call Create to instantiate a media player at runtime. For media players created at design time, Create is called automatically.
        Create allocates memory for a media player and calls the inherited Create. Then it loads the bitmaps for the media player's buttons and initializes its properties, setting AutoEnable, AutoRewind, Colored, Enabled, and Visible to true, AutoOpen to false, and DeviceType to dtAutoSelect."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of the media player.
        Do not call Destroy directly in an application. Call Free instead. Free checks that the TMediaPlayer reference is not nil before it calls Destroy.
        Destroy first verifies that no device is open, then destroys the bitmaps used for the media player's buttons and calls the inherited Destroy."""
    def Eject(self, *args, **kwargs) -> Any:
        """Releases the loaded medium from the open multimedia device.
        Eject is called when the Eject button on the media player control is clicked at runtime. It ejects the loaded medium from the open multimedia device.
        Upon completion, Eject stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Eject method has been completed. The Notify property determines whether Eject generates an OnNotify event."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Next(self, *args, **kwargs) -> Any:
        """Moves to the beginning of the next track of the currently loaded medium.
        If the current position is at the last track when Next is called, Next makes the current position the beginning of the last track. If the multimedia device doesn't use tracks, Next goes to the end of the medium. Next is called when the Next button on the media player control is clicked at runtime.
        Upon completion, Next stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Next method has completed. The Notify property determines whether Next generates an OnNotify event."""
    def Open(self, *args, **kwargs) -> Any:
        """Opens a multimedia device.
        Use Open to open a multimedia device. The multimedia device type must be specified in the DeviceType property before a device can be opened.
        Upon completion, Open stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Open method is completed. The Notify property determines whether Open generates an OnNotify event."""
    def Pause(self, *args, **kwargs) -> Any:
        """Toggles the open multimedia device on or off.
        If the device is already paused when Pause is called, the device resumes playing or recording by calling the Resume method. Pause is called when the Pause button on the media player control is clicked at runtime.
        Upon completion, Pause stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Pause method has completed. The Notify property determines whether Pause generates an OnNotify event."""
    def PauseOnly(self, *args, **kwargs) -> Any:
        """Pauses the open multimedia device.
        If the device is already paused when PauseOnly is called, the device will remain paused.
        Upon completion, PauseOnly stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the PauseOnly method has completed. The Notify property determines whether PauseOnly generates an OnNotify event."""
    def Play(self, *args, **kwargs) -> Any:
        """Plays the media loaded in the open multimedia device.
        Play is called when the Play button on the media player control is clicked at runtime.
        Upon completion, Play stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Play method has completed. The Notify property determines whether Play generates an OnNotify event.
        If the StartPos property is set, playing starts at the position specified in StartPos. Otherwise, playing starts at the current position, specified in the Position property. Similarly, if the EndPos property is set, playing stops at the position specified in EndPos. Otherwise, playing stops at the end of the medium.
        Whether the medium (specified in the Position property) is rewound before playing starts depends on the AutoRewind property."""
    def Previous(self, *args, **kwargs) -> Any:
        """Sets the current position to the beginning of the previous track if the position was at the beginning of a track when Previous was called.
        If the position is at the first track or somewhere other than the beginning of a track when Previous was called, Previous sets the current position to the beginning of the current track. If the device doesn't use tracks, Previous sets the current position to the beginning of the medium, which is specified in the Start property. Previous is called when the Previous button on the media player control is clicked at runtime.
        Upon completion, Previous stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Previous method has completed. The Notify property determines whether Previous generates an OnNotify event."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def Resume(self, *args, **kwargs) -> Any:
        """Resumes playing or recording the currently paused multimedia device.
        Resume is called when the Pause button on the media player control is clicked at runtime, when the device is paused.
        Upon completion, Resume stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Resume method has completed. The Notify property determines whether Resume generates an OnNotify event."""
    def Rewind(self, *args, **kwargs) -> Any:
        """Sets the current position to the beginning of the the medium, which is stored in the Start property.
        Upon completion, Rewind stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Rewind method has completed. The Notify property determines whether Rewind generates an OnNotify event."""
    def Save(self, *args, **kwargs) -> Any:
        """Saves the currently loaded medium to the file specified in the FileName property.
        Save is ignored for devices that don't use media stored in files (videodiscs, for example).
        Upon completion, Save stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Save method has completed. The Notify property determines whether Save generates an OnNotify event."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def StartRecording(self, *args, **kwargs) -> Any:
        """Begins recording from the current Position or from the position specified in StartPos.
        StartRecording is called when the Record button on the media player control is clicked at runtime.
        Upon completion, StartRecording stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the StartRecording method has completed. The Notify property determines whether StartRecording generates an OnNotify event.
        By default, the Notify property becomes true, and the Wait property becomes false upon completion of the StartRecording method. However, if these properties have been set to specific values prior to calling StartRecording, they remain unchanged."""
    def Step(self, *args, **kwargs) -> Any:
        """Moves forward a number of frames (determined by the Frames property) in the currently loaded medium.
        Step is called when the Step button on the media player control is clicked at runtime.
        Upon completion, Step stores a numerical error code in the Error property and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Step method has completed. The Notify property determines whether Step generates an OnNotify event."""
    def Stop(self, *args, **kwargs) -> Any:
        """Halts playing or recording.
        Stop is called when the Stop button on the media player control is clicked at runtime.
        Upon completion, Stop stores a numerical error code in the Error property, and the corresponding error message in the ErrorMessage property.
        The Wait property determines whether control is returned to the application before the Stop method has completed. The Notify property determines whether Stop generates an OnNotify event."""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Memo(CustomMemo):
    """TMemo is a wrapper for a Windows multiline edit control.
    Use TMemo to put a standard Windows multiline edit control on a form. Multiline edit boxes allow the user to enter more than one line of text. They are appropriate for representing lengthy information.
    TMemo implements the generic behavior introduced in TCustomMemo. TMemo publishes many of the properties inherited from TCustomMemo, but does not introduce any new behavior."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: Alignment
    """Alignment: Determines how the text is aligned within the text edit control.
        Use Alignment to change the way the text is formatted in the text edit control. Alignment can take one of the following values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        taLeftJustify
        
        
        
        Align text to the left side of the control
        
        
        
        
        taCenter
        
        
        
        Center text horizontally in the control.
        
        
        
        
        taRightJustify
        
        
        
        Align text to the right side of the control."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: BorderStyle
    """BorderStyle: Determines whether the edit control has a single line border around the client area.
        Use BorderStyle to affect the sharpness with which the client area of the edit control stands out. BorderStyle can have a value of either bsSingle or bsNone. If BorderStyle is bsSingle, the edit control has a single-line border around the client area. If BorderStyle is bsNone, there will be no border."""
    CanUndoSelText: bool
    """bool: When set to True, it allows you to call or invoke an Undo operation in order to undo a change previously made by using SetSelText or SetSelTextBuf. By default it is set to false."""
    CharCase: EditCharCase
    """EditCharCase: Determines the case of the text within the edit control.
        Use CharCase to force the contents of the edit control to assume a particular case.
        When CharCase is set to ecLowerCase or ecUpperCase, the case of characters is converted as the user types them into the edit control. Changing the CharCase property to ecLowerCase or ecUpperCase changes the actual contents of the text, not just the appearance. Any case information is lost and can't be recaptured by changing CharCase to ecNormal."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    EditMargins: EditMargins
    """EditMargins: Embarcadero Technologies does not currently have any additional information."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HideSelection: bool
    """bool: Determines whether the visual indication of the selected text remains when focus shifts to another control.
        Set HideSelection to false to provide visual feedback of the selected portion of the text even when the edit control does not have focus. Set HideSelection to true to show the selection only when the edit control has focus. HideSelection does not affect the actual value of the selection, only the visual indication. Always setting HideSelection to false can make forms with many edit controls look too busy."""
    ImeMode: ImeMode
    """ImeMode: Determines the behavior of the input method editor (IME).
        Set ImeMode to configure the way an IME processes user keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application. 
        ImeMode allows a control to influence the type of conversion performed by the IME so that it is appropriate for the input expected by the control. For example, a control that only accepts numeric input might specify an ImeMode of imClose, as no conversion is necessary for numeric input.
        
        Note:  The value of ImeMode only takes effect when the control receives focus. To change the value of ImeMode when the control already has input focus, call the SetIme method."""
    ImeName: str
    """str: Specifies the input method editor (IME) to use for converting keyboard input to Asian language characters.
        Set ImeName to specify which IME to use for converting keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application.
        ImeName must specify one of the IMEs that has been installed through the Windows control panel. The property inspector provides a drop-down list of all currently installed IMEs on the system. At runtime, applications can obtain a list of currently installed IMEs from the global Screen variable.
        If ImeName specifies an unavailable IME, the IME that was active when the application started is used instead. No exception is generated.
        
        Note:  The value of ImeName only takes effect when the control receives focus. To change the value of ImeName after the control has input focus, call the SetIme method."""
    Lines: Strings
    """Strings: Contains the individual lines of text in the memo control.
        Use Lines to manipulate text in an memo control on a line-by-line basis. Lines is a TStrings object, so the TStrings methods may be used for Lines to perform manipulations such as counting the lines of text, adding new lines, deleting lines, or replacing lines with new text. For example:
        
        MyMemo.Lines.Add(...);
        
        To work with all the text at once, use the Text property. To manipulate individual lines of text, the Lines property works better.
        
        Note:  Although Lines is implemented as a TStrings descendant, it does not implement the support for associating objects with the strings in the list."""
    MaxLength: int
    """int: Specifies the maximum number of characters the user can enter into the edit control.
        Use MaxLength to limit the number of characters that can be entered into the edit control. A value of 0 indicates that there is no application-defined limit on the length.
        Use MaxLength to limit the length of the text in an edit control if that text will be copied into a fixed-length buffer.
        
        Note:  Setting MaxLength will not truncate the existing text, it merely prevents the user from adding more text after reaching the limit of MaxLength characters.
        Note:  Even when MaxLength is 0, there may be limitations imposed by the operating system on the number of characters that may be entered into an edit control.
        Note:  The unit of MaxLength is characters (not bytes) if the application is using themes."""
    OEMConvert: bool
    """bool: Determines whether characters typed in the edit control are converted from ANSI to OEM and then back to ANSI.
        To ensure that any characters typed in the edit control can be unambiguously converted to the OEM character set, set OEMConvert to true. This causes all characters to be converted from ANSI to OEM and then back to ANSI as they are typed. Set OEMConvert to false to avoid the overhead of this conversion when it does not matter whether the text can be unambiguously mapped to an OEM string.
        OEMConvert is most useful for edit controls used to enter file names when the application does not use Unicode file names."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ReadOnly: bool
    """bool: Determines whether the user can change the text of the edit control.
        To restrict the edit control to display only, set the ReadOnly property to true. Set ReadOnly to false to allow the contents of the edit control to be edited.
        Setting ReadOnly to true ensures that the text is not altered, while still allowing the user to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    ScrollBars: ScrollStyle
    """ScrollStyle: Determines whether the memo control has scroll bars.
        Use ScrollBars to give a multiline edit control horizontal or vertical scroll bars. ScrollBars can take one of the following values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        ssNone
        
        
        
        The control has no scroll bars.
        
        
        
        
        ssHorizontal
        
        
        
        The control has a single scroll bar on the bottom edge.
        
        
        
        
        ssVertical
        
        
        
        The control has a single scroll bar on the right edge.
        
        
        
        
        ssBoth
        
        
        
        The control has a scroll bar on both the bottom and right edges."""
    SelStart: Any
    """Returns/sets the position of the cursor."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    WantReturns: bool
    """bool: Determines whether the user can insert return characters into the text.
        Set WantReturns to true to allow users to enter return characters into the text. Set WantReturns to false to allow the form to handle return characters instead. 
        For example, in a form with a default button (such as an OK button) and a memo control, if WantReturns is false, pressing Enter chooses the default button. If WantReturns is true, pressing Enter inserts a return character in the text.
        
        Note:  If WantReturns is false, users can still enter return characters into the text by pressing Ctrl+Enter."""
    WantTabs: bool
    """bool: Determines whether the user can insert tab characters into the text.
        Set WantTabs to true to allow users to enter tab characters into the text. Set WantTabs to false if you want the tab character to select the next control on the form instead. 
        
        Note:  If WantTabs is true, users can tab into the edit control, but they can't tab out."""
    WordWrap: bool
    """bool: Determines whether the edit control inserts soft carriage returns so that the text wraps at the right margin.
        Set WordWrap to true to make the edit control wrap text at the right margin so that it fits in the client area. The wrapping has cosmetic purposes only. The text does not include any return characters that were not explicitly entered. Set WordWrap to false to have the edit control display a separate line only where return characters were explicitly entered into the text. 
        
        Note:  Most of the times when WordWrap is true, the horizontal scroll bar is not necessary. However, exceptions appear; when the line cannot be cut into pieces, the wrapping cannot occur. In these cases, the scroll bar is still required."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MemoryStream(CustomMemoryStream):
    """TMemoryStream is a stream that stores its data in dynamic memory.
    Use TMemoryStream to store data in a dynamic memory buffer that is enhanced with file-like access capabilities. TMemoryStream provides the general I/O capabilities of a stream object while introducing methods and properties to manage a dynamic memory buffer.
    Memory streams are useful as intermediary objects that can hold information as well as read it from or write it to another storage medium. They provide a useful format for comparing the contents of streams, or for manipulating data that is stored in a less accessible medium."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Clear(self, *args, **kwargs) -> Any:
        """Frees the memory buffer, discarding all data associated with the memory stream.
        Use Clear to empty the memory buffer for the memory stream and free all associated memory. In addition to freeing the memory associated with the memory buffer, Clear:
        
        Sets the Memory property to nil (Delphi) or NULL (C++).
        Sets the Position property to 0.
        Sets the Size property to 0."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TMemoryStream.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMemoryStream reference is not nil, and only then calls Destroy.
        Destroy a TMemoryStream object when it is no longer needed to store or write data. Destroy calls Clear to free the memory buffer before calling the inherited destructor."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def LoadFromFile(self, FileName: str) -> None:
        """TMemoryStream.LoadFromFile(FileName: str) -> None
        Loads the entire contents of a file into the memory buffer.
        Use LoadFromFile to fill the memory stream with the contents of a file. Pass the name of the file as the FileName parameter. LoadFromFile allows an application to read the contents of a file into the memory stream without having to explicitly create and free a file stream object.
        LoadFromFile reallocates the memory buffer so that the contents of the file will exactly fit. It sets the Size property accordingly, and then reads the entire contents of the file into the memory buffer. Thus, LoadFromFile will discard any pre-existing data stored in the memory stream."""
    def LoadFromStream(self, Stream: Stream) -> None:
        """TMemoryStream.LoadFromStream(Stream: Stream) -> None
        Loads the entire contents of a stream into the memory buffer.
        Use LoadFromStream to fill the memory stream with the contents of the stream specified by the Stream parameter. LoadFromStream always sets the Position of the source stream to 0, before streaming in the number of bytes indicated by the source stream's Size property.
        LoadFromStream reallocates the memory buffer so that the contents of the source stream will exactly fit. It sets the Size property accordingly, and then reads the entire contents of the source stream into the memory buffer. Thus, LoadFromStream will discard any pre-existing data stored in the memory stream.
        If the source stream is a TFileStream object, LoadFromStream does the same thing as LoadFromFile, except that the application must create and free the TFileStream object. LoadFromStream also allows applications to fill a memory stream object from other types of stream objects."""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def SetSize(self, NewSize: int) -> None:
        """TMemoryStream.SetSize(NewSize: int) -> None
        Sets the Size property of the memory stream.
        Use SetSize to set the Size of a memory stream before filling it with data. SetSize allocates the memory buffer to hold NewSize bytes, preserving as much of the existing data as possible.
        Use SetSize before filling the memory buffer with data from various sources, or from a portion of another stream. If the intended contents of the memory stream is exactly the same as the contents of another stream or file, use LoadFromStream or LoadFromFile instead.\r
        Sets the Size property of the memory stream.
        Use SetSize to set the Size of a memory stream before filling it with data. SetSize allocates the memory buffer to hold NewSize bytes, preserving as much of the existing data as possible.
        Use SetSize before filling the memory buffer with data from various sources, or from a portion of another stream. If the intended contents of the memory stream is exactly the same as the contents of another stream or file, use LoadFromStream or LoadFromFile instead."""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """TMemoryStream.Write(Buffer, Count: int) -> int
        Writes Count bytes from Buffer to the current position in the memory buffer and updates the current position by Count bytes.
        Use Write to insert Count bytes into the memory buffer of the memory stream, starting at the current position. Write will increase the size of the memory buffer, if necessary, to accommodate the data being written in. If the current position is not the end of the memory buffer, Write will overwrite the data following the current position.
        Write updates the Size property to Position + Count, and sets the Position property to the new value of Size. Thus, any data that was stored in the memory stream in the Count bytes after the current position is lost when calling Write.
        Write always writes the Count bytes in the Buffer, unless there is a memory failure. Thus, for TMemoryStream, Write is equivalent to the WriteBuffer method.
        All other data-writing methods of a memory stream (WriteBuffer, WriteComponent) call Write to do the actual writing."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Menu(Component):
    """TMenu is the base type for menu components such as TMainMenu and TPopupMenu.
    Use TMenu as a base class when defining a component that represents a collection of menu items. TMenu introduces properties and methods to create a Windows menu that represents a set of menu items, dispatch commands associated with those menu items, and locate the help context id for any of those menu items."""
    __hash__: ClassVar[None] = ...
    AutoHotkeys: MenuAutoFlag
    """MenuAutoFlag: Determines whether the accelerator keys for menu items can be reset automatically.
        Set AutoHotkeys to indicate whether the menu should automatically ensure that accelerator keys for its items are reset if necessary so that every menu item has an accelerator key and no two items have the same accelerator key. This ensures that menu items added dynamically at runtime can have accelerator keys that do not introduce conflicts. TMenu tries to preserve all existing accelerator key mappings when adjusting the accelerator keys, but may be forced to change some in order to ensure that every item has a unique accelerator.
        Before the menu is displayed, the menu checks and adjusts the accelerator key mappings if AutoHotkeys is maAutomatic. When AutoHotkeys is maManual, the menu does not alter the top-level menu items, but may adjust the accelerator keys for submenus, depending on the AutoHotkeys property of the menu item that is the parent of the submenu.
        When AutoHotkeys is maManual, an application can still adjust the menu items by calling the Items property's RethinkHotkeys method. AutoHotkeys merely controls whether this adjustment occurs automatically.
        
        Note:  The AutoHotkeys property of a menu is linked to the AutoHotkeys property of the TMenuItems object that implements its Items property. Setting one sets the other."""
    AutoLineReduction: MenuAutoFlag
    """MenuAutoFlag: Determines whether redundant separator bars are automatically removed from the menu.
        Set AutoLineReduction to indicate whether the menu should automatically ensure that the menu does not start or end with a separator bar and that two separator bars do not appear next to each other. This ensures that menus built dynamically at runtime do not have separator bars in undesired positions.
        Before the menu is displayed, it removes superfluous separator bars when AutoLineReduction is maAutomatic. When AutoLineReduction is maManual, the menu does not remove separators from the top-level menu items, but may remove superfluous separators from submenus, depending on the AutoLineReduction property of the menu item that is the parent of the submenu.
        When AutoLineReduction is maManual, an application can still remove superfluous separators by calling the Items property's RethinkLines method. AutoLineReduction merely determines whether this adjustment occurs automatically.
        
        Note:  The AutoLineReduction property of a menu is linked to the AutoLineReduction property of the TMenuItems object that implements its Items property. Setting one sets the other."""
    BiDiMode: BiDiMode
    """BiDiMode: Determines the layout of the menu in Middle East locales.
        Set BiDiMode to control the layout of menu items. BiDiMode controls whether the menu items read from left to right or right to left."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Handle: int
    """int: Provides access to the Windows menu handle for the menu.
        Use Handle to call a Windows API function that requires a menu handle. Handle is the handle for the menu that contains only the items described by the Items property."""
    Images: CustomImageList
    """CustomImageList: Lists the images that can appear beside individual menu items.
        Use Images to hold the set of images that can appear beside menu items in the menu. Individual menu items set their ImageIndex property to indicate which image in the list appears to the left of the menu item caption.
        Images in the list should be 16x16.
        
        Tip:  If the application uses action lists, this property should be the value of the action list's Images property. This way, menu items and buttons that do the same thing can display the same image."""
    Items: MenuItem
    """MenuItem: Describes the elements of the menu.
        Use Items to access information about the elements in the menu. Items is a single TMenuItem object that describes the elements of the menu in its own Items property.
        
        Note:  Because Items is the default property of TMenuItem, the Items property of TMenu can be treated as an indexed array of menu items that describe the individual items in the menu. That is, instead of writing
        Note:  FirstItem?:= Menu1.Items.Items[0];
        Note:  you can use
        Note:  FirstItem?:= Menu1.Items[0];
        Set the Items property at design time by clicking on the Items property in the Property Inspector. The Menu Designer automatically inserts a menu item. As each menu item is entered, outlined regions appear at the possible locations of additional menu items. Click in those regions to specify additional menu items. At runtime, create a TMenuItem that describes the elements of the menu programmatically, and set the Items property of the menu."""
    Owner: Any
    """Returns the Component Owner"""
    OwnerDraw: bool
    """bool: Specifies whether the menu items are drawn by the application.
        Set OwnerDraw to true to indicate that the application will draw menu items in an OnDrawItem event handler. When OwnerDraw is true, menu items receive an OnMeasureItem and an OnDrawItem event when they need to be rendered on screen.
        Set OwnerDraw to false to accept the default drawing. When OwnerDraw is false, menu items display the caption with an optional image to the left (If the Images and ImageIndex properties are set).
        Owner-draw menus are useful for displaying the value that appears when selecting a menu item. For example, in a menu that allows users to choose a color, an owner-draw menu could display rectangles drawn in the designated color, rather than color names."""
    ParentBiDiMode: bool
    """bool: Indicates whether the BiDiMode property is inherited from the control that uses the menu.
        By default, ParentBiDiMode is true, indicating that the layout of menu items follows the BiDiMode setting of the associated form or control. Change ParentBiDiMode to false to override the default BiDiMode setting and control the menu's layout independently."""
    WindowHandle: int
    """int: Provides access to the handle of the window that uses the menu.
        Read WindowHandle to get the window handle of the control that receives WM_COMMAND messages when the user clicks on an item in the menu. When menu items are selected, use this handle in an OnClick event handler to send messages to the control that uses the menu or to make Windows API calls that affect the control. 
        Set WindowHandle to associate the menu with a control."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TMenu.Create(AOwner: Component) -> None
        Creates an instance of TMenu.
        Call Create to create a menu at runtime. Menus placed on forms at design time are created automatically. Create calls the inherited Create method, then sets the initial values for the menu component, including creating an Items property.
        The AOwner parameter indicates the component (usually a form) that is responsible for managing the memory associated with the menu."""
    def CreateMenuItem(self, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the menu component.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMenu reference is not nil, and only then calls Destroy. Destroy frees the Items property, and then calls the inherited Destroy method."""
    def DispatchCommand(self, ACommand: int) -> bool:
        """TMenu.DispatchCommand(ACommand: int) -> bool
        Calls the Click method of the menu item with the specified value as its Command property.
        Call DispatchCommand to simulate a click on the menu item associated with a command ID. If DispatchCommand locates a menu item that matches the command ID, it calls the Click method for that menu item and returns true. If there is no such item, DispatchCommand returns false."""
    def DispatchPopup(self, AHandle: int) -> bool:
        """TMenu.DispatchPopup(AHandle: int) -> bool
        Dispatches a pop-up menu command.
        Call DispatchPopup to simulate a click on the menu item associated with the pop-up menu handle. If DispatchPopup locates a menu item that matches the pop-up menu handle, it calls the Click method for that menu item and returns true. If there is no such item, DispatchPopup returns false."""
    def FindItem(self, Value: int, Kind: FindItemKind) -> MenuItem:
        """TMenu.FindItem(Value: int, Kind: FindItemKind) -> MenuItem
        Locates and returns a menu item.
        Call FindItem to locate a menu item in the menu or one of its submenus. The menu item is identified by either a pop-up menu handle, command ID, or menu shortcut value. The Kind parameter specifies how the menu item is to be identified."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TMenu.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Executes a callback for child menu items.
        GetChildren is called automatically by the streaming system so that child menu items are saved and read with their parent menu."""
    def GetHelpContext(self, Value: int, ByCommand: bool) -> int:
        """TMenu.GetHelpContext(Value: int, ByCommand: bool) -> int
        Returns the help context ID associated with a menu item.
        Call GetHelpContext to obtain the ID for context-sensitive help on a particular menu item. Identify the menu item as the item that matches the Value property. If ByCommand is true, Value is the Command property of the TMenuItem. If ByCommand is false, Value is the Handle property."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def IsRightToLeft(self, *args, **kwargs) -> Any:
        """Indicates whether menu items read from right to left.
        Call IsRightToLeft to determine the layout of main menu items. IsRightToLeft returns true if the application is running on a system with a Middle Eastern locale and the BiDiMode property is not bdLeftToRight."""
    def IsShortCut(self, Message: WMKey) -> bool:
        """TMenu.IsShortCut(Message: WMKey) -> bool
        Dispatches a key message if it represents a shortcut key for an item in the menu.
        Call IsShortCut when processing a KeyDown message to identify shortcut keys and trigger the appropriate menu action. IsShortCut decodes the key message passed in the Message parameter. It then encodes the state of the Shift, Control, and Alt keys with the value of the character that was typed to obtain the ShortCut property of a menu item. If IsShortCut locates a menu item associated with the shortcut key combination, it calls the item's Click method and returns true. If no item in the menu has a shortcut corresponding to the message, IsShortCut returns false."""
    def ParentBiDiModeChanged(self, *args, **kwargs) -> Any:
        """Ensures that the menu's layout follows the current settings of the BiDiMode and ParentBiDiMode properties.
        ParentBiDiMode changed is called when the menu's BiDiMode property must be updated to reflect the bi-directional mode of its associated control.\r
        Ensures that the menu's layout follows the current settings of the BiDiMode and ParentBiDiMode properties.
        ParentBiDiMode changed is called when the menu's BiDiMode property must be updated to reflect the bi-directional mode of its associated control."""
    def ProcessMenuChar(self, Message: WMMenuChar) -> None:
        """TMenu.ProcessMenuChar(Message: WMMenuChar) -> None
        Responds to keyboard input for the menu.
        ProcessMenuChar handles keyboard messages from Windows. It checks whether the character typed is an accelerator character from one of the menu's items. If so, ProcessMenuChar executes the menu item (or, if the item is disabled, selects it). If the key is not an accelerator, ProcessMenuChar checks for captions that begin with the character. If there is only one, it is treated like an accelerator. Otherwise, the first item beginning with that character is selected.
        When calling ProcessMenuChar programmatically, the User, MenuFlag, and Menu fields of Message parameter must be supplied."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class MenuItem(Component):
    """TMenuItem describes the properties of an item in a menu.
    Use TMenuItem to specify the appearance and behavior of an item in a menu. Each TMainMenu or TPopupMenu component can contain multiple menu items. When a menu is defined at design time, the Menu Designer automatically creates menu item objects for each command on the menu.
    The Caption property can be used to define an accelerator key to the menu item of a TMainMenu."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Designates the action associated with the menu item.
        Action designates the action object that is associated with the menu item. Actions can be associated with a menu item by using the action list editor at design-time. Actions are a way of centralizing user responses to commands."""
    AutoCheck: bool
    """bool: Indicates whether the menu item's checked state toggles automatically when the item is clicked.
        When AutoCheck is true, then every time the menu item is clicked, the value of the Checked property toggles automatically before the OnClick event occurs. When AutoCheck is false, the application must explicitly set the value of the Checked property (for example, in an OnClick event handler)."""
    AutoHotkeys: MenuItemAutoFlag
    """MenuItemAutoFlag: Determines whether the accelerator keys for submenu items can be reset automatically.
        Set AutoHotkeys to indicate whether the accelerator keys for the items in the Items property can be reset if necessary to ensure that every menu item has an accelerator key and no two items have the same accelerator key. This ensures that menu items added dynamically at runtime can have accelerator keys that do not introduce conflicts. TMenuItem tries to preserve all existing accelerator key mappings when adjusting the accelerator keys, but may be forced to change some in order to ensure that every item has a unique accelerator.
        Before the menu is displayed, it checks and adjusts the accelerator key mappings if AutoHotkeys is maAutomatic or if AutoHotkeys is maParent and the parent menu item adjusts accelerator key mappings. Otherwise, the menu does not alter the items listed in the Items property, but may adjust the accelerator keys for submenus, depending on the AutoHotkeys property of the menu item that is the parent of the submenu.
        
        Note:  When AutoHotkeys disallows automatic adjustment of accelerator keys, an application can still adjust the menu items by calling the RethinkHotkeys method. AutoHotkeys merely controls whether this adjustment occurs automatically."""
    AutoLineReduction: MenuItemAutoFlag
    """MenuItemAutoFlag: Determines whether redundant separator bars are automatically removed from the submenu.
        Set AutoLineReduction to indicate whether the menu item should automatically ensure that the submenu defined by its Items property does not start or end with a separator bar and that two separator bars do not appear next to each other. This ensures that menus built dynamically at run time do not have separator bars in undesired positions.
        Before the menu is displayed, the menu item removes superfluous separator bars if AutoLineReduction is maAutomatic or AutoLineReduction is maParent and the parent menu item removes superfluous separator bars. Otherwise, the menu item does not remove separators from the Items property, but may remove superfluous separators from submenus, depending on the AutoLineReduction property of the menu item that is the parent of the submenu.
        
        Note: When AutoLineReduction disallows automatic removal of separator bars, an application can still remove superfluous separators by calling the RethinkLines method. AutoLineReduction merely controls whether this adjustment occurs automatically."""
    Bitmap: Bitmap
    """Bitmap: Designates a bitmap that is drawn for the menu item.
        Use Bitmap to provide a custom image that appears next to the caption in the menu item. On owner-draw menus, Bitmap can be used from an OnDrawItem event handler to represent the entire menu item or a portion of the menu item.
        
        Note:  If the ImageIndex property is set and the parent menu has a non-nil (Delphi) or NULL (C++) Images property, the image identified by ImageIndex is used instead of Bitmap."""
    Break: MenuBreak
    """MenuBreak: Determines whether the menu item starts a new column in the menu.
        Set Break to break a long menu into columns at the item described by this menu item. The value of Break indicates whether the menu is broken into columns, and if so, whether a bar appears between the columns of the parent menu.
        The default is mbNone (no breaking into columns)."""
    Caption: str
    """str: Specifies the text of the menu item.
        Set Caption to the string the user sees for this item in the menu. To underline a character in a string, include an ampersand (&) before the character. This type of character is called an accelerator character. If Caption includes an accelerator character, the user can select the menu item by pressing Alt while typing the underlined character.
        
        Tip:  To automatically assign or adjust the accelerator characters in menu item captions, use the RethinkHotkeys method.
        Use the Caption property to identify the menu item as a line that separates the menu into parts. Specify a hyphen character (-) as the value of Caption for the menu item to indicate that the menu item is a separator. To separate the menu into multiple columns, use the Break property instead.
        
        Note:  This property is not stored with the menu item if it is supplied by a TAction object."""
    Checked: bool
    """bool: Specifies whether a check mark should appear beside the Caption.
        Use Checked to allow a menu item to work like a check box. If Checked is true, the menu item appears checked. If Checked is false, the menu item remains unchecked.
        
        Note:  This property is not stored with the menu item if it is supplied by a TAction object."""
    Command: int
    """int: Specifies the Windows Command ID associated with the menu item.
        Use Command in an application that directly handles WM_COMMAND messages. When the user selects the menu item, Windows sends a WM_COMMAND to the window associated with the menu. The ItemID of the message contains the value of the Command property of the menu item that was selected."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Count: int
    """int: Indicates the number of subitems of the menu item.
        Read Count to determine the number of subitems listed in the Items property array. When the user clicks on a menu item that has subitems, a dropdown menu appears which displays those subitems. Each subitem can, in turn, contain additional subitems. The Count property counts only the immediate subitems of the menu item."""
    Default: bool
    """bool: Specifies whether the menu item is invoked when the parent item is double clicked.
        Set Default to specify whether a menu item is the default item in a submenu. Default menu items are executed when the parent item is double-clicked, allowing users to avoid navigating the submenus that contain them. 
        The default item appears in boldface. A submenu can have only one default item. If the Items list of the parent menu item already contains a default menu item, setting the Default property to true sets the Default property of the previous default item to false."""
    Enabled: bool
    """bool: Specifies whether the menu item is enabled.
        Use Enabled to enable or disable a menu item. If Enabled is true, the Click method is called when the user selects the item with the mouse. If Enabled is false, the menu item appears dimmed and the user cannot select it. However, calling the Click method works even when Enabled is false.
        
        Note:  This property is not stored with the menu item if it is supplied by a TAction object."""
    GroupIndex: int
    """int: Identifies the logical group to which the menu item belongs.
        Use GroupIndex to control how menus are merged. In applications that contain multiple forms, items from the menus of secondary forms can be merged into the application's main menu as those forms become active. MDI applications always merge the menus of child windows with the main menu of the parent window. 
        By default, all menu items in a menu bar (main menu) have the same GroupIndex value. To use GroupIndex to merge menus, set the GroupIndex value of each successive menu item to a value equal to or greater than that of the previous menu item. 
        When a menu item in a menu bar that is merged into the application's main menu has the same GroupIndex value as a menu item in the main menu, the menu item in the application's main menu is replaced by the corresponding menu item. If multiple menu items in the application's main menu have the same GroupIndex value, they can be replaced only by separate menu items from the other form's menu that also have repeated GroupIndex values. Thus, the first main menu item with a given value is replaced by the first item in the second form with that value, the second item in the main form is replaced by the second item in the second form, and so on. 
        When a menu item in a menu bar that is merged into the application's main menu has a GroupIndex that falls between the GroupIndex values of two adjacent items on the application's main menu, that menu item is inserted between the two adjacent items. If the item's GroupIndex value is greater than all other GroupIndex values in the application's main menu, the item appears at the end of the main menu. If the GroupIndex value is less than all other GroupIndex values in the application's main menu, the menu item appears at the beginning of the main menu bar. 
        When an object created by an OLE 2.0 server application is activated, the server can try to merge its menus with the menus of the container application. The GroupIndex property is used to replace up to three main menu items with items from the server, in the manner described above. The server application uses the following predefined GroupIndex values to locate menu items to replace:
        
        
        
        
        
        Group
        
        Index
        
        Description
        
        
        
        Edit
        
        
        
        1
        
        
        
        Server menu items for editing the active OLE object
        
        
        
        
        View
        
        
        
        3
        
        
        
        Server menu items for modifying the view of the OLE object.
        
        
        
        
        Help
        
        
        
        5
        
        
        
        Server menu items for accessing the server's online Help.
        
        
        
        
        
        Note:  See the documentation for the OLE server for information about whether it attempts menu merge during in-place activation.
        GroupIndex can also be used to define groups of menu items that act like radio buttons. To allow menu items to behave like radio buttons, set the RadioItem property to all menu items in the group to true, and assign each menu item the same value of GroupIndex. Checking any menu item in the group will then uncheck the others."""
    Handle: int
    """int: Indicates the Windows menu handle of the drop-down menu associated with the menu item.
        Use Handle when calling a Windows API function that requires a menu handle. Handle is only valid if the Count property is greater than 0."""
    HelpContext: int
    """int: Specifies the help context ID associated with the menu item.
        Use HelpContext to associate the menu item with a screen in the Help system of the application. Each screen in the Help system should have a unique context ID. When a menu item is selected using the keyboard, pressing F1 displays a Help screen. Which Help screen appears depends on the value of the HelpContext property.
        
        Note:  This property is not stored with the menu item if it is supplied by a TAction object."""
    Hint: str
    """str: Specifies the text string that can appear when the user moves the mouse pointer over a menu item.
        Set Hint to a string that provides more information about the meaning of the menu item than the Caption. The hint text appears in the Status Bar when the user pauses with the mouse over the menu item if Help Hints are enabled (that is, if the Form's and the Application's ShowHint properties are True). It is also available for the code in the application's OnHint event handler.
        The value of Hint can specify both a short value for the Help Hint window and a longer string to be used by the OnHint event handler. To provide both a short and a long hint, set Hint to the short string, followed by a vertical bar (|), followed by the long string. 
        
        Note: This property is not stored with the menu item if it is supplied by a TAction object."""
    ImageIndex: int
    """int: Indicates which image maintained by the parent menu appears next to the menu item.
        Set ImageIndex to designate an image that should appear next to the caption when the menu item is drawn. On top-level menu items, ImageIndex specifies a zero-offset index into the Images property of the parent menu (TMenu or TPopupMenu). On submenu items, ImageIndex is the zero-offset index into the parent item's SubMenuImages property.
        If the parent menu or item does not maintain a list of images, use the Bitmap property to provide an image for a single menu item. However, any image specified by ImageIndex takes precedence over the Bitmap property. Bitmap is only used when ImageIndex has a negative value or the parent's Images or SubMenuImages property is nil (Delphi) or NULL (C++).
        
        Note:  This property is not stored with the menu item if it is supplied by a TAction object."""
    ImageName: str
    """str: Displays the name of linked items from the Image Collection."""
    Items: MenuItem
    """MenuItem:"""
    MenuIndex: int
    """int: Indicates the index of the menu item within its parent menu.
        Use MenuIndex to locate the menu item in the Items property of its parent menu item. Changing this value moves the menu item within its menu.
        
        Note: MenuIndex may not correspond to the position of the item in the menu the user sees. The menu can include items that are not visible."""
    OnAdvancedDrawItem: Callable[[Object,Canvas,Rect,OwnerDrawState],None]
    """Callable[[Object, Canvas, Rect, OwnerDrawState], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDrawItem: Callable[[Object,Canvas,Rect,bool],None]
    """Callable[[Object, Canvas, Rect, bool], None]:"""
    OnMeasureItem: Callable[[Object,Canvas,int,int],None]
    """Callable[[Object, Canvas, int, int], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    Parent: MenuItem
    """MenuItem: Identifies the parent menu item of this menu item.
        Read Parent to determine the menu item that represents the dropdown menu that contains this menu item. If the menu item is a top level menu item in a main menu or pop-up menu, Parent is the value of that menu's Items property."""
    RadioItem: bool
    '''bool: Specifies whether the menu item is mutually exclusive with other menu items in its group.
        Use RadioItem to make the menu item behave like a radio button with a group of other menu items. The group of menu items is the set of all menu items in a pop-up or drop-down menu that have the same value of GroupIndex. When RadioItem is true, only one menu item in the group that contains the menu item can be checked at a time. The single selected menu item in the group is indicated by a round dot next to the Caption.
        
        Note: RadioItem does not automatically select the item when the user clicks it at runtime: you must still explicitly set the Checked property to true in response to the OnClick event. RadioItem simply changes the appearance of the Checked state (from a check mark to a round dot) and automatically unchecks other menu items in the same group when you set the Checked property to true.
        RadioItem does not work for the top-level items in a main menu.
        
        Note:  Under Windows NT 3.51, the round dot indicator only appears if the "new shell" has been installed.'''
    ShortCut: int
    """int: Shortcut that opens the menu item.
        The string representation of this shortcut appears to the right of the menu item in the menu.
        
        Note: ShortCut is not stored with the menu item if it is supplied by an action."""
    SubMenuImages: CustomImageList
    """CustomImageList: Lists the images that can appear beside individual items in a submenu of this menu item.
        Use SubMenuImages to supply a set of images that can appear beside items listed in the Items property. Individual menu items set their ImageIndex property to indicate which image in the list appears to the left of the menu item caption.
        
        Tip:  If the application uses action lists, this property can be the value of the command list's Images property. This way, menu items and buttons that do the same thing can display the same image."""
    Visible: bool
    """bool: Specifies whether the menu item appears in the menu.
        Use Visible to prevent the user from seeing an item in the menu. For example, remove menu items that do not apply to the current component of a pop-up menu in an OnPopup event handler.
        If Visible is true, the menu item appears. If Visible is false, the menu item is hidden.
        
        Note:  This property is not stored with the menu item if it is supplied by a TAction object."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Add(self, Item: MenuItem) -> None:
        """TMenuItem.Add(Item: MenuItem) -> None
        Adds one or more menu items to the end of the Items property array.
        Use Add to add new menu items to the dropdown menu for this menu item. If this menu item is the value of the Items property of a main menu or pop-up menu, Add adds the items to the end of the menu. 
        Specify a single new menu item to add as the value of the Item parameter, or an array of new menu items as the value of the AItems parameter. AItems_Size is the index of the last item in the AItems array (one less than the number of items).\r
        Adds one or more menu items to the end of the Items property array.
        Use Add to add new menu items to the dropdown menu for this menu item. If this menu item is the value of the Items property of a main menu or pop-up menu, Add adds the items to the end of the menu. 
        Specify a single new menu item to add as the value of the Item parameter, or an array of new menu items as the value of the AItems parameter. AItems_Size is the index of the last item in the AItems array (one less than the number of items)."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Clear(self, *args, **kwargs) -> Any:
        """Removes and frees all menu items listed in the Items property.
        Use Clear to free all the items listed in the Items property array."""
    def Click(self, *args, **kwargs) -> Any:
        """Simulates a mouse click.
        Click generates an OnClick event, as if the user had clicked the menu item. Unlike a real mouse click, Click does not generate a WM_COMMAND message to the window associated with the menu.
        Component writers can override click to provide a different response when the user selects the menu item."""
    def Create(self, AOwner: Component) -> None:
        """TMenuItem.Create(AOwner: Component) -> None
        Creates an instance of TMenuItem.
        Use Create to create a menu item at runtime. Menu items defined at design time using the Menu designer are created automatically.
        AOwner is the component that is responsible for freeing the menu item. It becomes the value of the Owner property."""
    def Delete(self, Index: int) -> None:
        """TMenuItem.Delete(Index: int) -> None
        Removes a menu item from the Items property array.
        Call Delete to remove a menu item and all its submenus from a menu. The Index parameter is the index of the item to be deleted, where 0 specifies the first item in the menu, 1 specifies the second item, and so on.
        Delete does not free the removed item's memory. To remove an item from the menu and free its memory, call the Free method in the item you want to remove.
        To temporarily hide a menu item, without deleting it, use the Visible property."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TMenuItem.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMenuItem reference is not nil, and only then calls Destroy."""
    def Find(self, ACaption: str) -> MenuItem:
        """TMenuItem.Find(ACaption: str) -> MenuItem
        Locates a menu item in the Items property array given its caption.
        Use Find to locate the menu item in the Items property array with the caption specified by the ACaption parameter. Find ignores accelerator characters when comparing item captions to the ACaption parameter.
        Find returns the first menu item in the Items property array with the specified caption. If no item is found, Find returns nil (Delphi) or NULL (C++)."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TMenuItem.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Enumerates all child components.
        Vcl.Menus.TMenuItem.GetChildren inherits from System.Classes.TComponent.GetChildren. All content below this line refers to System.Classes.TComponent.GetChildren.
        Enumerates all child components.
        GetChildren is used internally in the component streaming system. It is not necessary to call it directly. 
        GetChildren expects a TGetChildProc routine that receives all enumerated components. 
        Root represents the owner of the components that will be enumerated.
        This method does nothing in TComponent and is expected to be overridden in descendants."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TComponent enumerator.
        Vcl.Menus.TMenuItem.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
        Returns a TComponent enumerator.
        GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
        To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop."""
    def GetImageList(self, *args, **kwargs) -> Any:
        """Returns the Image list that supplies an image for the menu item.
        Use GetImageList to access the list of images that contains the image for this menu item. The ImageIndex property identifies a specific image from the list that GetImageList returns.
        GetImageList first checks the Parent of this menu item for a SubMenuImages property. If the parent menu item does not maintain a list of images, it checks that menu item's parent, and so on until reaching a top-level menu item (a menu item where Parent is not set). If none of the parent menu items has a SubMenuImages property, GetImageList checks the top-level menu for an Images property.
        GetImageList returns the first image list it finds. If it doesn't find an image list, GetImageList returns nil (Delphi) or NULL (C++)."""
    def GetItem(self, Index: int) -> MenuItem:
        """TMenuItem.GetItem(Index: int) -> MenuItem
        Embarcadero Technologies does not currently have any additional information."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def GetParentMenu(self, *args, **kwargs) -> Any:
        """Returns the main menu of which the menu item is part.
        GetParentMenu returns the menu that contains the menu item."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def IndexOf(self, Item: MenuItem) -> int:
        """TMenuItem.IndexOf(Item: MenuItem) -> int
        Returns the position of a menu item within the Items array.
        Call IndexOf to locate a menu item in the submenu headed by this menu item. IndexOf returns 0 for the first menu item, 1 for the second menu item, and so on. If the menu item is not in the submenu, IndexOf returns -1.
        
        Note: IndexOf may not correspond to the position of the item in the menu the user sees if the menu includes some items that are not visible."""
    def InitiateAction(self, *args, **kwargs) -> Any:
        """Calls the action link's Update method if the menu item is associated with an action link.
        InitiateAction calls the action link, if there is one for the menu item, to update the association between the action and the menu item."""
    def Insert(self, Index: int, Item: MenuItem) -> None:
        """TMenuItem.Insert(Index: int, Item: MenuItem) -> None
        Inserts a menu item into a specified position in the Items array.
        Use Insert to insert a new menu item to the dropdown menu for this menu item. If this menu item is the value of the Items property of a main menu or pop-up menu, Insert inserts an item into that menu. Specify the new menu item to add as the value of the Item parameter, and the position in the Items array as the value of the Index parameter."""
    def InsertNewLineAfter(self, AItem: MenuItem) -> int:
        """TMenuItem.InsertNewLineAfter(AItem: MenuItem) -> int
        Inserts a separator bar after a specified item from the Items property array.
        Use InsertNewLineAfter to insert a separator bar after the menu item specified by AItem. If AItem is not an item in the Items property array, InsertNewLineAfter raises an exception.
        InsertNewLineAfter returns the index of the newly inserted separator item in the Items property array.
        
        Tip:  When inserting separator bars at runtime, it is a good idea to set AutoLineReduction to true so that superfluous separators can be automatically removed."""
    def InsertNewLineBefore(self, AItem: MenuItem) -> int:
        """TMenuItem.InsertNewLineBefore(AItem: MenuItem) -> int
        Inserts a separator bar before a specified item from the Items property array.
        Use InsertNewLineBefore to insert a separator bar before the menu item specified by AItem. If AItem is not an item in the Items property array, InsertNewLineBefore raises an exception.
        InsertNewLineBefore returns the index of the newly inserted separator item in the Items property array.
        
        Tip:  When inserting separator bars at runtime, it is a good idea to set AutoLineReduction to true so that superfluous separators can be automatically removed."""
    def IsLine(self, *args, **kwargs) -> Any:
        """Indicates whether the menu item represents a separator bar.
        Call IsLine to determine whether the menu item is a separator bar. IsLine checks the Caption of the menu item and returns true if the value of Caption is '-'. Menu items with this Caption appear as separator bars."""
    def NewBottomLine(self, *args, **kwargs) -> Any:
        """Inserts a separator bar at the end of the Items property array.
        Use NewBottomLine to insert a separator bar at the end of the items property array. This is useful when building up submenus dynamically at runtime.
        NewBottomLine returns the index of the newly inserted separator item in the Items property array.
        
        Tip:  When inserting separator bars at runtime, it is a good idea to set AutoLineReduction to true so that superfluous separators can be automatically removed."""
    def NewTopLine(self, *args, **kwargs) -> Any:
        """Inserts a separator bar at the beginning of the Items property array.
        Use NewTopLine to insert a separator bar at the beginning of the items property array. This is useful when building up submenus dynamically at runtime.
        NewTopLine returns the index of the newly inserted separator item in the Items property array.
        
        Tip:  When inserting separator bars at runtime, it is a good idea to set AutoLineReduction to true so that superfluous separators can be automatically removed."""
    def Remove(self, Item: MenuItem) -> None:
        """TMenuItem.Remove(Item: MenuItem) -> None
        Removes a menu item from the Items property array
        Call Remove to remove a menu item and all its submenus from a menu. The Item parameter is the item to be removed. If Item is not a menu item in the Items array, Remove raises an exception.
        Remove does not free the item's memory. To remove an item from the menu and free its memory, call the Free method in the item you want to remove.
        To temporarily hide a menu item, without deleting it, use the Visible property."""
    def RethinkHotkeys(self, *args, **kwargs) -> Any:
        """Adjusts the captions of subitems so that every item has an accelerator and there are no duplicate accelerator keys.
        Call RethinkHotkeys to adjust the accelerator keys for the items in the Items property and in any submenu of those items. RethinkHotkeys checks for items that do not have an accelerator key or that have duplicate accelerator keys. It then replaces any duplicate accelerators with unique characters and adds accelerator keys to items that don't have them. RethinkHotkeys gives first priority to existing accelerator key mappings, but may change them if necessary to ensure uniqueness.
        RethinkHotkeys lets a menu adjust the accelerator keys when the AutoHotkeys property is false. For any menu or submenu that has AutoHotkeys set to true, this adjustment occurs automatically.
        RethinkHotkeys returns true if RethinkHotkeys changed the Caption property of any menu items, false otherwise."""
    def RethinkLines(self, *args, **kwargs) -> Any:
        """Removes superfluous separator lines from the Items property array.
        Call RethinkLines to remove superfluous separators from the items in the Items property and in any submenu of those items. RethinkLines removes separators that appear at the very beginning or end of a submenu and separators that immediately follow another separator.
        RethinkLines lets a menu remove superfluous separators when the AutoLineReduction property is false. For any menu or submenu that has AutoLineReduction set to true, this adjustment occurs automatically.
        RethinkLines returns true if RethinkLines removed any menu items, false otherwise."""
    def SetParentComponent(self, Value: Component) -> None:
        """TMenuItem.SetParentComponent(Value: Component) -> None
        Sets the parent component.
        Vcl.Menus.TMenuItem.SetParentComponent inherits from System.Classes.TComponent.SetParentComponent. All content below this line refers to System.Classes.TComponent.SetParentComponent.
        Sets the parent component.
        SetParentComponent is used internally in the component streaming system. It is not necessary to call it directly. 
        Derived classes override this method to implement proper handling for parenting."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Metafile(Graphic):
    """TMetafile is an encapsulation of the Win32 Enhanced metafile.
    TMetafile contains a metafile graphic (EMF file format).
    Properties of TMetafile indicate the size and characteristics of the metafile.
    To draw a metafile on a canvas, call the Draw or StretchDraw methods of a TCanvas object, passing a TMetafile as a parameter. The Enhanced property determines how the metafile will be stored on disk. If Enhanced is true, the metafile is stored as an .EMF (Win32 Enhanced Metafile) file. If Enhanced is false, the metafile is stored as a .WMF (Windows 3.1 Metafile, with Aldus header)."""
    __hash__: ClassVar[None] = ...
    CreatedBy: Any
    Description: Any
    Enhanced: Any
    Handle: Any
    Inch: Any
    MMHeight: Any
    MMWidth: Any
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, Source: Persistent) -> None:
        """TMetafile.Assign(Source: Persistent) -> None
        Copies an object to the metafile.
        Assign copies the Enhanced and Palette properties of an object to the metafile. If the metafile is nil (Delphi) or NULL (C++), Assign creates one. Otherwise, Assign calls the inherited method. For assignment, metafiles are polymorphic with other TGraphic objects, and with TPicture."""
    @classmethod
    def CanLoadFromStream(cls, Stream: Stream) -> bool:
        """TMetafile.CanLoadFromStream(Stream: Stream) -> bool
        Vcl.Graphics.TMetafile.CanLoadFromStream inherits from Vcl.Graphics.TGraphic.CanLoadFromStream. All content below this line refers to Vcl.Graphics.TGraphic.CanLoadFromStream.
        CanLoadFromStream returns True when a specified stream contains a streamed image of a specific TGraphic subclass. 
        The method uses current stream position, it does not change current stream position."""
    def Clear(self) -> Any:
        """TMetaFile.Clear()"""
    def Create(self, *args, **kwargs) -> Any:
        """Instantiates a metafile object.
        Call Create to instantiate a metafile at runtime.
        Create allocates memory for a metafile object, and calls the inherited Create. Then sets the Enhanced and Transparent properties to true.
        To create a metafile image from scratch, draw the image in a metafile canvas. When the metafile canvas is destroyed, it transfers the image into the metafile object provided to the metafile canvas constructor. After the image is drawn on the canvas and the canvas is destroyed, the image is 'playable' in the metafile object."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of a metafile object.
        Do not call Destroy directly in an application. Instead, an application should call Free. Free verifies that the TMetafile reference is not nil before it calls Destroy.
        Destroy releases the image, which frees the image and the handle when the reference count on the metafile image is zero. Then Destroy calls the inherited Destroy."""
    def HandleAllocated(self, *args, **kwargs) -> Any:
        """Indicates whether the TMetafile object has acquired a handle to the underlying GDI object.
        Use HandleAllocated to determine whether the Handle property is set to an HMETAFILE value. HandleAllocated indicates whether the underlying GDI object has already been created. Use HandleAllocated rather than reading the Handle property. When an application reads the Handle property, it automatically creates a metafile and returns its handle if the underlying GDI object does not already exist."""
    def LoadFromClipboardFormat(self, AFormat: int, AData: int, APalette: int) -> None:
        """TMetafile.LoadFromClipboardFormat(AFormat: int, AData: int, APalette: int) -> None
        Loads a metafile from the Clipboard.
        LoadFromClipboardFormat replaces the current image with the data in the clipboard. LoadFromClipboardFormat ignores the AData and APalette parameters."""
    def LoadFromStream(self, Stream: Stream) -> None:
        """TMetafile.LoadFromStream(Stream: Stream) -> None
        Loads the metafile from a stream.
        Use LoadFromStream by specifying the stream from which the metafile is loaded as the value of Stream. LoadFromStream reads a metafile from a stream and replaces the current image with it."""
    def ReleaseHandle(self) -> Any:
        """TMetaFile.ReleaseHandle()"""
    def SaveToClipboardFormat(self, AFormat: int, AData: int, APalette: int) -> None:
        """TMetafile.SaveToClipboardFormat(AFormat: int, AData: int, APalette: int) -> None
        Saves a metafile to a Clipboard format.
        Use SaveToClipboardFormat to copy the metafile to a Clipboard format. The resulting values can then be copied to the Windows clipboard using the clipboard's SetAsHandle method.
        The metafile's palette is returned in the APalette parameter, the format in the AFormat parameter, and a handle to the data in the AData parameter. Before the metafile can be saved, an application must have registered the format with the metafile object using the RegisterClipboardFormat method.
        To save a metafile to a file, call SaveToFile."""
    def SaveToFile(self, Filename: str) -> None:
        '''TMetafile.SaveToFile(Filename: str) -> None
        Writes the metafile to disk.
        Use SaveToFile to save the metafile to a file provided by the Filename parameter. To load a metafile from a file, call the LoadFromFile method.
        
         Note: If the Filename parameter has an extension of ".wmf", the metafile is saved as a WMF file. It is not necessary to set the Enhanced property.'''
    def SaveToStream(self, Stream: Stream) -> None:
        """TMetafile.SaveToStream(Stream: Stream) -> None
        Writes the metafile to a stream.
        Use SaveToStream to save the metafile to the stream specified by the Stream parameter. 
        If the Enhanced property is True, the metafile is saved as an EMF; if False, it it saved as a WMF."""
    def SetSize(self, AWidth: int, AHeight: int) -> None:
        """TMetafile.SetSize(AWidth: int, AHeight: int) -> None
        Specifies the size of the metafile.
        Use the SetSize method to set both the height and width of the metafile. This results in better performance than setting the height and width separately."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Monitor(Object):
    """TMonitor represents a monitor on which an application runs.
    TMonitor represents a monitor that displays the user interface of an application. It introduces properties to describe the dimensions of a single monitor. In addition, the Primary property distinguishes the primary property from other monitors on the system.
    When writing multi-monitor applications, use TMonitor to help lay out forms and dialogs so that they are not split over several monitors.
    Applications do not create instances of TMonitor. Instead, monitor components for all available monitors are listed by the Monitors property of the global Screen variable. The global Screen variable also provides global information about the monitors on which the application runs, such as screen resolution, available fonts, and so on."""
    __hash__: ClassVar[None] = ...
    BoundsRect: Any
    """Indicates the dimensions of the monitor in pixels."""
    Handle: Any
    """Indicates the Windows handle for the monitor."""
    Height: Any
    """Indicates the vertical size of the monitor in pixels."""
    Left: Any
    """Indicates the logical position of the left edge of the monitor."""
    MonitorNum: Any
    """Specifies the index of the monitor in the global screen object's Monitors list."""
    PixelsPerInch: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    Primary: Any
    """Indicates whether this is the primary monitor."""
    Top: Any
    """Indicates the logical position of the top edge of the monitor."""
    Width: Any
    """Indicates the horizontal size of the monitor in pixels."""
    WorkareaRect: Any
    """Indicates the dimensions of the usable area on the monitor."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Notebook(CustomControl):
    """TNotebook displays multiple pages, each with its own set of controls.
    Notebook components are frequently used with tab set controls (TTabSet) to let the user select pages in the notebook by clicking a tab. TNotebook is provided for backward compatibility. New applications should use TPageControl instead."""
    __hash__: ClassVar[None] = ...
    ActivePage: str
    """str: Determines which page displays in the notebook.
        ActivePage determines which page displays in the notebook. The value of ActivePage must be one of the strings contained in the Pages property.
        To get or set the active page by index rather than string, use the PageIndex property instead."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnPageChanged: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    PageIndex: int
    """int: Determines which page displays in the notebook control.
        The value of PageIndex determines which page displays in the notebook. Changing the PageIndex value changes the page in the control.
        Each string in the Pages property is automatically assigned a PageIndex value when the page is created. The first page receives a value of 0, the second has a value of 1, and so on. If you delete a string from the Pages property, the PageIndex values are reassigned so that the values always begin with 0 and continue to increase without any gaps between values.
        To get or set the current page using its string rather than its index, use the ActivePage property instead."""
    Pages: Strings
    """Strings: Contains the strings that identify the individual pages of the notebook control.
        The Pages property contains the strings that identify the individual pages of the notebook control. Both these controls create a separate page for each string in the Pages property. For example, if Pages contains three strings, First, Second, and Third, the control has three separate pages. 
        You can access the various pages in a notebook or tabbed notebook control with either the ActivePage or PageIndex property."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TNotebook.Create(AOwner: Component) -> None
        Constructs a TNotebook component.
        Call Create to instantiate a notebook at runtime. Notebook components placed in forms at design time are created automatically.
        The AOwner parameter specifies the component (usually the form) that is responsible for freeing the notebook."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TNotebook component.
        Do not call Destroy directly in an application. Instead, use Free, which checks that the TNotebook reference is not nil before calling Destroy."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TNotebook.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Calls a specified method for each child of the control.
        Vcl.ExtCtrls.TNotebook.GetChildren inherits from Vcl.Controls.TWinControl.GetChildren. All content below this line refers to Vcl.Controls.TWinControl.GetChildren.
        Calls a specified method for each child of the control.
        GetChildren is called by the streaming system that loads and saves components. Applications seldom need to call this routine.
        GetChildren executes the callback specified by the Proc parameter for every child control listed by the Controls property that lists the Root parameter as its Owner.
        Override GetChildren to limit or augment which child controls are saved with the control. When overriding GetChildren, call the procedure passed as the Proc parameter for every child control that should be saved. The Root parameter indicates the component (usually a form) that owns the control."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class NumberBox(CustomNumberBox):
    """TNumberBox is a numeric input control that supports the input of integer numbers, floating point numbers with a given set of decimal digits and proper formatting, and currency values."""
    __hash__: ClassVar[None] = ...
    AcceptExpressions: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: Alignment
    """Alignment: Determines how the text is aligned within the text edit control.
        Use Alignment to change the way the text is formatted in the text edit control. Alignment can take one of the following values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        taLeftJustify
        
        
        
        Align text to the left side of the control
        
        
        
        
        taCenter
        
        
        
        Center text horizontally in the control.
        
        
        
        
        taRightJustify
        
        
        
        Align text to the right side of the control."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSelect: bool
    """bool: Determines whether all the text in the edit control is automatically selected when the control gets focus.
        Set AutoSelect to select all the text when the edit control gets focus. AutoSelect only applies to single-line edit controls.
        Use AutoSelect when the user is more likely to replace the text in the edit control than to append to it."""
    AutoSize: bool
    """bool: Determines whether the height of the edit control automatically resizes to accommodate the text.
        Use AutoSize to make the edit control adjust its size automatically so the client area accommodates the height of the text. When AutoSize is false, the edit control has a fixed height. When AutoSize is true, the size of the control is readjusted whenever a change occurs that could affect the height of the control, such as a change to the font or border style.
        
        Note: AutoSize only adjusts the height of the edit control. Even with AutoSize set to true, text in the edit control may appear truncated if it extends beyond the width of the control."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: BorderStyle
    """BorderStyle: Determines whether the edit control has a single line border around the client area.
        Use BorderStyle to affect the sharpness with which the client area of the edit control stands out. BorderStyle can have a value of either bsSingle or bsNone. If BorderStyle is bsSingle, the edit control has a single-line border around the client area. If BorderStyle is bsNone, there will be no border."""
    CharCase: EditCharCase
    """EditCharCase: Determines the case of the text within the edit control.
        Use CharCase to force the contents of the edit control to assume a particular case.
        When CharCase is set to ecLowerCase or ecUpperCase, the case of characters is converted as the user types them into the edit control. Changing the CharCase property to ecLowerCase or ecUpperCase changes the actual contents of the text, not just the appearance. Any case information is lost and can't be recaptured by changing CharCase to ecNormal."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    CurrencyFormat: NumberBoxCurrencyFormat
    """NumberBoxCurrencyFormat: Embarcadero Technologies does not currently have any additional information."""
    CurrencyString: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Decimal: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    DisplayFormat: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HideSelection: bool
    """bool: Determines whether the visual indication of the selected text remains when focus shifts to another control.
        Set HideSelection to false to provide visual feedback of the selected portion of the text even when the edit control does not have focus. Set HideSelection to true to show the selection only when the edit control has focus. HideSelection does not affect the actual value of the selection, only the visual indication. Always setting HideSelection to false can make forms with many edit controls look too busy."""
    ImeMode: ImeMode
    """ImeMode: Determines the behavior of the input method editor (IME).
        Set ImeMode to configure the way an IME processes user keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application. 
        ImeMode allows a control to influence the type of conversion performed by the IME so that it is appropriate for the input expected by the control. For example, a control that only accepts numeric input might specify an ImeMode of imClose, as no conversion is necessary for numeric input.
        
        Note:  The value of ImeMode only takes effect when the control receives focus. To change the value of ImeMode when the control already has input focus, call the SetIme method."""
    ImeName: str
    """str: Specifies the input method editor (IME) to use for converting keyboard input to Asian language characters.
        Set ImeName to specify which IME to use for converting keystrokes. An IME is a front-end input processor for Asian language characters. The IME hooks all keyboard input, converts it to Asian characters in a conversion window, and sends the converted characters or strings on to the application.
        ImeName must specify one of the IMEs that has been installed through the Windows control panel. The property inspector provides a drop-down list of all currently installed IMEs on the system. At runtime, applications can obtain a list of currently installed IMEs from the global Screen variable.
        If ImeName specifies an unavailable IME, the IME that was active when the application started is used instead. No exception is generated.
        
        Note:  The value of ImeName only takes effect when the control receives focus. To change the value of ImeName after the control has input focus, call the SetIme method."""
    LargeStep: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    MaxLength: int
    """int: Specifies the maximum number of characters the user can enter into the edit control.
        Use MaxLength to limit the number of characters that can be entered into the edit control. A value of 0 indicates that there is no application-defined limit on the length.
        Use MaxLength to limit the length of the text in an edit control if that text will be copied into a fixed-length buffer.
        
        Note:  Setting MaxLength will not truncate the existing text, it merely prevents the user from adding more text after reaching the limit of MaxLength characters.
        Note:  Even when MaxLength is 0, there may be limitations imposed by the operating system on the number of characters that may be entered into an edit control.
        Note:  The unit of MaxLength is characters (not bytes) if the application is using themes."""
    MaxValue: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    MinValue: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    Mode: NumberBoxMode
    """NumberBoxMode: Embarcadero Technologies does not currently have any additional information."""
    NegativeValueColor: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    OEMConvert: bool
    """bool: Determines whether characters typed in the edit control are converted from ANSI to OEM and then back to ANSI.
        To ensure that any characters typed in the edit control can be unambiguously converted to the OEM character set, set OEMConvert to true. This causes all characters to be converted from ANSI to OEM and then back to ANSI as they are typed. Set OEMConvert to false to avoid the overhead of this conversion when it does not matter whether the text can be unambiguously mapped to an OEM string.
        OEMConvert is most useful for edit controls used to enter file names when the application does not use Unicode file names."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChangeValue: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnEvaluateExpression: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnValidateChar: Any
    """Callable[[unicodechr(str), bool], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ReadOnly: bool
    """bool: Determines whether the user can change the text of the edit control.
        To restrict the edit control to display only, set the ReadOnly property to true. Set ReadOnly to false to allow the contents of the edit control to be edited.
        Setting ReadOnly to true ensures that the text is not altered, while still allowing the user to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    SelStart: Any
    """Returns/sets the position of the cursor."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    SmallStep: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    SpinButtonOptions: NumberBoxSpinButtonOptions
    """NumberBoxSpinButtonOptions: Embarcadero Technologies does not currently have any additional information."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    TextHint: str
    """str: A hint or message to be displayed when the Text property is empty.
        Use TextHint to cue the user on what kind of entry is expected in the text field. Runtime themes must be enabled.
        
        Code Examples
        StdCtrlsProp (Delphi)
        StdCtrlsProp (C++)"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    UseMouseWheel: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseNaNValue: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    UseUpDownKeys: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    Value: float
    """float: Embarcadero Technologies does not currently have any additional information."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    Wrap: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Object:
    """TObject is the ultimate ancestor of all objects and components.
    TObject encapsulates fundamental behavior common to objects by introducing methods that:
    
    Create, maintain, and destroy instances of the object by allocating, initializing, and freeing required memory.
    Respond when object instances are created or destroyed.
    Return class-type and instance information on an object and runtime type information (RTTI) about its published properties.
    Support message handling.
    Support interfaces implemented by the object.
    Use TObject as an immediate base class when declaring simple objects that do not need to persist (are not saved and reloaded) and that do not need to be assigned to other objects. 
    Much of the capability of objects is established by methods that TObject introduces. Many of these methods are used internally by IDEs and are not intended for users to call directly. Others are overridden in descendant objects that have more complex behavior. 
    Although TObject is the based object of a component framework, not all objects are components. All component classes descend from TComponent. 
    
    Note: TObject is never directly instantiated. Although it does not use programming language features that prevent instantiation, TObject is an abstract class."""
    __hash__: ClassVar[None] = ...
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AfterConstruction(self, *args, **kwargs) -> Any:
        """Responds after the last constructor has executed.
        AfterConstruction is called automatically after the object's last constructor has executed. Do not call it explicitly in your applications. 
        The AfterConstruction method implemented in TObject does nothing. Override this method when creating a class that performs an action after the object is created. For example, TCustomForm overrides AfterConstruction to generate an OnCreate event."""
    def BeforeDestruction(self, *args, **kwargs) -> Any:
        """Responds before the first destructor executes.
        BeforeDestruction is called automatically before the object's first destructor executes. Do not call it explicitly in your applications. 
        The BeforeDestruction method implemented in TObject does nothing. Override this method when creating a class that performs an action before the object is destroyed. For example, TCustomForm overrides BeforeDestruction to generate an OnDestroy event. 
        
        Note: BeforeDestruction is not called when the object is destroyed before it is fully constructed. That is, if the object's constructor raises an exception, the destructor is called to dispose of the object, but BeforeDestruction is not called."""
    @classmethod
    def ClassInfo(cls, *args, **kwargs) -> Any:
        """Returns a pointer to the run-time type information (RTTI) table for the object type.
        ClassInfo provides access to the RTTI table for a given object type.
        Some classes do not provide run-time type information. For these classes, ClassInfo returns nil (Delphi) or NULL (C++). All classes descended from TPersistent do provide run-time type information."""
    @classmethod
    def ClassName(cls, *args, **kwargs) -> Any:
        """Returns a string indicating the type of the object instance (as opposed to the type of the variable passed as an argument).
        Use ClassName to obtain the class name from an object instance or class reference. This is useful for differentiating object instances that are assigned to a variable that has the type of an ancestor class. 
        
        Note: In C++ code, call ClassName as a method to obtain an object's class name. Use the global static function to obtain the class name from a metaclass object."""
    @classmethod
    def ClassNameIs(cls, Name: str) -> bool:
        """TObject.ClassNameIs(Name: str) -> bool
        Determines whether an object is of a specific type.
        ClassNameIs determines whether an object instance or class reference has a class name that matches a specified string. This is useful to query objects across modules or shared libraries. 
        
        Note: In C++ code, call ClassNameIs as a method to compare an object's class name. Use the global static function to compare the class name from a metaclass object."""
    @classmethod
    def ClassParent(cls, *args, **kwargs) -> Any:
        """Returns the type of the immediate ancestor of a class.
        ClassParent returns the name of the parent class for an object instance or class reference. For TObject, ClassParent returns nil (Delphi) or NULL (C++). 
        Avoid using ClassParent in application code. 
        
        Note: In Delphi code, use the is or as operators instead of ClassParent.
        Note: In C++ code, use a dynamic cast or the InheritsFrom method instead of ClassParent."""
    def ClassType(self, *args, **kwargs) -> Any:
        """Returns the class reference for the object's class.
        
        Note: ClassType dynamically determines the type of an object and returns its class reference, or metaclass.
        Avoid using ClassType in application code. 
        
        Note: In Delphi code, use the is or as operators instead of ClassType.
        Note: In C++ code, use a dynamic cast or the InheritsFrom method instead of ClassType."""
    def CleanupInstance(self, *args, **kwargs) -> Any:
        """Performs finalization on long strings, variants, and interface variables within a class.
        Do not call CleanupInstance directly. CleanupInstance is called automatically when the object instance is destroyed. 
        CleanupInstance releases all long strings and variants. It sets long strings to empty and variants to Unassigned."""
    def Create(self, *args, **kwargs) -> Any:
        """Constructs an object and initializes its data before the object is first used.
        Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
        Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.
        
        Note: If an exception escapes from a constructor, the object's destructor is called to clean up the failed instance."""
    def DefaultHandler(self, Message) -> None:
        """TObject.DefaultHandler(Message) -> None
        Provides the interface for a method that processes message records.
        DefaultHandler is called by Dispatch when it cannot find a method for a particular message. DefaultHandler provides message handling for all messages for which an object does not have specific handlers. Descendant classes that process messages override DefaultHandler according to the types of messages they handle. 
        
        Note:  In a Delphi message-handling method, calling inherited results in a call to the ancestor's DefaultHandler method only if that ancestor does not specify a message method for the particular message being handled. Otherwise, calling inherited results in a call to the specific handler for that type of message."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of an object instance.
        Do not call Destroy directly. Call Free instead. Free verifies that the object reference is not nil before calling Destroy. 
        The Destroy method defined by TObject deallocates memory. Descendent objects usually define a destructor that is customized for that particular kind of object. 
        When declaring a Destroy method in a descendant, always add the override directive to the declaration and call the inherited Destroy as the last statement in the overriding method. Because Destroy is a virtual method, overriding it ensures that the proper inherited behavior occurs. 
        
        Note:  If an exception escapes from the constructor, the destructor is called to destroy the partially constructed object instance that failed to initialize completely. Therefore, destructors should check that allocated resources such as handles were actually allocated before trying to release them, since their value might be zero. 
        Destroy should be implemented so that it calls Free on all subobjects created within the object's constructor (that is, allocated by the constructor). Unlike Destroy, Free provides a safeguard when destroying objects that are nil."""
    def Dispatch(self, Message) -> None:
        """TObject.Dispatch(Message) -> None
        Calls message-handling methods for the object, based on the contents of the Message parameter.
        Call Dispatch to automatically pass messages to the appropriate message handler. 
        Dispatch determines whether a message is in the list of message handlers declared for the object. If the object does not handle the message, Dispatch then examines the message-handler list of the ancestor class, and continues checking ancestors until it either finds a specific handler or runs out of ancestors, in which case it calls DefaultHandler. 
        The only assumption Dispatch makes about the data in Message is that the first two bytes contain a message ID?that is, an integer that determines which message handler Dispatch calls. Although any kind of data can be passed to Dispatch, most TObject descendants expect a message record such as TMessage or a specific data structure type."""
    def DisposeOf(self, *args, **kwargs) -> Any:
        """DisposeOf forces the execution of the destructor code in an object. 
        It was an artifact from previous versions when the Delphi Mobile compilers supported Automatic Reference Counting. In current versions of Delphi, DisposeOf is used as a wrapper that invokes TObject.Free. 
        
        type
          TMySimpleClass = class
          private
            stringMember: String;
            constructor Create(const Text: String);
            destructor Destroy;
          end;
        
        constructor TMySimpleClass.Create(const Text: String);
        begin
          stringMember := Text;
        end;
        
        destructor TMySimpleClass.Destroy;
        begin
          // this will be executed on calling the DisposeOf method.
        end;
        
        var
          myObject: TMySimpleClass;
        begin
          myObject := TMySimpleClass.Create('This is a code snippet indicating the usage of the DisposeOf method');
          try
            // Use 'myObject' here
          finally
            myObject.DisposeOf;
          end;
        end."""
    def Equals(self, Obj: Object) -> bool:
        """TObject.Equals(Obj: Object) -> bool
        Checks whether the current instance and the Obj parameter are equal.
        The function has one Obj parameter of the TObject type.
        By default, the Equals method shows whether the addresses corresponding to the current object and the Obj object are identical. The method returns a boolean value that represents the equality between the two addresses. 
        
        
        Note: Equals is supposed to be overridden in user-derived classes, to provide consumer objects with an equality determining function. 
        For example, in the FMX.Types.TBounds class, Equals also returns True if the Rect properties of the current object and of the Obj object are equal. In the FMX.StdActns.TBaseValueRange class, Equals also returns True if all the properties of the current object and of the Obj object are equal."""
    def FieldAddress(self, Name: str) -> Pointer:
        """TObject.FieldAddress(Name: str) -> Pointer
        Returns the address of a published object field.
        FieldAddress is used internally by the component streaming system to access a specified published field of an object. FieldAddress returns a pointer to the field, if it exists. If the object has no published field by that name, FieldAddress returns nil (Delphi) or NULL (C++). 
        Programs should access and manipulate fields by using properties instead of FieldAddress.\r
        Returns the address of a published object field.
        FieldAddress is used internally by the component streaming system to access a specified published field of an object. FieldAddress returns a pointer to the field, if it exists. If the object has no published field by that name, FieldAddress returns nil (Delphi) or NULL (C++). 
        Programs should access and manipulate fields by using properties instead of FieldAddress."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def FreeInstance(self, *args, **kwargs) -> Any:
        """Deallocates memory allocated by a previous call to the NewInstance method.
        All destructors call FreeInstance automatically to deallocate memory that was allocated by overriding NewInstance. 
        Do not call FreeInstance directly. FreeInstance should be overridden if NewInstance was overridden to change the way the object's instance data was allocated. 
        Like NewInstance, FreeInstance uses the value returned from InstanceSize to deallocate the object's memory."""
    def GetHashCode(self, *args, **kwargs) -> Any:
        """Returns an integer containing the hash code.
        By default, calling GetHashCode on an object returns an integer representing the virtual address at which the object is stored. 
        
        Notes:
        GetHashCode is supposed to be overridden in user-derived classes, to provide consumer objects with an integer hash code representation.
        The sign of the hash code depends on the address of the particular object instance. Negative hash code can appear for object instances that reside at higher memory locations."""
    def GetInterface(self, IID: GUID, Obj) -> bool:
        """TObject.GetInterface(IID: GUID, Obj) -> bool
        Retrieves a specified interface.
        GetInterface retrieves the interface designated by a GUID or type name. The basic implementation of GetInterface uses the GUID specified in the IID parameter. If the specified interface is supported by the class, it is returned in the Obj parameter, and GetInterface has a return value of True. Otherwise, Obj contains nil (Delphi) or NULL (C++), and GetInterface returns False. 
        
        Note:  In Delphi code, IID can be an interface name. The compiler automatically translates this name into the corresponding GUID. 
        Note:  In C++ code, use the templated version of GetInterface to obtain an interface from a DelphiInterface object. 
        GetInterface is equivalent to the as operator (Delphi) and dynamic casts (C++), except that GetInterface does not raise an exception if the interface is not supported."""
    @classmethod
    def GetInterfaceEntry(cls, IID: GUID) -> PInterfaceEntry:
        """TObject.GetInterfaceEntry(IID: GUID) -> PInterfaceEntry
        Returns the entry for a specific interface implemented in a class.
        GetInterfaceEntry returns the class entry for the interface specified by the IID parameter. 
        
        Note:  In Delphi Code, IID can be an interface name. The compiler replaces this name with the actual GUID. 
        Note:  COM objects can use GetInterfaceEntry to automate dispatch calls to a dual-IDispatch interface."""
    @classmethod
    def GetInterfaceTable(cls, *args, **kwargs) -> Any:
        """Returns a pointer to a structure containing all of the interfaces implemented by a given class.
        GetInterfaceTable returns the interface entries for the class. This list contains only interfaces implemented by this class, not its ancestors. To find the ancestor list, iteratively call ClassParent and then call GetInterfaceTable on the value it returns. To find the entry for a specific interface, use the GetInterfaceEntry method instead."""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    @classmethod
    def InitInstance(cls, Instance: Pointer) -> Object:
        """TObject.InitInstance(Instance: Pointer) -> Object
        Initializes a newly allocated object instance to all zeros and initializes the instance's virtual method table pointer.
        You should not call InitInstance directly. InitInstance is called by NewInstance when an object is created. When overriding NewInstance, be sure to call InitInstance as the last statement. 
        InitInstance is not virtual, so you cannot override it. Instead, initialize any data for an object in the constructor."""
    @classmethod
    def InstanceSize(cls, *args, **kwargs) -> Any:
        """Returns the size in bytes of each instance of the object type.
        InstanceSize indicates how many bytes of memory are required for a class's instance data. InstanceSize is called from methods that allocate and deallocate memory. InstanceSize is not a virtual method, so it cannot be overridden. InstanceSize should be called only when implementing a custom version of NewInstance."""
    @classmethod
    def MethodAddress(cls, Name: str) -> Pointer:
        """TObject.MethodAddress(Name: str) -> Pointer
        Returns the address of a class method by name.
        
        Note: You can use MethodAddress for published methods only.
        There are situations when it is useful to invoke an object method without hard coding the method name in advance. Call MethodAddress to dynamically retrieve the address of such a method by specifying the method Name as a string.
        An easy way to invoke the method is to define a procedure or function data type, such as:
        
        type TProc = procedure of object;
        
        Assign the object name and the MethodAddress method to a TMethod variable, such as: 
        
        MethodVar.Data?:= Pointer(ObjectInstanceName);
        MethodVar.Code?:= ObjectInstanceName.MethodAddress('MethodNameString');
        
        Pass this in a call to a variable of the procedure or function type:
        
        Proc?:= TProc(MethodVar);
        Proc;\r
        Returns the address of a class method by name.
        
        Note: You can use MethodAddress for published methods only.
        There are situations when it is useful to invoke an object method without hard coding the method name in advance. Call MethodAddress to dynamically retrieve the address of such a method by specifying the method Name as a string.
        An easy way to invoke the method is to define a procedure or function data type, such as:
        
        type TProc = procedure of object;
        
        Assign the object name and the MethodAddress method to a TMethod variable, such as: 
        
        MethodVar.Data?:= Pointer(ObjectInstanceName);
        MethodVar.Code?:= ObjectInstanceName.MethodAddress('MethodNameString');
        
        Pass this in a call to a variable of the procedure or function type:
        
        Proc?:= TProc(MethodVar);
        Proc;"""
    @classmethod
    def MethodName(cls, Address: Pointer) -> str:
        """TObject.MethodName(Address: Pointer) -> str
        Returns the name of a class method by address.
        There are situations when it is useful to invoke an object method without hard coding the method name in advance. Call MethodAddress to dynamically retrieve the address of such a method by specifying the method name as a string. 
        MethodName is the opposite of this process--by supplying an Address method, the name of the method is returned as a string."""
    @classmethod
    def NewInstance(cls, *args, **kwargs) -> Any:
        """Allocates memory for an instance of an object type and returns a pointer to that new instance.
        All constructors call NewInstance automatically. NewInstance calls InstanceSize to determine how much memory containing a particular instance to allocate from the heap. Do not call NewInstance directly. 
        Override NewInstance only for special memory allocation requirements. For example, when allocating a large number of identical objects that all need to be in memory at the same time, you can allocate a single block of memory for the entire group, then override NewInstance to use part of that larger block for each instance. 
        If you override NewInstance to allocate memory, you may need to override FreeInstance to deallocate the memory. 
        
        Note:  By default, NewInstance calls InitInstance."""
    @classmethod
    def QualifiedClassName(cls, *args, **kwargs) -> Any:
        """Returns the qualified name of the class.
        QualifiedClassName returns the class's unit scope concatenated with the class name. Example:
        
        uses
          SysUtils, SyncObjs;
        
        begin
          Writeln(TEvent.QualifiedClassName); // displays System.SyncObjs.TEvent"""
    def SafeCallException(self, ExceptObject: Object, ExceptAddr: Pointer) -> int:
        """TObject.SafeCallException(ExceptObject: Object, ExceptAddr: Pointer) -> int
        Handles exceptions in methods declared using the safecall calling convention.
        SafeCallException handles exceptions in methods that use the safecall calling convention. Some classes that implement interfaces override this method to handle possible errors. 
        As implemented in TObject, SafeCallException simply returns E_UNEXPECTED. This is the appropriate response for classes that do no support interfaces."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToString(self, *args, **kwargs) -> Any:
        '''Returns a string containing the class name.
        By default, the ToString returns a string containing the class name of the instance that is being called. 
        For example, calling ToString on a TButton instance returns a string containing "TButton". 
        
        Note: ToString is intended to be overridden in user-derived classes, to provide consumer objects with a string representation.'''
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    @classmethod
    def UnitName(cls, *args, **kwargs) -> Any:
        """Returns the name of the unit where the class is defined.
        UnitName can be used to obtain the unit where a specific class is defined. For example, calling UnitName on TButton returns the Vcl.StdCtrls string."""
    @classmethod
    def UnitScope(cls, *args, **kwargs) -> Any:
        """Returns the class's unit scope.
        The class's unit scope is currently equivalent with the class's unit name.
        
        uses
          SysUtils, SyncObjs;
        
        begin
          Writeln(TEvent.UnitScope); // displays System.SyncObjs
          // ..."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class OpenDialog(Component):
    """TOpenDialog displays a file-selection dialog.
    TOpenDialog displays a modal Windows dialog box for selecting and opening files. The dialog does not appear at runtime until it is activated by a call to the Execute method. When the user clicks Open, the dialog closes and the selected file or files are stored in the Files property."""
    __hash__: ClassVar[None] = ...
    DefaultExt: str
    """str: Specifies a default file extension.
        DefaultExt specifies a file extension that is appended automatically to the selected file name, unless the selected file name already includes a registered extension. If the user selects a file name with an extension that is unregistered, DefaultExt is appended to the unregistered extension.
        Extensions longer than three characters are not supported. Do not include the period (.) that divides the file name and its extension.
        
        Code Examples
        SavePictureDialog (Delphi)
        TApplicationIcon (Delphi)
        SavePictureDialog (C++)
        TApplicationIcon (C++)"""
    FileEditStyle: FileEditStyle
    """FileEditStyle: Determines the style of the file-selection dialog. (Obsolete.)
        FileEditStyle is maintained for compatibility with older versions of the VCL. It has no effect."""
    FileName: Any
    Files: Strings
    """Strings: List of selected file names.
        Files is a string list that contains each selected file name with its full directory path. (To let users select multiple file names, set the ofAllowMultiSelect flag in Options.) Use properties and methods for string lists to traverse this list of files and read individual items.
        The example below assigns the list of files in Files to the Items property of a TListBox component.
        
        
        
        ListBox1.Items.Assign(OpenDialog1.Files);
        
        
        
        
        ListBox1->Items->Assign(OpenDialog1->Files);"""
    Filter: str
    '''str: Determines the file masks (filters) available in the dialog.
        The file-selection dialog includes a drop-down list of file types under the edit box. When the user picks a file type from the list, only files of the selected type are displayed in the dialog.
        To configure file masks at design time, click on the ellipsis marks (...) to the right of the Filter property in the Object Inspector. This opens the Filter editor. In the left column of the Filter editor, under Filter Name, type a brief description of each file type that will be available at runtime. In the right column, under Filter, type the file mask corresponding to each description. For example, the description "Text files" might appear to the left of the mask "*.txt", and the description "Pascal source files" might appear to the left of the mask "*.pas". Since the description appears in the drop-down list at runtime, it is often helpful to show the mask explicitly in the description (for example, "Text files (*.txt)").
        To create file masks in program code, assign a value to the Filter property that consists of a description and a mask separated by a vertical bar (pipe) character. Do not include spaces around the vertical bar. For example,
        
        
        
        OpenDialog1.Filter := \'Text files (*.txt)|*.TXT\';
        
        
        
        
        OpenDialog1->Filter = "Text files (*.txt)|*.TXT";
        
        
        
        Multiple filters should be separated by vertical bars. For example,
        
        
        
        OpenDialog1.Filter := \'Text files (*.txt)|*.TXT|Pascal files (*.pas)|*.PAS\';
        
        
        
        
        OpenDialog1->Filter = "Text files (*.txt)|*.TXT|Pascal files (*.pas)|*.PAS";
        
        
        
        To include multiple masks in a single filter, separate the masks with semicolons. This works both in the Object Inspector and in program code. For example,
        
        
        
        OpenDialog1.Filter := \'Pascal files|*.PAS;*.DPK;*.DPR\';
        
        
        
        
        OpenDialog1->Filter = "Pascal files|*.PAS;*.DPK;*.DPR";
        
        
        
        If no value is assigned to Filter, the dialog displays all file types.'''
    FilterIndex: int
    """int: Determines which filter is selected by default when the dialog opens.
        FilterIndex determines which of the file types in Filter is selected by default when the dialog opens. Set FilterIndex to 1 to choose the first file type in the list as the default, or set FilterIndex to 2 to choose the second file type as the default, and so forth. If the value of FilterIndex is out or range, the first file type listed in Filter is the default."""
    HistoryList: Strings
    """Strings: Maintains a list of previously selected files. (Obsolete.)
        HistoryList is maintained for compatibility with older versions of TOpenDialog. It is not used."""
    InitialDir: str
    """str: Determines the current directory when the dialog opens.
        InitialDir determines the default directory displayed in the file-selection dialog when it opens. For example, to point the dialog at the WINDOWS\\SYSTEM directory, set the value of InitialDir to C:\\WINDOWS\\SYSTEM.
        If no value is assigned to InitialDir, or if the specified directory does not exist, the initial directory is controlled by the global ForceCurrentDirectory variable. If ForceCurrentDirectory is true, the dialog opens with the current working directory displayed. Otherwise, the dialog opens with either the current working directory or the My Documents directory, depending on the version of Windows."""
    OnCanClose: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnFolderChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnIncludeItem: Callable[[OFNotifyEx,bool],None]
    """Callable[[OFNotifyEx, bool], None]:"""
    OnSelectionChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnTypeChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Options: OpenOptions
    """OpenOptions: Determines the appearance and behavior of the file-selection dialog.
        Use the Options property to customize the appearance and functionality of the dialog."""
    OptionsEx: OpenOptionsEx
    """OpenOptionsEx: Augments the Options property with additional flags that determine the appearance and behavior of the file-selection dialog.
        Use the OptionsEx property to further customize the file open dialog beyond the options covered by the Options property."""
    Title: str
    '''str: Specifies the text in the dialog\'s title bar.
        Use Title to specify the text that appears in the file-selection dialog\'s title bar. If no value is assigned to Title, the dialog has the title "Open".
        
        Code Examples
        TOpenDialogTitle (Delphi)
        TOpenDialogTitle (C++)'''
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TOpenDialog.Create(AOwner: Component) -> None
        Creates and initializes a TOpenDialog instance.
        Create generates a TOpenDialog instance, but the new dialog does not appear on the form at runtime until the Execute method is called.
        AOwner is the component that is responsible for freeing the TOpenDialog instance. It becomes the value of the Owner property."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TOpenDialog and frees its memory.
        Do not call Destroy directly in an application. Call Free instead. Free verifies that the TOpenDialog reference is not nil before calling Destroy."""
    def Execute(self) -> Any:
        """TOpenDialog.Execute()
        Displays the dialog"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Page(CustomControl):
    """Specifies a page in a TNotebook control.
    The TPage class implements a page in a TNotebook control."""
    __hash__: ClassVar[None] = ...
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    OnAlignInsertBefore: Callable[[WinControl,Control,Control],bool]
    """Callable[[WinControl, Control, Control], bool]:"""
    OnAlignPosition: Callable[[WinControl,Control,int,int,int,int,Rect,AlignInfo],None]
    """Callable[[WinControl, Control, int, int, int, int, Rect, AlignInfo], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TPage.Create(AOwner: Component) -> None
        Creates an instance of TCustomControl.
        Vcl.ExtCtrls.TPage.Create inherits from Vcl.Controls.TCustomControl.Create. All content below this line refers to Vcl.Controls.TCustomControl.Create.
        Creates an instance of TCustomControl.
        Calling Create constructs and initializes an instance of TCustomControl. However, you should never attempt to instantiate a TCustomControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants. Controls placed on forms at design time are created automatically.
        After calling the inherited constructor, Create initializes the control and also a TCanvas object for its Canvas property.
        When overriding Create, always call the inherited Create method first, then proceed with the control's initialization. Remember to specify the override directive when overriding the Create method.
        
        Note: If a component's constructor allocates resources or memory, also override the destructor to free those resources."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PageControl(WinControl):
    """TPageControl is a set of pages used to make a multiple page dialog box.
    Use TPageControl to create a multiple page dialog or tabbed notebook. TPageControl displays multiple overlapping pages that are TTabSheet objects. The user selects a page by clicking the page's tab that appears at the top of the control. To add a new page to a TPageControl object at design time, right-click the TPageControl object and choose New Page.
    You can define an accelerator key to a page of the TPageControl. To define the accelerator key use the Caption property of the TTabSheet control. 
    To create a tabbed control that uses only a single body portion (page), use TTabControl instead.
    
    Note:  When using one of the page controls, if you want to restrict a user from switching to a tab, you cannot set TTabSheet.Enabled to false to accomplish that restriction. Instead, use the OnChanging event to prevent the user from selecting a tab."""
    __hash__: ClassVar[None] = ...
    ActivePage: Any
    """Specifies the page currently displayed by the page control."""
    ActivePageIndex: Any
    """Specifies the page currently displayed by the page control."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Canvas: Any
    """Gives access to the tab control canvas."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    DockSite: bool
    """bool: Specifies whether the control can be the target of drag-and-dock operations.
        Set DockSite to true to allow other controls to be docked to this windowed control.
        
        Code Examples
        Docking (Delphi)
        Docking (C++)"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    HotTrack: bool
    """bool: Determines whether labels on the tab under the mouse are automatically highlighted.
        Set HotTrack to true to provide visual feedback to the user about which tab would be selected if the mouse button is clicked. HotTrack is especially useful when the tab control contains multiple rows of tabs."""
    Images: CustomImageList
    """CustomImageList: Specifies the images drawn in tabs.
        Images specifies the images that are drawn in tabs. For disabled tabs, grayed versions of the images are used. 
        In the implementation of TCustomTabControl, the order of images in image list properties directly corresponds to the associated tabs in the control. In the descendant class, TPageControl, this behavior is replaced by support for individual  TTabSheet objects, each with an ImageIndex property. In any case, the application programmer can define customized image displays by defining an OnGetImageIndex event handler."""
    MultiLine: bool
    """bool: Determines whether the tabs can appear on more than one row.
        Use MultiLine to determine how the tabs are displayed. If MultiLine is true, the tabs are displayed on more than one row when the number of tabs exceeds the number that fits across the top of the tab control. How many rows is determined by how many tabs are in the tab control. If MultiLine is false, the tabs are displayed on one row only, and the user must scroll the displayed scroll arrows to view all the tabs."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChanging: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDockDrop: Callable[[Object,DragDockObject,int,int],None]
    """Callable[[Object, DragDockObject, int, int], None]:"""
    OnDockOver: Callable[[Object,DragDockObject,int,int,DragState,bool],None]
    """Callable[[Object, DragDockObject, int, int, DragState, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDrawTab: Callable[[CustomTabControl,int,Rect,bool],None]
    """Callable[[CustomTabControl, int, Rect, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetImageIndex: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnGetSiteInfo: Callable[[Object,Control,Rect,Point,bool],None]
    """Callable[[Object, Control, Rect, Point, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnUnDock: Callable[[Object,Control,WinControl,bool],None]
    """Callable[[Object, Control, WinControl, bool], None]:"""
    OwnerDraw: bool
    """bool: Specifies whether the tab control handles its own painting.
        Set OwnerDraw to true to override any default painting behavior."""
    PageCount: Any
    """Indicates the number of pages in the TPageControl object."""
    Pages: Any
    """Lists all the pages in the TPageControl."""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    RaggedRight: bool
    """bool: Specifies whether rows of tabs stretch to fill the width of the control.
        Use RaggedRight to get or set whether rows of tabs stretch to fill the width of the control."""
    RowCount: Any
    ScrollOpposite: bool
    """bool: Determines how the rows of tabs are scrolled in a multi-line tab control.
        Set ScrollOpposite to determine where previous rows of tabs in a multi-line tab control move when the user selects a tab in another row. When ScrollOpposite is true, previous rows of tabs are moved to the bottom of the tab control if TabPosition is tpTop, or to the top if TabPosition is tpBottom. When ScrollOpposite is false, previous rows of tabs are moved to the back of all other rows of tabs.
        For example, in a tab control with three rows of tabs at the top, if the user selects a tab in the second row, ScrollOpposite determines where the first row moves. If ScrollOpposite is true, the second row now appears at the front (bottom) row on top of the tab control, followed by the third row behind (above) it. The first row moves to the bottom of the tab control. If ScrollOpposite is false, the first row moves to the back (top), so that the tab control displays the second row in front (at the bottom of the tab region), followed by the third row (now in the middle), followed by the first row.
        
        Note:  Setting ScrollOpposite to true automatically sets the MultiLine property to true."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Style: TabStyle
    """TabStyle: Specifies the style of the tab control.
        Use Style to determine the appearance of the tabs. These can appear as notebook tabs or as buttons."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabHeight: int
    """int: Specifies the height, in pixels, of the tabs in the tab control.
        Set TabHeight to control the height of the tabs that appear above the client region of the tab control. The TabHeight property is the vertical size in pixels of the individual tabs. If TabHeight is set to 0, the tabs automatically size themselves to fit their text."""
    TabIndex: int
    """int: Identifies the selected tab on a tab control.
        Read TabIndex to determine which tab was selected by the user. TabIndex is the index of the tab in the list of labels maintained by the Tabs property. The first (leftmost) tab has a TabIndex of 0, the next has 1, and so on. If no tabs are selected, TabIndex has a value of -1.
        Set TabIndex to programmatically change the selected tab in the tab control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabPosition: TabPosition
    """TabPosition: Determines whether tabs appear at the top or bottom.
        Set TabPosition to tpTop to display the tabs at the top of the tab control. Set TabPosition to tpBottom to display the tabs at the bottom. If the ScrollOpposite property is True, tabs can appear at both top and bottom, with the row containing the current tab and all subsequent rows on the side indicated by TabPosition.
        Due to a limitation in the windows common control, if TabPosition is tpLeft or tpRight, Font must be a True Type font. Otherwise, tab text may paint incorrectly."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    TabWidth: int
    """int: Specifies the horizontal size, in pixels, of the tabs in the tab control.
        TabWidth specifies a fixed width for all tabs. If TabWidth is 0, then each tab is automatically made wide enough to show its caption."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TPageControl.Create(AOwner: Component) -> None
        Creates an instance of PageControl.
        Call Create to instantiate a page control at runtime. Page controls added to forms at design time are created automatically.
        AOwner is the form in which the page control should appear. It becomes the value of the Owner property.
        When creating a page control at runtime, the pages must be added programmatically. To add a page to a page control at runtime, create the TTabSheet object for the page and set its PageControl property."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TPageControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TPageControl reference is not nil, and only then calls Destroy. Destroy frees the TList object that holds the pages of the control, and then calls the inherited destructor."""
    def FindNextPage(self) -> Any:
        """TPageControl.FindNextPage()
        Returns the next page in the page control before or after a specified page."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TPageControl.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Calls a specified procedure for every page in the page control.
        Call GetChildren to execute a callback for every page in the page control. The Proc parameter is the callback. The Root parameter is ignored by TPageControl.
        GetChildren is intended primarily for the streaming system that loads and saves components."""
    def GetHitTestInfoAt(self) -> Any:
        """TPageControl.GetHitTestInfoAt()
        Returns information about the location of a point relative to the client area of the tab control."""
    def IndexOfTabAt(self) -> Any:
        """TPageControl.IndexOfTabAt()
        Indicates the index of the tab at a specified point."""
    def ScrollTabs(self) -> Any:
        """TPageControl.ScrollTabs()
        Scrolls the tabs that are visible when the tab control is not multi-line."""
    def SelectNextPage(self) -> Any:
        """TPageControl.SelectNextPage()
        Changes the ActivePage to the first visible page that is before or after the currently active page."""
    def TabRect(self) -> Any:
        """TPageControl.TabRect()
        Returns the bounding rectangle for a specified tab."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PaintBox(Control):
    """Wrapper for Delphi TPaintBox"""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    Canvas: Canvas
    """Canvas:"""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnPaint: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TPaintBox.Create(AOwner: Component) -> None
        Creates an instance of TControl.
        Calling Create constructs and initializes an instance of TControl. However, you should never attempt to instantiate a TControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants.
        Create calls the parent constructor and initializes the control. 
        When overriding Create, always call the inherited Create method first, then proceed with the control's initialization. Remember to specify the override directive when overriding the Create method.
        
        Note:  If a control's constructor allocates resources or memory, also override the destructor to free those resources."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Panel(CustomControl):
    """Wrapper for Delphi TPanel"""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: Alignment
    """Alignment:"""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BevelWidth: int
    """int: Specifies the width of the inner and outer bevels.
        Use BevelWidth to specify the width, in pixels, of the inner and outer bevels."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: BorderStyle
    """BorderStyle:"""
    BorderWidth: int
    """int: Specifies the width of the control's border.
        Use BorderWidth to get or set the width of the control's border. Graphics or text drawn by the control is clipped to the area within the border."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DockManager: IDockManager
    """IDockManager: Specifies the control's docking manager interface.
        Use DockManager to specify the control's docking manager. The docking manager handles the layout of docking zones (where controls are docked) and any painting associated with docking zones.
        If you set DockSite and UseDockManager to true, but do not assign a value to DockManager, the windowed control generates a default docking manager, using the global DefaultDockTreeClass variable."""
    DockSite: bool
    """bool: Specifies whether the control can be the target of drag-and-dock operations.
        Set DockSite to true to allow other controls to be docked to this windowed control.
        
        Code Examples
        Docking (Delphi)
        Docking (C++)"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    FullRepaint: bool
    """bool:"""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    Locked: bool
    """bool:"""
    OnAlignInsertBefore: Callable[[WinControl,Control,Control],bool]
    """Callable[[WinControl, Control, Control], bool]:"""
    OnAlignPosition: Callable[[WinControl,Control,int,int,int,int,Rect,AlignInfo],None]
    """Callable[[WinControl, Control, int, int, int, int, Rect, AlignInfo], None]:"""
    OnCanResize: Callable[[Object,int,int,bool],None]
    """Callable[[Object, int, int, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnConstrainedResize: Callable[[Object,int,int,int,int],None]
    """Callable[[Object, int, int, int, int], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDockDrop: Callable[[Object,DragDockObject,int,int],None]
    """Callable[[Object, DragDockObject, int, int], None]:"""
    OnDockOver: Callable[[Object,DragDockObject,int,int,DragState,bool],None]
    """Callable[[Object, DragDockObject, int, int, DragState, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetSiteInfo: Callable[[Object,Control,Rect,Point,bool],None]
    """Callable[[Object, Control, Rect, Point, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnUnDock: Callable[[Object,Control,WinControl,bool],None]
    """Callable[[Object, Control, WinControl, bool], None]:"""
    Padding: Padding
    """Padding: Specifies the padding of a control.
        Use Padding to specify the padding of a control. This value is an instance of the class TPadding."""
    ParentBackground: bool
    """bool: Determines whether the control uses its parent's theme background.
        If ParentBackground is True, the control uses the parent's theme background to draw its own background. 
        If  ParentBackground is False, the control uses its own properties, such as Color, to draw its background.
        ParentBackground has no effect unless XP themes are enabled."""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowCaption: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    UseDockManager: bool
    """bool: Specifies whether the docking manager is used in drag-and-dock operations.
        Use UseDockManager to get or set whether a docking manager is used in drag-and-dock operations. 
        The docking manager handles the positioning of docked controls and any painting of docking zones around those controls. If you do not use a docking manager, docked controls are aligned to the windowed control based on the closest edge to where they are released. When you do not use a docking manager, there is no region for a user to grab to automatically undock a docked control."""
    VerticalAlignment: VerticalAlignment
    """VerticalAlignment:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PascalInterface:
    """Wrapper of a Pascal record"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PascalRecord:
    """Wrapper of a Pascal record"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Persistent(Object):
    """TPersistent is the ancestor for all objects that have assignment and streaming capabilities.
    TPersistent encapsulates the behavior common to all objects that can be assigned to other objects, and that can read and write their properties to and from a form file (.xfm or .dfm file). For this purpose, TPersistent introduces methods that can be overridden to:
    
    Define the procedure for loading and storing unpublished data to a stream.
    Provide the means to assign values to properties.
    Provide the means to assign the contents of one object to another.
    Do not create instances of TPersistent. Use TPersistent as a base class when declaring objects that are not components, but that need to be saved to a stream or have their properties assigned to other objects."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, persistent) -> Any:
        """TPersistent.Assign(persistent)
        Assigns to this object the values of another TPersistent object"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TPersistent instance and frees its memory.
        Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy."""
    def GetNamePath(self) -> Any:
        """TPersistent.GetNamePath()
        Returns the name of the object as it appears in the Object Inspector."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Picture(Persistent):
    """TPicture contains a bitmap, icon, metafile graphic, or user-defined graphic.
    TPicture is a TGraphic container, used to hold a graphic, the type of which is specified in the Graphic property. It is used in place of a TGraphic if the graphic can be of any TGraphic class. LoadFromFile and SaveToFile are polymorphic. For example, if the TPicture is holding an Icon, it is valid to LoadFromFile a bitmap file, where the class TIcon can only read .ICO files.
    If the TPicture contains a bitmap graphic, the Bitmap property specifies the graphic. If the TPicture contains an icon graphic, the Icon property specifies the graphic. If the TPicture contains a metafile graphic, the Metafile property specifies the graphic.
    The properties of TPicture indicate the type of graphic that the picture object contains, and its size. The methods of TPicture are used to load, save, and manipulate graphics.
    To load or save a picture to the Clipboard, use the Assign method of a TClipboard object.
    To draw a picture on a canvas, call the Draw or StretchDraw methods of a TCanvas object, passing the Graphic property of a TPicture as a parameter."""
    __hash__: ClassVar[None] = ...
    Bitmap: Any
    Graphic: Any
    Height: Any
    Icon: Any
    Metafile: Any
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnFindGraphicClass: Callable[[Object,FindGraphicClassContext,GraphicClass],None]
    """Callable[[Object, FindGraphicClassContext, GraphicClass], None]:"""
    OnProgress: Callable[[Object,ProgressStage,int,bool,Rect,str],None]
    """Callable[[Object, ProgressStage, int, bool, Rect, str], None]:"""
    PictureAdapter: IChangeNotifier
    """IChangeNotifier: Represents an OLE interface for the picture.
        PictureAdapter is for internal use only."""
    WICImage: WICImage
    """WICImage: Embarcadero Technologies does not currently have any additional information."""
    Width: Any
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Assign(self, Source: Persistent) -> None:
        """TPicture.Assign(Source: Persistent) -> None
        Copies one object to another by copying the contents of that object to the other.
        When Source is a object type that is valid for the Graphic property, Assign makes that graphic the value of the Graphic property.
        The actions performed by Assign depend on the actual types of the TPicture Graphic property and Source. For example, if the Graphic property and Source are bitmaps (TBitmap), the bitmap contained in Source is copied into the Graphic property. Similar conversions are valid, for example, for TIcon or TMetafile.
        If the Source parameter is not a valid object for the Graphic property, Assign calls the inherited method so that the picture can be copied from any object with which it is compatible."""
    def Create(self, *args, **kwargs) -> Any:
        """Creates a TPicture object.
        Call Create to create an instance of TPicture at runtime. Create allocates the memory for the picture object and initializes its internal formats. After creating the TPicture object, use the LoadFromClipboardFormat or LoadFromFile method to assign a graphical image to the picture, so that it is available to the application."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of a picture object.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TPicture reference is not nil before it calls Destroy.
        Destroy frees the graphic image it contains before calling the inherited Destroy."""
    def LoadFromClipboardFormat(self, AFormat: int, AData: int, APalette: int) -> None:
        """TPicture.LoadFromClipboardFormat(AFormat: int, AData: int, APalette: int) -> None
        Reads the picture from the handle provided in the given Clipboard format.
        Use LoadFromClipboardFormat to read in a graphic from the Clipboard. If the format is not supported, an EInvalidGraphic exception is raised.
        The following code snippet shows how to load a picture from the clipboard into a TImage control.
        
        Note: To load a picture into the clipboard, you can use the code snippet for the SaveToClipboardFormat method.
        
        Delphi:
        
        uses
          Vcl.Clipbrd;
        
        procedure TForm1.Button1Click(Sender: TObject);
        var
          Picture: TPicture;
        begin
         Picture := TPicture.Create;
         try
           Picture.LoadFromClipboardFormat(cf_BitMap, ClipBoard.GetAsHandle(cf_Bitmap), 0);
           Image1.Picture := Picture;
         finally
           Picture.Free;
           Clipboard.Clear;
         end;
        end;
        
        
        
        C++:
        
        #include <Vcl.Clipbrd.hpp>
        
        void __fastcall TForm1::Button1Click(TObject *Sender){
        \tTPicture* Picture;
        \tTClipboard* cb = Clipboard();
        
        \tPicture = new TPicture();
        \ttry{
        \t\tPicture->LoadFromClipboardFormat(CF_BITMAP, cb->GetAsHandle(CF_BITMAP), 0);
        \t\tImage1->Picture = Picture;
        \t}
        \t__finally{
        \t\tdelete Picture;
        \t\tcb->Clear();
        \t}
        }"""
    def LoadFromFile(self) -> Any:
        """TPicture.LoadFromFile()"""
    def LoadFromStream(self, Stream: Stream) -> None:
        """TPicture.LoadFromStream(Stream: Stream) -> None
        Reads the picture from a Stream.
        Use LoadFromStream to read a picture from a TStream object. The TGraphic class created is determined by the type of data contained in the stream.
        The data in the stream should be previously written by a call to the SaveToStream method of another TPicture or of a TGraphic descendant."""
    @classmethod
    def RegisterClipboardFormat(cls, AFormat: int, AGraphicClass: GraphicClass) -> None:
        """TPicture.RegisterClipboardFormat(AFormat: int, AGraphicClass: GraphicClass) -> None
        Registers a new TGraphic class for use in the LoadFromClipboardFormat method.
        Use RegisterClipboardFormat register a new graphic format with TPicture so that it can be used with the LoadFromClipboardFormat method."""
    @classmethod
    def RegisterFileFormat(cls, AExtension: str, ADescription: str, AGraphicClass: GraphicClass) -> None:
        '''TPicture.RegisterFileFormat(AExtension: str, ADescription: str, AGraphicClass: GraphicClass) -> None
        Registers a new TGraphic class for use in LoadFromFile.
        Use RegisterFileFormat to register a graphic file format with TPicture so that it can be used with a Open or Save dialog box.
        The AExtension parameter specifies the three-character system file extension to associate with the graphic class (for example, "bmp" is associated with TBitmap). The ADescription parameter specifies the description of the graphic to appear in the drop down list of the dialog box (for example, "Bitmaps" is the description of TBitmap). The AGraphicClass parameter registers the new graphic class to associate with the file format.'''
    @classmethod
    def RegisterFileFormatRes(cls, AExtension: str, ADescriptionResID: int, AGraphicClass: GraphicClass) -> None:
        '''TPicture.RegisterFileFormatRes(AExtension: str, ADescriptionResID: int, AGraphicClass: GraphicClass) -> None
        Registers a new TGraphic class for use in the LoadFromFile method.
        Use RegisterFileFormatRes by specifying a string resource.
        The AExtension parameter specifies the three-character system file extension to associate with the graphic class (for example, "bmp" is associated with TBitmap).
        The ADescriptionResID parameter specifies the resource ID for a description of the graphic, which then appears in the drop down list of the dialog box (for example, "Bitmaps" is the description of TBitmap).
        The AGraphicClass parameter registers the new graphic class to associate with the file format.'''
    def SaveToClipboardFormat(self, AFormat: int, AData: int, APalette: int) -> None:
        '''TPicture.SaveToClipboardFormat(AFormat: int, AData: int, APalette: int) -> None
        Allocates a global handle and writes the picture in its native Clipboard format (CF_BITMAP for bitmaps, CF_METAFILE for metafiles, and so on).
        Use SaveToClipboardFormat to copy the picture to a Clipboard format. The resulting values can then be copied to the Windows clipboard using the clipboard\'s SetAsHandle method.
        The palette of the picture is returned in the APalette parameter, the format in the AFormat parameter, and a handle to the data in the AData parameter. Before the picture can be saved, an application must have registered the format using the RegisterClipboardFormat method.
        The following code snippet shows how to save a bitmap to the clipboard.
        
        Note: To load a bitmap from the clipboard, you can use the code snippet for the LoadFromClipboardFormat method.
        
        Delphi:
        
        uses
          Vcl.Clipbrd;
        
        procedure TForm1.Button1Click(Sender: TObject);
        var
          MyFormat : Word;
          Picture : TPicture;
          AData : THandle;
          APalette : HPALETTE;
        begin
          Picture := TPicture.Create;
          try
            Picture.LoadFromFile(\'C:\\Users\\Public\\Pictures\\Sample Pictures\\desert.bmp\');
            Picture.SaveToClipBoardFormat(MyFormat, AData, APalette);
            ClipBoard.SetAsHandle(MyFormat,AData);
          finally
            Picture.Free;
          end;
        end;
        
        
        
        C++:
        
        #include <Vcl.Clipbrd.hpp>
        
        void __fastcall TForm1::Button1Click(TObject *Sender){
        \tTClipboard* cb = Clipboard();
        \tunsigned short MyFormat;
        \tTPicture* Picture;
        \tunsigned int AData;
        \tHPALETTE APalette;
        
        \tPicture = new TPicture();
        \ttry{
        \t\tPicture->LoadFromFile("C:\\\\Users\\\\Public\\\\Pictures\\\\Sample Pictures\\\\desert.bmp");
        \t\tPicture->SaveToClipboardFormat(MyFormat, AData, APalette);
        \t\tcb->SetAsHandle(MyFormat, AData);
        \t}
        \t__finally{
        \t\tdelete Picture;
        \t}
        }'''
    def SaveToFile(self) -> Any:
        """TPicture.SaveToFile()"""
    def SaveToStream(self, Stream: Stream) -> None:
        """TPicture.SaveToStream(Stream: Stream) -> None
        Saves the picture to a stream.
        Use SaveToStream to save a picture to the TStream object specified by the Stream parameter. 
        The saved picture can be loaded to another TPicture or to an appropriate TGraphic descendant by calling its LoadFromStream method."""
    @classmethod
    def SupportsClipboardFormat(cls, AFormat: int) -> bool:
        """TPicture.SupportsClipboardFormat(AFormat: int) -> bool
        Indicates if the given Clipboard format is supported by the LoadFromClipboardFormat method.
        If the LoadFromClipboardFormat method supports the Clipboard format specified as the value of AFormat, SupportsClipboardFormat returns true. If the format is not supported, the method returns false."""
    @classmethod
    def UnregisterGraphicClass(cls, AClass: GraphicClass) -> None:
        """TPicture.UnregisterGraphicClass(AClass: GraphicClass) -> None
        Removes all references to the specified TGraphic class and all its descendants from the internal lists of file formats and clipboard formats.
        Call UnregisterGraphicClass to make a graphic class unavailable to all picture objects. UnregisterGraphicClass reverses the registration accomplished by the RegisterFileFormat, or RegisterFileFormatRes, or RegisterClipboardFormat method. When a graphic class is registered, the global GraphicFilter, GraphicExtension, and GraphicFileMask functions can return dialog filter strings, default file extensions or file filters for the graphic class. Call UnregisterGraphicClass when these values should not be available. For example, component writers who implement custom graphic classes unregister those classes according to the language used. In Delphi, the classes are unregistered in the finalization block of the unit that implements them and, in C++, the classes are unregistered using the #pragma exit directive (C++). 
        File formats and clipboard formats for the custom class are registered in the initialization block (Delphi) or using #pragma startup (C++)."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Point:
    """wrapper for Delphi TPoint type"""
    __hash__: ClassVar[None] = ...
    X: Any
    """Provides access to the X coordinate of a point"""
    Y: Any
    """Provides access to the Y coordinate of a point"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PopupMenu(Menu):
    """TPopupMenu encapsulates the properties, methods, and events of a pop-up menu.
    Use TPopupMenu to define the pop-up menu that appears when the user clicks on a control with the right mouse button. To make a pop-up menu available, assign the TPopupMenu object to the control's PopupMenu property.
    
    Tip:  To create a popup menu that users can configure at runtime, use the TStandardMenuPopup component with an action manager instead.
    Note:  If the popup menu's ParentBiDiMode is true, the popup menu's BiDiMode is set to the BiDiMode of the control that activates it. If a control cannot be found, the BiDiMode is set to the value of the Application object's BiDiMode. The popup menu's BiDiMode affects all of its menu items."""
    __hash__: ClassVar[None] = ...
    Alignment: PopupAlignment
    """PopupAlignment: Determines where the pop-up menu appears when the user clicks the right mouse button.
        Set Alignment to control the placement of the popup menu. Alignment controls whether the menu appears to the left of the mouse, to the right of the mouse, or centered over the mouse.
        By default, the menu appears with its top left corner under the mouse (paLeft)."""
    AutoHotkeys: MenuAutoFlag
    """MenuAutoFlag: Determines whether the accelerator keys for menu items can be reset automatically.
        Set AutoHotkeys to indicate whether the menu should automatically ensure that accelerator keys for its items are reset if necessary so that every menu item has an accelerator key and no two items have the same accelerator key. This ensures that menu items added dynamically at runtime can have accelerator keys that do not introduce conflicts. TMenu tries to preserve all existing accelerator key mappings when adjusting the accelerator keys, but may be forced to change some in order to ensure that every item has a unique accelerator.
        Before the menu is displayed, the menu checks and adjusts the accelerator key mappings if AutoHotkeys is maAutomatic. When AutoHotkeys is maManual, the menu does not alter the top-level menu items, but may adjust the accelerator keys for submenus, depending on the AutoHotkeys property of the menu item that is the parent of the submenu.
        When AutoHotkeys is maManual, an application can still adjust the menu items by calling the Items property's RethinkHotkeys method. AutoHotkeys merely controls whether this adjustment occurs automatically.
        
        Note:  The AutoHotkeys property of a menu is linked to the AutoHotkeys property of the TMenuItems object that implements its Items property. Setting one sets the other."""
    AutoLineReduction: MenuAutoFlag
    """MenuAutoFlag: Determines whether redundant separator bars are automatically removed from the menu.
        Set AutoLineReduction to indicate whether the menu should automatically ensure that the menu does not start or end with a separator bar and that two separator bars do not appear next to each other. This ensures that menus built dynamically at runtime do not have separator bars in undesired positions.
        Before the menu is displayed, it removes superfluous separator bars when AutoLineReduction is maAutomatic. When AutoLineReduction is maManual, the menu does not remove separators from the top-level menu items, but may remove superfluous separators from submenus, depending on the AutoLineReduction property of the menu item that is the parent of the submenu.
        When AutoLineReduction is maManual, an application can still remove superfluous separators by calling the Items property's RethinkLines method. AutoLineReduction merely determines whether this adjustment occurs automatically.
        
        Note:  The AutoLineReduction property of a menu is linked to the AutoLineReduction property of the TMenuItems object that implements its Items property. Setting one sets the other."""
    AutoPopup: bool
    """bool: Determines whether the pop-up menu appears automatically when the user clicks the right mouse button.
        Set AutoPopup to true to cause the pop-up menu to appear automatically when the user clicks the right mouse button on a control that has the pop-up menu specified as its PopupMenu property. The application key present on keyboards specifically designed for 32-bit Windows will also show this menu when pressed.
        Set AutoPopup to false if the appearance of the pop-up menu should be controlled programmatically. To display a pop-up menu when AutoPopup is false, use the Popup method."""
    BiDiMode: BiDiMode
    """BiDiMode: Determines the layout of the menu in Middle East locales.
        Set BiDiMode to control the layout of menu items. BiDiMode controls whether the menu items read from left to right or right to left."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    HelpContext: int
    """int: Specifies a context ID for the entire pop-up menu.
        Use HelpContext to associate a help screen with the entire pop-up menu. Each screen in the Help system should have a unique context ID. When a component is selected in the application, pressing F1 displays the Help screen associated with the value of HelpContext.
        To associate a help screen with the individual items in the pop-up menu, use the HelpContext property of the associated TMenuItem objects."""
    Images: CustomImageList
    """CustomImageList: Lists the images that can appear beside individual menu items.
        Use Images to hold the set of images that can appear beside menu items in the menu. Individual menu items set their ImageIndex property to indicate which image in the list appears to the left of the menu item caption.
        Images in the list should be 16x16.
        
        Tip:  If the application uses action lists, this property should be the value of the action list's Images property. This way, menu items and buttons that do the same thing can display the same image."""
    MenuAnimation: MenuAnimation
    """MenuAnimation: Specifies how the menu appears when it is first displayed.
        Use MenuAnimation to specify how the popup menu appears on the screen. The menu can simply appear as a whole, or can slide into view like a window shade being drawn from any edge.
        
        Note: MenuAnimation only has an effect when running on Windows 98, NT 5.0, or later."""
    OnChange: Callable[[Object,MenuItem,bool],None]
    """Callable[[Object, MenuItem, bool], None]:"""
    OnClose: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnPopup: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    OwnerDraw: bool
    """bool: Specifies whether the menu items are drawn by the application.
        Set OwnerDraw to true to indicate that the application will draw menu items in an OnDrawItem event handler. When OwnerDraw is true, menu items receive an OnMeasureItem and an OnDrawItem event when they need to be rendered on screen.
        Set OwnerDraw to false to accept the default drawing. When OwnerDraw is false, menu items display the caption with an optional image to the left (If the Images and ImageIndex properties are set).
        Owner-draw menus are useful for displaying the value that appears when selecting a menu item. For example, in a menu that allows users to choose a color, an owner-draw menu could display rectangles drawn in the designated color, rather than color names."""
    ParentBiDiMode: bool
    """bool: Indicates whether the BiDiMode property is inherited from the control that uses the menu.
        By default, ParentBiDiMode is true, indicating that the layout of menu items follows the BiDiMode setting of the associated form or control. Change ParentBiDiMode to false to override the default BiDiMode setting and control the menu's layout independently."""
    PopupComponent: Component
    """Component: Indicates the component that last displayed the popup menu in response to a right mouse click.
        Read PopupComponent to determine which control is currently using the popup menu. In applications where multiple controls share the same pop-up menu, use PopupComponent to determine which of them displayed the menu.
        Set PopupComponent to associate a control with the menu before calling the Popup method programmatically to bring up the pop-up menu."""
    PopupPoint: Point
    """Point: Indicates the location where the pop-up menu appears.
        This public property is used internally to locate the popup menu. Its value is set by the Popup method."""
    TrackButton: TrackButton
    """TrackButton: Specifies which mouse button activates the popup menu when it is associated with a toolbar button.
        Use TrackButton to specify which mouse button activates the popup menu when it is associated with a toolbar button."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def CloseMenu(self, *args, **kwargs) -> Any:
        """Closes the pop-up menu onscreen.
        Call CloseMenu to close the pop-up menu."""
    def Create(self, AOwner: Component) -> None:
        """TPopupMenu.Create(AOwner: Component) -> None
        Creates an instance of TPopupMenu.
        Call Create to create to create a pop-up menu at runtime. Pop-up menus placed in forms or data modules at design time are created automatically."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TPopupMenu.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TPopupMenu reference is not nil, and only then calls Destroy."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def Popup(self, X: int, Y: int) -> None:
        """TPopupMenu.Popup(X: int, Y: int) -> None
        Displays the pop-up menu onscreen.
        Call Popup to bring up the pop-up menu. The menu appears at the screen coordinates indicated by the values (in pixels) of X and Y."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class PrototypeBindSource(CustomPrototypeBindSource):
    """Is a bind source for creating sample data.
    If you want to create your own custom prototype bind source, then you should derive your class from TCustomPrototypeBindSource. When designing applications that make use of the LiveBindings framework, you can use a TPrototypeBindSource component readily available in the Tool Palette to generate sample data for your bindings.
    These tutorials in the Tutorials section describe the use of TPrototypeBindSource:
    
    Tutorial: Using TPrototypeBindSource and the LiveBindings Designer
    Mobile Tutorial: Using LiveBindings to Populate a ListView (iOS and Android)
    Tutorial: Using LiveBindings and DataModules with the Metropolis UI
    Mobile Tutorial: Using LiveBindings to Populate a ListBox in Mobile Applications (iOS and Android)"""
    __hash__: ClassVar[None] = ...
    AutoActivate: bool
    """bool: Specifies whether the bind source is automatically activated.  Set AutoActive to True for automatic activation."""
    AutoEdit: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    AutoPost: bool
    """bool: Embarcadero Technologies does not currently have any additional information."""
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    FieldDefs: GeneratorFieldDefs
    """GeneratorFieldDefs: Embarcadero Technologies does not currently have any additional information."""
    OnCreateAdapter: Callable[[Object,BindSourceAdapter],None]
    """Callable[[Object, BindSourceAdapter], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    RecordCount: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    ScopeMappings: ScopeMappings
    """ScopeMappings: Specifies an owned collection of scope mappings.
        The ScopeMappings property specifies an owned collection whose elements are scope mappings. ScopeMappings are used to add name/value pairs that can be referenced by expressions that reference this source component."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class RadioButton(WinControl):
    """TRadioButton is a wrapper for a system radio button.
    Use TRadioButton to add a radio button to a form. Radio buttons present a set of mutually exclusive options to the user- that is, only one radio button in a set can be selected at a time. When the user selects a radio button, the previously selected radio button becomes unselected. Radio buttons are frequently grouped in a radio group box (TGroupBox). Add the group box to the form first, then get the radio buttons from the Component palette and put them into the group box. Or you can add a TRadioGroup, a group that already has radio buttons in it, so that you do not have to get the buttons from the Tool Palette.
    By default, all radio buttons that are directly contained in the same windowed control container, such as a TRadioGroup or TPanel, are grouped. For example, two radio buttons on a form can be checked at the same time only if they are contained in separate containers, such as two different group boxes.
    The Caption property can be used to define an accelerator key to the control."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: LeftRight
    """LeftRight: Determines the position of the caption relative to the radio button.
        Set Alignment to determine whether the caption of the radio button should appear to the left of the radio button (taLeftJustify) or to the right of the radio button (taRightJustify).
        
        Note:  Do not confuse the Alignment property with the alignment of the caption in the text area of the radio button. The caption always appears left aligned. Alignment only controls on which side of the button the text area appears."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Checked: bool
    """bool:"""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    WordWrap: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TRadioButton.Create(AOwner: Component) -> None
        Creates an instance of TRadioButton.
        Call Create to instantiate a radio button at runtime. Radio buttons added to forms at design time are created automatically.
        AOwner is the component, typically a form, that becomes the value of the Owner property. The Owner is responsible for freeing the radio button object."""
    def GetControlsAlignment(self, *args, **kwargs) -> Any:
        """Returns the alignment of any text in the control.
        Use GetControlsAlignment to determine the orientation of text in controls that do not have an Alignment property.
        GetControlsAlignment overrides the inherited method, returning taRightJustify if UseRightToLeftAlignment returns false. If UseRightToLeftAlignment returns true, GetControlsAlignment returns the opposite of the Alignment property."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class RadioGroup(CustomControl):
    '''TRadioGroup represents a group of radio buttons that function together.
    A TRadioGroup object is a special group box that contains only radio buttons. Radio buttons that are placed directly in the same control component are said to be "grouped." When the user checks a radio button, all other radio buttons in its group become unchecked. Hence, two radio buttons on a form can be checked at the same time only if they are placed in separate containers, such as group boxes.
    To add radio buttons to a TRadioGroup, edit the Items property in the Object Inspector. Each string in Items makes a radio button appear in the group box with the string as its caption. The value of the ItemIndex property determines which radio button is currently selected.
    Display the radio buttons in a single column or in multiple columns by setting the Columns property.
    
    Note:  Setting the radio group\'s BiDiMode to bdRightToLeft automatically flips its radio buttons. The FlipChildren method has no effect.'''
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Columns: int
    """int:"""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DefaultHeaderFont: bool
    """bool:"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HeaderFont: Font
    """Font:"""
    ItemIndex: int
    """int:"""
    Items: Strings
    """Strings:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBackground: bool
    """bool: Determines whether the control uses its parent's theme background.
        If ParentBackground is True, the control uses the parent's theme background to draw its own background. 
        If  ParentBackground is False, the control uses its own properties, such as Color, to draw its background.
        ParentBackground has no effect unless XP themes are enabled."""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    RadioTabStop: bool
    """bool:"""
    ShowFrame: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    WordWrap: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Rect:
    """wrapper for Delphi TRect type"""
    __hash__: ClassVar[None] = ...
    Bottom: Any
    """Provides access to the Bottom coordinate of a rectangle"""
    BottomRight: Any
    """Provides access to the BottomRight coordinate of a rectangle"""
    Left: Any
    """Provides access to the Left coordinate of a rectangle"""
    Right: Any
    """Provides access to the Right coordinate of a rectangle"""
    Top: Any
    """Provides access to the Top coordinate of a rectangle"""
    TopLeft: Any
    """Provides access to the TopLeft coordinate of a rectangle"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ResourceStream(CustomMemoryStream):
    """TResourceStream is a memory stream that provides access to the compiled resources in an application.
    Use TResourceStream to read the resources of an application. An instance of TResourceStream holds the value of a single resource in a memory buffer where it is accessible to the application.
    The global ReadComponentRes function uses TResourceStream to access the compiled resources used by the application."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, Instance: int, ResName: str, ResType: PWideChar) -> None:
        """TResourceStream.Create(Instance: int, ResName: str, ResType: PWideChar) -> None
        Creates an instance of TResourceStream associated with a particular resource name and type.
        Call Create to instantiate a TResourceStream, passing in parameters that identify the resource in a specified instance. TResourceStream finds the resource data and loads it into the Memory buffer for the TResourceStream.
        The Instance parameter is the instance handle associated with the executable or shared library that contains the resource.
        In the first constructor syntax, the ResName is the string associated with the resource in the .rc file that was compiled with the application. If the resource is associated with an integer ID rather than a string, use the string representation of the integer after a pound sign. Thus, for example, a resource with an integer identifier of 128 be identified by a ResName of #128.
        
        Note:  Specifying resources by ID requires less memory than specifying resources by name.
        The ResType parameter is a string identifying the type of the resource. Applications can define their own resource types and identify them by name in the .rc file. In addition, there are a number of predefined resource types (which reflect Windows resource types). To identify a resource that is one of the predefined resource types, set ResType to the appropriate value from the following table:
        
        
        
        
        
        ResType
        
        Type of resource
        
        
        
        RT_ACCELERATOR
        
        
        
        Accelerator table
        
        
        
        
        RT_BITMAP
        
        
        
        Bitmap resource
        
        
        
        
        RT_DIALOG
        
        
        
        Dialog box
        
        
        
        
        RT_FONT
        
        
        
        Font resource
        
        
        
        
        RT_FONTDIR
        
        
        
        Font directory resource
        
        
        
        
        RT_MENU
        
        
        
        Menu resource
        
        
        
        
        RT_RCDATA
        
        
        
        Application-defined resource (raw data)
        
        
        
        
        RT_STRING
        
        
        
        String-table entry
        
        
        
        
        RT_MESSAGETABLE
        
        
        
        Message-table entry
        
        
        
        
        RT_CURSOR
        
        
        
        Hardware-dependent cursor resource
        
        
        
        
        RT_GROUP_CURSOR
        
        
        
        Hardware-independent cursor resource
        
        
        
        
        RT_ICON
        
        
        
        Hardware-dependent icon resource
        
        
        
        
        RT_GROUP_ICON
        
        
        
        Hardware-independent icon resource
        
        
        
        
        RT_VERSION
        
        
        
        Version resource"""
    def CreateFromID(self, Instance: int, ResID: int, ResType: PWideChar) -> None:
        """TResourceStream.CreateFromID(Instance: int, ResID: int, ResType: PWideChar) -> None"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TResourceStream.
        Do not call Destroy directly in an application to destroy an instance of TResourceStream. Instead, call Free. Free verifies that the TResourceStream reference is not nil, and only then calls Destroy.
        Destroy frees the memory buffer that stores the resource before calling the inherited destructor."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """TResourceStream.Write(Buffer, Count: int) -> int
        Overrides the inherited method to raise an exception when an attempt is made to write the resource back to the application.
        Applications should not use a TResourceStream to write the resources of the running application. Write overrides the inherited method to raise an EStreamError exception when an application tries to write to the application's resources.
        As all other data-writing methods of TResourceStream (WriteBuffer, WriteComponent) call Write to do the actual writing, calling any of the data-writing methods of TResourceStream will raise an exception."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SaveDialog(OpenDialog):
    '''TSaveDialog displays a "Save As" dialog for saving files.
    TSaveDialog displays a modal Windows dialog box for selecting file names and saving files. The dialog does not appear at runtime until it is activated by a call to the Execute method. When the user clicks Save, the dialog closes and the selected file name is stored in the FileName property.'''
    __hash__: ClassVar[None] = ...
    FileName: Any
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Execute(self) -> Any:
        """TOpenDialog.Execute()
        Displays the dialog"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ScrollBar(WinControl):
    """Wrapper for Delphi TScrollBar"""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    Kind: ScrollBarKind
    """ScrollBarKind:"""
    LargeChange: int
    """int:"""
    Max: int
    """int:"""
    Min: int
    """int:"""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnScroll: Callable[[Object,ScrollCode,int],None]
    """Callable[[Object, ScrollCode, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    PageSize: int
    """int:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    Position: int
    """int:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    SmallChange: int
    """int:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TScrollBar.Create(AOwner: Component) -> None
        Creates an instance of TWinControl.
        Call Create to construct and initialize a new control and insert the newly-constructed control into its owner, as specified by the AOwner parameter. Create inserts the control in the owner by calling the owner's InsertComponent method. 
        Most controls override Create to initialize their unique properties. Objects that override the Create method must always call the inherited Create method first, and then proceed with the component-specific initialization. Specify the override directive when overriding the Create method.
        If a component's Create method allocates resources or memory, override the Destroy method to free those resources."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def SetParams(self, APosition: int, AMin: int, AMax: int) -> None:
        """TScrollBar.SetParams(APosition: int, AMin: int, AMax: int) -> None"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Shape(Control):
    """Wrapper for Delphi TShape"""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    Brush: Brush
    """Brush:"""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    Pen: Pen
    """Pen:"""
    Shape: ShapeType
    """ShapeType:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TShape.Create(AOwner: Component) -> None
        Creates an instance of TControl.
        Calling Create constructs and initializes an instance of TControl. However, you should never attempt to instantiate a TControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants.
        Create calls the parent constructor and initializes the control. 
        When overriding Create, always call the inherited Create method first, then proceed with the control's initialization. Remember to specify the override directive when overriding the Create method.
        
        Note:  If a control's constructor allocates resources or memory, also override the destructor to free those resources."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy.
        Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
        As the control is destroyed, it:
        
        Frees the TFont object in its Font property.
        Calls its inherited destructor.
        Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method.
        When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def StyleChanged(self, Sender: Object) -> None:
        """TShape.StyleChanged(Sender: Object) -> None"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Size:
    """wrapper for Delphi TSize type"""
    __hash__: ClassVar[None] = ...
    cx: Any
    """Provides access to the width of the size"""
    cy: Any
    """Provides access to the height of the size"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SpeedButton(Control):
    """Wrapper for Delphi TSpeedButton"""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    AllowAllUp: bool
    """bool:"""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    DisabledImageIndex: int
    """int:"""
    DisabledImageName: str
    """str:"""
    Down: bool
    """bool:"""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Flat: bool
    """bool:"""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Glyph: Bitmap
    """Bitmap:"""
    GroupIndex: int
    """int:"""
    HotImageIndex: int
    """int:"""
    HotImageName: str
    """str:"""
    ImageIndex: int
    """int:"""
    ImageName: str
    """str:"""
    Images: CustomImageList
    """CustomImageList:"""
    Layout: ButtonLayout
    """ButtonLayout:"""
    Margin: int
    """int:"""
    NumGlyphs: int
    """int:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    PressedImageIndex: int
    """int:"""
    PressedImageName: str
    """str:"""
    SelectedImageIndex: int
    """int:"""
    SelectedImageName: str
    """str:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Spacing: int
    """int:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Transparent: bool
    """bool:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SpinButton(WinControl):
    """TSpinButton allows the user to navigate through a range of values using the arrow buttons.
    A TSpinButton is a control with two TTimerSpeedButtons, each button displaying an arrow. TSpinButton allows the navigation through a range of values using the arrow buttons to customize the value held by the control. Usually, it is used to increase or decrease the value of the focused control."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DownGlyph: Bitmap
    """Bitmap: The bitmap that appears on the Down button.
        DownGlyph represents the bitmap that appears on the Down button.
        You can provide up to four images (one for each state) within a single bitmap, depending on the value of the DownNumGlyphs property. All images must be the same size and next to each other in a row.
        The four states of the button are described in the following table:
        
        
        
        Button state
        
        Description
        
        
        
        Up
        
        
        
        This image appears when the button is up. This image is also used when the button has focus (for example, if the user tabs to it); in this case, a focus rectangle is drawn around the button. If no other images exist in the bitmap, bit buttons also use this image for all other states.
        
        
        
        
        Disabled
        
        
        
        This image usually appears dimmed to indicate that the button cannot be selected.
        
        
        
        
        Clicked
        
        
        
        This image appears when the button is clicked. The Up image reappears when the user releases the mouse button.
        
        
        
        
        Down
        
        
        
        This image appears when the button stays down."""
    DownNumGlyphs: int
    """int: Specifies the number of Glyphs that appear on the Down button.
        DownNumGlyphs specifies the number of Glyphs that appear on the Down button. If you have multiple images in a bitmap, you must specify the number of images that are in the bitmap with the NumGlyphs property. The default value is 1."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    FocusControl: WinControl
    """WinControl: Designates a windowed control associated with the TSpinButton.
        Use FocusControl to set focus to a control."""
    Focused: Any
    """Determines whether the control has input focus."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnDownClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnUpClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    UpGlyph: Bitmap
    """Bitmap: The bitmap that appears on the Up button.
        UpGlyph specifies the bitmap that appears on the Up button.
        You can provide up to four images (one for each state) within a single bitmap, depending on the value of the UpNumGlyphs property. All images must be the same size and next to each other in a row.
        The four states of the button are described in the following table:
        
        
        
        Button state
        
        Description
        
        
        
        Up
        
        
        
        This image appears when the button is up. This image is also used when the button has focus (for example, if the user tabs to it); in this case, a focus rectangle is drawn around the button. If no other images exist in the bitmap, bit buttons also use this image for all other states.
        
        
        
        
        Disabled
        
        
        
        This image usually appears dimmed to indicate that the button cannot be selected.
        
        
        
        
        Clicked
        
        
        
        This image appears when the button is clicked. The Up image reappears when the user releases the mouse button.
        
        
        
        
        Down
        
        
        
        This image appears when the button stays down."""
    UpNumGlyphs: int
    """int: Number of Glyphs that appear on the Up button.
        UpNumGlyphs specifies the number of Glyphs that appear on the Up button. If you have multiple images in a bitmap, you must specify the number of images that are in the bitmap with the NumGlyphs property. The default value is 1."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TSpinButton.Create(AOwner: Component) -> None
        Creates and initializes a TSpinButton instance.
        The Create method creates and initializes a TSpinButton instance."""
    def SetBounds(self, ALeft: int, ATop: int, AWidth: int, AHeight: int) -> None:
        """TSpinButton.SetBounds(ALeft: int, ATop: int, AWidth: int, AHeight: int) -> None
        Sets the Left, Top, Width, and Height properties of the control in a single operation.
        SetBounds sets the Left, Top, Width, and Height properties of the control in a single operation. Specify the values for the Left, Top, Width, and Height properties as the value of the ALeft, ATop, AWidth, and AHeight parameters, respectively. The same effect can be achieved by setting the Left, Top, Width, and Height properties separately.
        SetBounds calls the SetBounds inherited method."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class SpinEdit(CustomEdit):
    """TSpinEdit combines a TEdit box with a TSpinButton.
    A TSpinEdit component is a TEdit with a TSpinButton attached.
    The Value of the edit box is numerical. By pressing the up and down buttons of TSpinButton, the Value is increased or decreased."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSelect: bool
    """bool: Determines whether all the text in the edit control is automatically selected when the control gets focus.
        Set AutoSelect to select all the text when the edit control gets focus. AutoSelect only applies to single-line edit controls.
        Use AutoSelect when the user is more likely to replace the text in the edit control than to append to it."""
    AutoSize: bool
    """bool: Determines whether the height of the edit control automatically resizes to accommodate the text.
        Use AutoSize to make the edit control adjust its size automatically so the client area accommodates the height of the text. When AutoSize is false, the edit control has a fixed height. When AutoSize is true, the size of the control is readjusted whenever a change occurs that could affect the height of the control, such as a change to the font or border style.
        
        Note: AutoSize only adjusts the height of the edit control. Even with AutoSize set to true, text in the edit control may appear truncated if it extends beyond the width of the control."""
    Button: SpinButton
    """SpinButton: Specifies the TSpinButton of the TSpinEdit.
        Button is a read-only property that specifies the spin button of the TSpinEdit."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    EditorEnabled: bool
    """bool: Specifies whether Value can be edited.
        EditorEnabled specifies whether Value can be edited or not."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    Increment: int
    """int: Specifies the increment value.
        Increment specifies the increment used to increase or decrease the Value property by clicking one of the TSpinEdit buttons or using the Up and Down keys while TSpinEdit is focused."""
    MaxLength: int
    """int: Specifies the maximum number of characters the user can enter into the edit control.
        Use MaxLength to limit the number of characters that can be entered into the edit control. A value of 0 indicates that there is no application-defined limit on the length.
        Use MaxLength to limit the length of the text in an edit control if that text will be copied into a fixed-length buffer.
        
        Note:  Setting MaxLength will not truncate the existing text, it merely prevents the user from adding more text after reaching the limit of MaxLength characters.
        Note:  Even when MaxLength is 0, there may be limitations imposed by the operating system on the number of characters that may be entered into an edit control.
        Note:  The unit of MaxLength is characters (not bytes) if the application is using themes."""
    MaxValue: int
    """int: Specifies the maximum value.
        MaxValue specifies the maximum Value that TSpinEdit can take."""
    MinValue: int
    """int: Specifies the minimum value.
        MinValue specifies the minimum Value that TSpinEdit can take."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ReadOnly: bool
    """bool: Determines whether the user can change the text of the edit control.
        To restrict the edit control to display only, set the ReadOnly property to true. Set ReadOnly to false to allow the contents of the edit control to be edited.
        Setting ReadOnly to true ensures that the text is not altered, while still allowing the user to select text. The selected text can then be manipulated by the application, or copied to the Clipboard."""
    SelStart: Any
    """Returns/sets the position of the cursor."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Value: int
    """int: Specifies the value listed in the TSpinEdit.
        Value specifies the value listed in the TSpinEdit. The value can be changed by clicking one of the TSpinEdit buttons or using the Up and Down keys while TSpinEdit is focused."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TSpinEdit.Create(AOwner: Component) -> None
        Creates and initializes a TSpinEdit instance.
        The Create method creates and initializes a TSpinEdit instance."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys a TSpinEdit instance.
        The Destroy method destroys a TSpinEdit instance. Destroy calls the Destroy inherited method."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TSpinEdit.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        The method is blank.
        TSpinEdit has no need to call a specified method for the control's child, so GetChildren doesn't perform any action."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Splitter(Control):
    """Wrapper for Delphi TSplitter"""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    AutoSnap: bool
    """bool:"""
    Beveled: bool
    """bool:"""
    Canvas: Canvas
    """Canvas:"""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    Cursor: int
    """int: Specifies the image used to represent the mouse pointer when it passes into the region covered by the control.
        Change the value of Cursor to provide feedback to the user when the mouse pointer enters the control. The value of Cursor is the index of the cursor in the list of cursors maintained by the global variable, Screen. In addition to the built-in cursors provided by TScreen, applications can add custom cursors to the list."""
    MinSize: int
    """int:"""
    OnCanResize: Callable[[Object,int,bool],None]
    """Callable[[Object, int, bool], None]:"""
    OnMoved: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnPaint: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ResizeStyle: ResizeStyle
    """ResizeStyle:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TSplitter.Create(AOwner: Component) -> None
        Creates an instance of TControl.
        Calling Create constructs and initializes an instance of TControl. However, you should never attempt to instantiate a TControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants.
        Create calls the parent constructor and initializes the control. 
        When overriding Create, always call the inherited Create method first, then proceed with the control's initialization. Remember to specify the override directive when overriding the Create method.
        
        Note:  If a control's constructor allocates resources or memory, also override the destructor to free those resources."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the control is not nil, and only then calls Destroy.
        Applications should only free controls explicitly when the constructor was called without assigning an owner to the control.
        As the control is destroyed, it:
        
        Frees the TFont object in its Font property.
        Calls its inherited destructor.
        Override Destroy to free any memory or resources allocated in the Create method. When declaring a Destroy method in a descendent control type, always add the override directive to the declaration and call the inherited Destroy as the last statement in the redeclared method.
        When a control is created, Delphi automatically provides exception handling around the constructor call. The destructor is called if an exception escapes from the constructor. This means that the destructor code must be prepared to clean up a partially constructed instance. Check all data fields for zero before disposing of their contents."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StaticText(WinControl):
    """TStaticText is a windowed control that displays text on a form.
    The TStaticText component functions like TLabel, except that it descends from TWinControl and therefore has a window handle. Use TStaticText instead of TLabel when the component's accelerator key must belong to a windowed control for example, on an ActiveX property page."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: Alignment
    """Alignment:"""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: StaticBorderStyle
    """StaticBorderStyle:"""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    FocusControl: WinControl
    """WinControl:"""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowAccelChar: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Transparent: bool
    """bool:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StatusBar(CustomStatusBar):
    """TStatusBar represents a status bar.
    The TStatusBar component is a row of panels, usually aligned at the bottom of a form, that display information about an application as it runs. Each panel is represented by a TStatusPanel object listed in the Panels property. The SimplePanel property can be used to toggle the status bar at runtime between a single- and multiple-panel display."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoHint: bool
    """bool: Specifies whether the status bar's text is set automatically to the current hint.
        Use AutoHint to specify whether the status bar's text is set automatically to the current hint. When AutoHint is True, the status bar automatically responds to hint actions by displaying the long version of the hint's text in the first panel."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderWidth: int
    """int: Specifies the width of the control's border.
        Use BorderWidth to get or set the width of the control's border. Graphics or text drawn by the control is clipped to the area within the border."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnCreatePanelClass: Callable[[CustomStatusBar,StatusPanelClass],None]
    """Callable[[CustomStatusBar, StatusPanelClass], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDrawPanel: Callable[[StatusBar,StatusPanel,Rect],None]
    """Callable[[StatusBar, StatusPanel, Rect], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnHint: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    Panels: StatusPanels
    """StatusPanels: Lists the panels (TStatusPanel objects) in the status bar.
        The Panels property holds a TStatusPanels, that is, a collection of TStatusPanel objects. At design time, you can add, remove, or modify panels with the Panels editor. To open the Panels editor, select the Panels property in the Object Inspector, then double-click in the Value column to the right or click the ellipsis (...) button.
        At design time, you can add, remove, or modify panels with the Panels editor:
        
        To open the Panels editor from the the Object Inspector, select the Panels property and either double-click in the Value column to the right or click the ellipsis (...) button.
        To open the Panels editor from the Form Designer, right-click TStatusBar and select Panels editor from the context menu."""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    SimplePanel: bool
    """bool: Determines whether the status bar displays a single panel or multiple panels.
        If SimplePanel is set to True, the status bar consists of a single panel displaying the text in SimpleText. If SimplePanel is set to False, the status bar displays a separate panel for each item in its Panels property.
        
        Note: When SimplePanel is False, you cannot use the SimpleText property to display text in the status bar. Instead, you must set the Text property on one of the panel objects."""
    SimpleText: str
    """str: Contains a text string to be displayed in the status panel when SimplePanel is True.
        
        Note: Microsoft Windows XP and earlier versions limited the size of the string to 127 chars. Under Microsoft Windows Vista, Windows 7, or later Windows operating systems, SimpleText has no such limit."""
    SizeGrip: bool
    """bool: Determines whether the status bar is resizable at run time.
        If SizeGrip is set to True, the status bar has a triangular grip on the lower right corner. The user can resize the status bar by dragging the grip with the mouse.
        A size grip will not be drawn unless the Parent property refers to the child of a TCustomForm descendant with a BorderStyle of bsSizeable or bsSizeToolWin.
        
        Note: If Align is set to alBottom, alRight, or alClient, the sizing grip will not work. If the Alignment property of the last panel in the status bar is set to taRightJustify, the sizing grip will truncate the panel's text."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    UseSystemFont: bool
    """bool: Specifies whether the status bar uses the system font.
        UseSystemFont specifies whether the status bar uses the system font. To change fonts, use the Font property."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Stream(Object):
    """TStream is the base class type for stream objects that can read from or write to various kinds of storage media, such as disk files, dynamic memory, and so on.
    Use specialized stream objects to read from, write to, or copy information stored in a particular medium. Each descendant of TStream implements methods for transferring information to and from a particular storage medium, such as a disk file, dynamic memory, and so on. In addition to methods for reading, writing, and copying bytes to and from the stream, stream objects permit applications to seek to an arbitrary position in the stream. Properties of TStream provide information about the stream, such as its size and the current position in the stream.
    TStream also introduces methods that work in conjunction with components and filers for loading and saving components in simple and inherited forms. These methods are called automatically by global routines that initiate component streaming. They can also be called directly to initiate the streaming process. Note, however, that component streaming always involves two additional objects:
    
    A component object that is passed as a parameter to the stream's methods.
    A filer object that is automatically created by the stream, and associated with the stream.
    Descendant stream objects, such as memory and file streams used for component streaming, are created automatically by the global functions ReadComponentRes and WriteComponentRes. For streaming other kinds of information, choose a descendent class according to the specific data and storage needs. These include:
    
    TFileStream -- for working with files.
    TStringStream -- for manipulating in-memory strings.
    TMemoryStream -- for working with a memory buffer.
    TWinSocketStream -- for reading and writing over a socket connection.
    TOleStream -- for using a COM interface to read and write."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    Position: int
    """int: Indicates the current offset into the stream for reading and writing.
        Use Position to obtain the current position of the stream. This is the number of bytes from the beginning of the streamed data."""
    Size: int
    """int: Indicates the size in bytes of the stream.
        Use Size to find the size of the stream. Size is used internally in routines that read and write to and from the stream. Setting the Size property of TStream does nothing. However, descendants of TStream can override this property to allow applications to change the size of the resource accessed using the stream. 
        The Size property typically indicates the size of the stream in bytes.  But  a descendent of TStream can use -1 to indicate an unknown size.  When the size is unknown, use the return value from TStream.Read to determine end of the stream.
        
        Example of Stream Size using DataSnap and DBX
        When you are reading a DataSnap stream in blocks, the actual TStream descendant that is used to read the stream is  TDBXStreamReaderStream.  TDBXStreamReaderStream overrides methods of TStream such as the method System.Classes.TStream.GetSize, which is the reader for the property Size.
        DBX connections support reading streams in block. The default block size is 32K. Streams can be passed from the client to the server, or from the server to the client. When the receiver is reading the stream (whether the receiver is the client or the server), the stream is passed from the sender to the receiver in blocks. When the stream is large enough to require multiple block readings, the Size property of the receiver's stream will be -1, which indicates that the size of the stream is unknown. As the receiver reads the stream, DataSnap makes a request to the sender for the next block, as needed. To read the stream, the client calls the Read() method until the return value is less than the value requested.
        The following code shows how to read a stream to the end, by checking the return value from Read():
        
        var
          LBuffer: TArray<Byte>;
          LReadCount: Integer;
        begin
          SetLength(LBuffer, 1024*10); // 10K buffer for this example.  The buffer size can be larger or smaller.
          repeat
            LReadCount := AStream.Read(LBuffer[0], Length(LBuffer));
            if LReadCount > 0 then
            begin
              // Process buffer
            end;
          until LReadCount < Length(LBuffer);"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CopyFrom(self, Source: Stream, Count: int, BufferSize: int) -> int:
        """TStream.CopyFrom(Source: Stream, Count: int, BufferSize: int) -> int
        Copies a specified number of bytes from one stream to another.
        Use CopyFrom to copy data from one stream to a different one. Using CopyFrom eliminates the need to create, read into, write from, and free a buffer when copying data. 
        CopyFrom copies Count bytes from the stream specified by Source into the stream. It then moves the current position by Count bytes and returns the number of bytes copied. 
        If Count is 0, CopyFrom sets Source position to 0 before reading and then copies the entire contents of Source into the stream. If Count is greater than or less than 0, CopyFrom reads from the current position in Source. 
        Because the CopyFrom method uses ReadBuffer and WriteBuffer to do the effective copying, if the Count is greater than the SourceStream size, ReadBuffer throws an exception stating that a stream read error has occured."""
    def FixupResourceHeader(self, FixupInfo: int) -> None:
        """TStream.FixupResourceHeader(FixupInfo: int) -> None
        Patches the resource header for a resource that has been written to the stream.
        Do not call FixupResourceHeader? it is used internally. The WriteDescendentRes method calls FixupResourceHeader after writing a component to the stream. This method then uses the current position to determine the size of the resource just written and adjust the resource header accordingly.
        The FixupInfo parameter is the value returned by WriteResourceHeader when it writes the resource header (before WriteDescendentRes streams out the component.)"""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def Read(self, Buffer, Count: int) -> int:
        """TStream.Read(Buffer, Count: int) -> int
        Methods responsible for reading  up to Count bytes of data  from the stream into Buffer.
        Descendant stream classes can define its own Read methods that read data from its particular storage medium (such as memory or a disk file) into a Buffer buffer.
        Read is used in cases where the number of bytes to read from the stream is not necessarily fixed. 
        Read attempts to read, into Buffer, up to Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. Read returns the number of bytes actually read, which may be less than Count.
        Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
        All the other data-reading methods of a stream (ReadBuffer, ReadData) call Read to do their actual reading.\r
        Methods responsible for reading  up to Count bytes of data  from the stream into Buffer.
        Descendant stream classes can define its own Read methods that read data from its particular storage medium (such as memory or a disk file) into a Buffer buffer.
        Read is used in cases where the number of bytes to read from the stream is not necessarily fixed. 
        Read attempts to read, into Buffer, up to Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. Read returns the number of bytes actually read, which may be less than Count.
        Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
        All the other data-reading methods of a stream (ReadBuffer, ReadData) call Read to do their actual reading.\r
        Methods responsible for reading  up to Count bytes of data  from the stream into Buffer.
        Descendant stream classes can define its own Read methods that read data from its particular storage medium (such as memory or a disk file) into a Buffer buffer.
        Read is used in cases where the number of bytes to read from the stream is not necessarily fixed. 
        Read attempts to read, into Buffer, up to Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. Read returns the number of bytes actually read, which may be less than Count.
        Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
        All the other data-reading methods of a stream (ReadBuffer, ReadData) call Read to do their actual reading."""
    def Read64(self, Buffer: tuple, Offset: int, Count: int) -> int:
        """TStream.Read64(Buffer: tuple, Offset: int, Count: int) -> int
        Embarcadero Technologies does not currently have any additional information."""
    def ReadBuffer(self, Buffer, Count: int) -> None:
        """TStream.ReadBuffer(Buffer, Count: int) -> None
        Reads Count bytes from the stream into Buffer.
        Use ReadBuffer to read Count bytes from the stream into a Buffer buffer in cases where the number of bytes to read is known and fixed, for example when reading in structures. ReadBuffer is used internally for loading from a stream and copying from a stream.
        Read attempts to read exactly Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. 
        Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
        ReadBuffer calls Read to do the actual reading. If Count bytes cannot be read from the stream, an EReadError exception is raised.\r
        Reads Count bytes from the stream into Buffer.
        Use ReadBuffer to read Count bytes from the stream into a Buffer buffer in cases where the number of bytes to read is known and fixed, for example when reading in structures. ReadBuffer is used internally for loading from a stream and copying from a stream.
        Read attempts to read exactly Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. 
        Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
        ReadBuffer calls Read to do the actual reading. If Count bytes cannot be read from the stream, an EReadError exception is raised.\r
        Reads Count bytes from the stream into Buffer.
        Use ReadBuffer to read Count bytes from the stream into a Buffer buffer in cases where the number of bytes to read is known and fixed, for example when reading in structures. ReadBuffer is used internally for loading from a stream and copying from a stream.
        Read attempts to read exactly Count bytes from the stream, starting at the current position, and then advances the current position in the stream by the number of bytes actually transferred. 
        Offset specifies a zero-based position in Buffer from which to write the first byte into Buffer. 
        ReadBuffer calls Read to do the actual reading. If Count bytes cannot be read from the stream, an EReadError exception is raised."""
    def ReadBufferData(self, Buffer: bool) -> None:
        """TStream.ReadBufferData(Buffer: bool) -> None
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading.\r
        Methods responsible for reading fixed Count or SizeOf(Buffer) number of bytes from the stream into Buffer.
        Use ReadBufferData to read exactly the fixed Count or SizeOf(Buffer) number of bytes from the stream into a typed Buffer. ReadBufferData raises an EReadError exception if ReadBufferData cannot read exactly the specified number of bytes.  
        ReadBufferData works using the following algorithms:
        
        When ReadBufferData does not have the Count parameter, then ReadBufferData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. If the number of bytes transferred is not  = SizeOf(Buffer), then ReadBufferData raises an EReadError exception.
        When ReadBufferData has the Count parameter, then ReadBufferData calls ReadData to read the Count bytes. If a reported number of transferred bytes is not equal to Count, then ReadBufferData raises an EReadError exception.
        ReadBufferData calls ReadData to do the actual reading."""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadComponent(self, Instance: Component) -> Component:
        """TStream.ReadComponent(Instance: Component) -> Component
        Initiates streaming of components and their properties.
        ReadComponent is called indirectly by the global routine ReadComponentRes, by the ReadComponentRes method, or it can be called directly to initiate component streaming.
        ReadComponent reads data values from the stream and assigns them to Instance's properties. It then constructs a reader object and calls the reader's ReadRootComponent method to read the Instance's property values and construct child objects defined in the stream as children of Instance. ReadComponent returns the component.
        If Instance is nil (Delphi) or NULL (C++), ReadComponent constructs a component based on the type information in the stream and returns the newly-constructed component."""
    def ReadComponentRes(self, Instance: Component) -> Component:
        """TStream.ReadComponentRes(Instance: Component) -> Component
        Reads components and their properties from a stream in a resource file format.
        ReadComponentRes is called automatically by the global routine ReadComponentResFile. It can also be called directly if the current position of the stream points to a component written using the WriteComponentRes method.
        ReadComponentResFile creates a file stream object, which then calls its ReadComponentRes method.
        ReadComponentRes first calls the ReadResHeader method to read a resource header from the stream. If the stream does not contain a resource header at the current position, ReadResHeader will raise an EInvalidImage exception. ReadComponentRes then calls ReadComponent to read the properties that must be set on Instance."""
    def ReadData(self, Buffer: Pointer, Count: int) -> int:
        """TStream.ReadData(Buffer: Pointer, Count: int) -> int
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading.\r
        Methods responsible for reading up to Count but not more than SizeOf(Buffer) bytes from the stream into Buffer.
        ReadData is used in cases, where the number of bytes to read from the stream is not necessarily fixed. 
        ReadData works using the following algorithms:
        
        When ReadData does not have the Count parameter, then ReadData tries to read the SizeOf(Buffer) number of bytes, then advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        When ReadData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then ReadData tries to read the SizeOf(Buffer) number of bytes. ReadData advances the current position in the stream by Count number of bytes. ReadData returns Count.
        If Count  <= SizeOf(Buffer), then ReadData tries to read up to the Count number of bytes from the stream. ReadData advances the current position in the stream by the number of bytes transferred. ReadData returns the number of bytes read.
        ReadData methods call Read to do their actual reading."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadResHeader(self, *args, **kwargs) -> Any:
        """Reads a resource-file header from the stream.
        Do not call ReadResHeader directly. It is called automatically by ReadComponentRes before reading a component from a resource file.
        After reading the resource-file header, ReadResHeader moves the current position of the stream to just beyond the header. If the stream does not contain a valid resource-file header, ReadResHeader raises an EInvalidImage exception."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def Seek(self, Offset: int, Origin: int) -> int:
        """TStream.Seek(Offset: int, Origin: int) -> int
        Moves to a specified position in the streamed resource.
        Call Seek to move the current position of the stream in its particular storage medium (such as memory or a disk file).
        The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        soBeginning
        
        
        
        Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be >= 0.
        
        
        
        
        soCurrent
        
        
        
        Offset is from the current position in the resource. Seek moves to Position + Offset.
        
        
        
        
        soEnd
        
        
        
        Offset is from the end of the resource. Offset must be <= 0 to indicate a number of bytes before the end of the file.
        
        
        
        Seek returns the new value of the Position property.
        Seek is called by the Position and Size properties.
        
        Note: As implemented in TStream, the two versions (the 32-bit or 64-bit syntax) call each other. Descendent stream classes must override at least one of these versions, and the override must not call the inherited default implementation.\r
        Moves to a specified position in the streamed resource.
        Call Seek to move the current position of the stream in its particular storage medium (such as memory or a disk file).
        The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        soBeginning
        
        
        
        Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be >= 0.
        
        
        
        
        soCurrent
        
        
        
        Offset is from the current position in the resource. Seek moves to Position + Offset.
        
        
        
        
        soEnd
        
        
        
        Offset is from the end of the resource. Offset must be <= 0 to indicate a number of bytes before the end of the file.
        
        
        
        Seek returns the new value of the Position property.
        Seek is called by the Position and Size properties.
        
        Note: As implemented in TStream, the two versions (the 32-bit or 64-bit syntax) call each other. Descendent stream classes must override at least one of these versions, and the override must not call the inherited default implementation.\r
        Moves to a specified position in the streamed resource.
        Call Seek to move the current position of the stream in its particular storage medium (such as memory or a disk file).
        The Origin parameter indicates how to interpret the Offset parameter. Origin should be one of the following values:
        
        
        
        Value
        
        Meaning
        
        
        
        soBeginning
        
        
        
        Offset is from the beginning of the resource. Seek moves to the position Offset. Offset must be >= 0.
        
        
        
        
        soCurrent
        
        
        
        Offset is from the current position in the resource. Seek moves to Position + Offset.
        
        
        
        
        soEnd
        
        
        
        Offset is from the end of the resource. Offset must be <= 0 to indicate a number of bytes before the end of the file.
        
        
        
        Seek returns the new value of the Position property.
        Seek is called by the Position and Size properties.
        
        Note: As implemented in TStream, the two versions (the 32-bit or 64-bit syntax) call each other. Descendent stream classes must override at least one of these versions, and the override must not call the inherited default implementation."""
    def Seek32(self, Offset: int, Origin: SeekOrigin) -> int:
        """TStream.Seek32(Offset: int, Origin: SeekOrigin) -> int
        Embarcadero Technologies does not currently have any additional information."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def Write(self, Buffer, Count: int) -> int:
        """TStream.Write(Buffer, Count: int) -> int
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        Write attempts to write up to Count bytes from the Buffer to the current position in the stream, and returns the number of bytes written.
        After writing to the stream, Write advances the current position by the number of bytes written. 
        Offset specifies a zero-based position in Buffer of the first byte to write. 
        All other data-writing methods of a stream (WriteBuffer, WriteData) call Write to do their actual writing.
        Each descendent stream object defines a Write method that writes data to its particular storage medium (such as memory or a disk file).\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        Write attempts to write up to Count bytes from the Buffer to the current position in the stream, and returns the number of bytes written.
        After writing to the stream, Write advances the current position by the number of bytes written. 
        Offset specifies a zero-based position in Buffer of the first byte to write. 
        All other data-writing methods of a stream (WriteBuffer, WriteData) call Write to do their actual writing.
        Each descendent stream object defines a Write method that writes data to its particular storage medium (such as memory or a disk file).\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        Write attempts to write up to Count bytes from the Buffer to the current position in the stream, and returns the number of bytes written.
        After writing to the stream, Write advances the current position by the number of bytes written. 
        Offset specifies a zero-based position in Buffer of the first byte to write. 
        All other data-writing methods of a stream (WriteBuffer, WriteData) call Write to do their actual writing.
        Each descendent stream object defines a Write method that writes data to its particular storage medium (such as memory or a disk file)."""
    def Write64(self, Buffer: tuple, Offset: int, Count: int) -> int:
        """TStream.Write64(Buffer: tuple, Offset: int, Count: int) -> int
        Embarcadero Technologies does not currently have any additional information."""
    def WriteBuffer(self, Buffer, Count: int) -> None:
        """TStream.WriteBuffer(Buffer, Count: int) -> None
        Writes Count bytes from Buffer onto the stream.
        WriteBuffer attempts to write Count  bytes from the Buffer to the current position in the stream, then WriteBuffer advances the current position by Count. If the stream fails to write all the requested bytes, an EWriteError exception is raised.
        Offset specifies a zero-based position in Buffer of the first byte to write.
        Use WriteBuffer to save data to a stream. WriteBuffer is used in cases, where the number of bytes to write is known and required, for example when writing in structures. Use WriteBuffer for standard file I/O streaming.
        WriteBuffer is used internally for writing to a stream. It is used by other objects, such as strings and lists, for writing strings stored in a buffer.
        WriteBuffer calls Write to handle the actual writing.\r
        Writes Count bytes from Buffer onto the stream.
        WriteBuffer attempts to write Count  bytes from the Buffer to the current position in the stream, then WriteBuffer advances the current position by Count. If the stream fails to write all the requested bytes, an EWriteError exception is raised.
        Offset specifies a zero-based position in Buffer of the first byte to write.
        Use WriteBuffer to save data to a stream. WriteBuffer is used in cases, where the number of bytes to write is known and required, for example when writing in structures. Use WriteBuffer for standard file I/O streaming.
        WriteBuffer is used internally for writing to a stream. It is used by other objects, such as strings and lists, for writing strings stored in a buffer.
        WriteBuffer calls Write to handle the actual writing.\r
        Writes Count bytes from Buffer onto the stream.
        WriteBuffer attempts to write Count  bytes from the Buffer to the current position in the stream, then WriteBuffer advances the current position by Count. If the stream fails to write all the requested bytes, an EWriteError exception is raised.
        Offset specifies a zero-based position in Buffer of the first byte to write.
        Use WriteBuffer to save data to a stream. WriteBuffer is used in cases, where the number of bytes to write is known and required, for example when writing in structures. Use WriteBuffer for standard file I/O streaming.
        WriteBuffer is used internally for writing to a stream. It is used by other objects, such as strings and lists, for writing strings stored in a buffer.
        WriteBuffer calls Write to handle the actual writing."""
    def WriteBufferData(self, Buffer: int, Count: int) -> None:
        """TStream.WriteBufferData(Buffer: int, Count: int) -> None
        Writes up to 4 four or Count bytes from Buffer onto the stream.
        WriteBufferData works using the following algorithms: 
        
        If Count  <= 4, then WriteBufferData tries to write up to Count bytes to the stream starting at the current position and advances the current position in the stream by the number of bytes transferred.
        If Count  > 4, then WriteBufferData tries to write up to 4 four bytes to the stream, starting at the current position, and then advances the current position in the stream until Count number of bytes from the initial position that was before the starting of WriteBufferData execution."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteComponent(self, Instance: Component) -> None:
        """TStream.WriteComponent(Instance: Component) -> None
        Initiates the writing of components and their properties to a stream.
        WriteComponent is used internally in the component streaming system, but can also be called directly when writing components to memory streams or database blobs.
        WriteComponent constructs a writer object and calls its WriteRootComponent method to write the component specified by Instance, and its owned objects, to the stream."""
    def WriteComponentRes(self, ResName: str, Instance: Component) -> None:
        """TStream.WriteComponentRes(ResName: str, Instance: Component) -> None
        Writes components and their properties to a stream from a resource file format.
        WriteComponentRes is used internally in the streaming system, but can also be called directly when sending data to other applications on disk. WriteComponentRes is used for streaming components that need data, such as a bitmap or icon to be stored in a resource-file format.
        WriteComponentRes calls WriteDescendentRes, passing in nil (Delphi) or NULL (C++) as the Ancestor. Therefore, WriteDescendentRes initiates the remainder of the streaming process for a component that, in this case, is not a descendant.
        To read a component written with WriteComponentRes, call the ReadComponentRes method."""
    def WriteData(self, Buffer: tuple, Count: int) -> int:
        """TStream.WriteData(Buffer: tuple, Count: int) -> int
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing.\r
        Methods responsible for writing up to Count bytes from Buffer to the stream.
        WriteData is used in cases, where the number of bytes to write to the stream is not necessarily fixed. 
        WriteData works using the following algorithms: 
        
        When WriteData does not have the Count parameter, then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written.
        When WriteData has the Count parameter, then:
        If Count  > SizeOf(Buffer), then WriteData tries to write the SizeOf(Buffer) number of bytes. WriteData advances the current position in the stream by the Count number of bytes.
        If Count  <= SizeOf(Buffer), then WriteData tries to write up to the Count number of bytes to the stream and then advances the current position in the stream by the number of bytes transferred. WriteData returns the number of bytes written, which may be less than Count.
        WriteData methods call Write to do their actual writing."""
    def WriteDescendent(self, Instance: Component, Ancestor: Component) -> None:
        """TStream.WriteDescendent(Instance: Component, Ancestor: Component) -> None
        Streams components and their properties in inherited forms.
        Do not call WriteDescendent directly. WriteDescendent is called automatically by WriteComponent.
        WriteDescendent constructs a writer object, then calls the writer object's WriteDescendent method to write the component passed in Instance to the stream. Instance is either an inherited form descended from Ancestor or nil (Delphi) or NULL (C++). However, WriteDescendent is never used to write owned components, only to initiate streaming on the root component."""
    def WriteDescendentRes(self, ResName: str, Instance: Component, Ancestor: Component) -> None:
        """TStream.WriteDescendentRes(ResName: str, Instance: Component, Ancestor: Component) -> None
        Streams components and their properties in inherited forms.
        Do not call WriteDescendentRes directly. WriteDescendentRes is called automatically by WriteComponentRes.
        WriteDescendentRes writes a resource-file header to the stream, using the resource name passed in ResName as the name of the resource. It then calls WriteDescendent to write Instance to the stream as a descendant of Ancestor."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteResourceHeader(self, ResName: str, FixupInfo: int) -> None:
        """TStream.WriteResourceHeader(ResName: str, FixupInfo: int) -> None
        Writes a resource-file header to the stream.
        Do not call WriteResourceHeader; it is used internally. The WriteDescendentRes method calls WriteResourceHeader before writing a component to the stream. This method writes the resource-file header, using the value passed as ResName for the name of the resource. It returns a position in FixupInfo that must be used to adjust the header after the size of the resource is known. WriteDescendentRes calls FixupResourceHeader with the value returned as FixupInfo after streaming out the component."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StringGrid(DrawGrid):
    """TStringGrid represents a grid control designed to simplify the handling of strings and associated objects.
    Add a TStringGrid object to a form to present textual data in a tabular format. TStringGrid provides many properties to control the appearance of the grid, as well as events and methods that take advantage of the tabular organization of the grid in responding to user actions. 
    TStringGrid introduces the ability to associate an object with each string in the grid. These objects can encapsulate any information or behavior represented by the strings that are presented to the user.
    For a TStringGrid, the DrawingStyle property controls whether the current settings have any effect for FixedColor, and for GradientStartColor and GradientEndColor:
    
    Setting FixedColor has no effect unless you also set DrawingStyle  to gdsClassic.
    Setting GradientStartColor and GradientEndColor has no effect unless you set the value of DrawingStyle to gdsGradient.
    Note: If the strings to be presented in a grid represent field values from the records in a dataset, use TDBGrid instead.
    Note: To display the string and the associated object or control, use TDrawGrid instead. ."""
    __hash__: ClassVar[None] = ...
    Canvas: Any
    """Specifies the TCanvas object that presents a drawing surface for the control."""
    Cells: str
    """str:"""
    Col: Any
    """Specifies the index of the column that contains the selected cell."""
    ColWidths: Any
    """Specifies column widths of the grid"""
    Cols: Strings
    """Strings:"""
    EditorMode: Any
    """Determines whether the current cell can be edited."""
    GridHeight: Any
    """Specifies the height of the grid in pixels."""
    GridWidth: Any
    """Specifies the width of the grid in pixels."""
    LeftCol: Any
    """Specifies the index of the first visible scrollable column in the grid."""
    Objects: Object
    """Object:"""
    Row: Any
    """Specifies the index of the row that contains the selected cell."""
    RowHeights: Any
    """Specifies row heights of the grid"""
    Rows: Strings
    """Strings:"""
    Selection: Any
    """Indicates the boundaries of the current selection."""
    TopRow: Any
    """Specifies the index of the first visible scrollable row in the grid."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, AOwner: Component) -> None:
        """TStringGrid.Create(AOwner: Component) -> None
        Creates an instance of TStringGrid.
        Call Create to create an instance of TStringGrid at runtime. For string grids placed on forms at design time, Create is called automatically.
        AOwner is another component, typically a form, that becomes the grid's Owner. The Owner is responsible for freeing the grid."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TStringGrid.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the string grid is not nil, and only then calls Destroy.
        Destroy frees the helper objects used to manage the array of strings and their associated objects."""
    def GetCell(self, col, row) -> Any:
        """TStringGrid.GetCell(col, row)
        Returns the content of a cell"""
    def SetCell(self, col, row, value) -> Any:
        """TStringGrid.SetCell(col, row, value)
        Sets the content of a cell"""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StringStream(BytesStream):
    """TStringStream provides file-like access to information stored as a long string.
    Use TStringStream to store data as a long string enhanced with I/O capabilities. TStringStream is useful as an intermediary object that can hold text as well as read it from or write it to another storage medium. TStringStream provides a mechanism for manipulating text that is obtained from a less accessible medium."""
    __hash__: ClassVar[None] = ...
    ClassName: Any
    """Returns the TObject.ClassName"""
    DataString: str
    """str: Provides direct access to the string that stores the text represented by the TStringStream object.
        Use DataString to get access to the text of the stream. The text represents the information that is being transferred by means of the string stream. Size is the number of bytes in the string, and Position is the current position within DataString.
        
        Note: DataString is a read-only property. DataString can be used to change the contents of the string, but applications can't change the DataString itself."""
    Encoding: Encoding
    """Encoding: Represents the encoding used internally by the TStringStream instance to store the data.
        Encoding represents the encoding that is used to get the corresponding array of bytes from a given string, or to obtain the corresponding string from the contained array of bytes. (A string stream contains an array of bytes.)
        The encoding of a stream string is set in the constructor (you can specify what encoding to use)."""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Create(self, *args, **kwargs) -> Any:
        """Creates an instance of TStringStream.
        Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.\r
        Creates an instance of TStringStream.
        Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.\r
        Creates an instance of TStringStream.
        Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.\r
        Creates an instance of TStringStream.
        Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.\r
        Creates an instance of TStringStream.
        Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter.\r
        Creates an instance of TStringStream.
        Call Create to instantiate a TStringStream object. Create initializes the DataString property to the AString parameter."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TMemoryStream.
        System.Classes.TStringStream.Destroy inherits from System.Classes.TMemoryStream.Destroy. All content below this line refers to System.Classes.TMemoryStream.Destroy.
        Destroys an instance of TMemoryStream.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TMemoryStream reference is not nil, and only then calls Destroy.
        Destroy a TMemoryStream object when it is no longer needed to store or write data. Destroy calls Clear to free the memory buffer before calling the inherited destructor."""
    def Free(self) -> Any:
        """TObject.Free()
        Frees the Wrapped Delphi Object"""
    def InheritsFrom(self, ClassName) -> Any:
        """TObject.InheritsFrom(ClassName)
        Returns True if Delphi Object is or inherits from ClassName"""
    def ReadBytes(self) -> Any:
        """TPyDelphiStream.ReadBytes()
        Read content as bytes."""
    def ReadFloat(self) -> Any:
        """TPyDelphiStream.ReadFloat()
        Read content as float."""
    def ReadInt(self) -> Any:
        """TPyDelphiStream.ReadInt()
        Read content as integer."""
    def ReadString(self) -> Any:
        """TPyDelphiStream.ReadString()
        Read content as string."""
    def SetProps(self, prop1 = ..., prop2 = ...) -> Any:
        """TObject.SetProps(prop1=val1, prop2=val2...)
        Sets several properties in one call"""
    def ToList(self) -> Any:
        """TStrings.ToList()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python list object."""
    def ToTuple(self) -> Any:
        """TStrings.ToTuple()
        If the object is a container (TStrings, TComponent...), it returns the content of the sequence as a Python tuple object."""
    def WriteBytes(self) -> Any:
        """TPyDelphiStream.WriteBytes()
        Write content as bytes."""
    def WriteFloat(self) -> Any:
        """TPyDelphiStream.WriteFloat()
        Write content as float."""
    def WriteInt(self) -> Any:
        """TPyDelphiStream.WriteInt()
        Write content as integer."""
    def WriteString(self) -> Any:
        """TPyDelphiStream.WriteString()
        Write content as string."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __dir__(self) -> Any:
        """Returns the list of all methods, fields and properties of this instance."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Strings(Persistent):
    """TStrings is the base class for objects that represent a list of strings.
    Derive a class from TStrings to store and manipulate a list of strings. TStrings contains abstract or, in C++ terminology, pure virtual methods and should not be directly instantiated.
    Descendants of TStrings can represent several individual strings, such as the individual lines that appear in a list box. Some objects use descendants of TStrings to represent one long body of text so that it can be manipulated in smaller chunks.
    TStrings introduces many properties and methods to:
    
    Add or delete strings at specified positions in the list.
    Rearrange the strings in the list.
    Access the string at a particular location.
    Read the strings from or write the strings to a file or stream.
    Associate an object with each string in the list.
    Store and retrieve strings as name-value pairs.
    For an explanation of name-value pairs, refer to the NameValueSeparator property."""
    __hash__: ClassVar[None] = ...
    Capacity: Any
    """Indicates the number of strings the TStrings object can hold."""
    CommaText: str
    '''str: Lists the strings in the TStrings object in a single comma-delimited string.
        Use CommaText to get or set all the strings in the TStrings object in a single comma-delimited string. The single comma-delimited string format is also known as the system data format (SDF).
        When retrieving CommaText, any string in the list that include spaces, commas or double quotes will be contained in double quotes, and any double quotes in a string will be repeated. For example, if the list contains the following strings:
        
        Stri,ng1
        Stri"ng2
        String 3
        String4
        
        CommaText will return: 
        
        "Stri,ng1","Stri""ng2","String 3",String4
        
        When assigning CommaText, the value is parsed as SDF formatted text. For SDF format, strings are separated by commas or spaces, and optionally enclosed in double quotes. Double quote marks that are part of the string are repeated to distinguish them from the quotes that surround the string. Spaces and commas that are not contained within double quote marks are delimiters. Two commas next to each other will indicate an empty string, but spaces that appear next to another delimiter are ignored. For example, suppose CommaText is set to:
        
        "Stri,ng 1","Stri""ng 2",String 3,String4
        
        The list will then contain:
        
        Stri,ng 1
        Stri"ng 2
        String
        3
        String4
        
        Note: CommaText is the same as the DelimitedText property with a delimiter of \',\' and a quote character of \'"\'.
        Including a trailing comma in the source string causes a blank item to be included in the string list. For example, if CommaText is set to
        
        "String1,String2,String3, "
        
        the string list will contain
        
        String1
        String2
        String3
        <Blank>'''
    Count: int
    """int: Introduces an abstract property to represent the number of strings in the list.
        Descendants of TStrings implement a Count property to indicate the number of strings in the list.
        Use the Count property when iterating over all the strings in the list, or when trying to locate the position of a string relative to the last string in the list."""
    DefaultEncoding: Encoding
    """Encoding: The default encoding for the current object.
        DefaultEncoding is used when the nil encoding is specified in a call to LoadFromStream or SaveToStream. 
        By default, DefaultEncoding is set to Default. The user can change DefaultEncoding if another default encoding is desired for LoadFromStream or SaveToStream."""
    DelimitedText: str
    '''str: Represents all the strings in the TStrings object as a single delimited string.
        Use DelimitedText to get or set all the strings in the TStrings object in a single string, separated by the character specified by the Delimiter property. 
        When retrieving DelimitedText, any string in the list that includes spaces or the delimiter and quotation marks characters specified in the Delimiter and QuoteChar properties will be surrounded (before and after) by the quotation mark character (QuoteChar). In addition, any QuoteChar character contained in an individual string will be repeated. 
        When retrieving DelimitedText, the resulting value delimits individual strings in two ways: each string is surrounded (before and after) by the quotation marks character specified by the QuoteChar property. In addition, individual strings are separated by the character specified by the Delimiter property. 
        When assigning DelimitedText, individual strings must be separated using Delimiter marks, and optionally enclosed in QuoteChar characters. 
        When assigning DelimitedText, the value is parsed as SDF formatted text. For SDF format, strings are separated by Delimiter characters or spaces, and optionally enclosed in QuoteChar characters. QuoteChar marks that are part of the string are repeated to distinguish them from the QuoteChar characters that surround the string. Spaces and Delimiter characters that are not contained within QuoteChar marks are delimiters. Two Delimiter characters next to each other will indicate an empty string, but spaces that appear next to another Delimiter character are ignored. 
        If StrictDelimiter is set to False, the space character is also interpreted as a delimiter, regardless of the value of Delimiter. This is not true when the space character occurs between quotation marks. 
        
        Note: CommaText is the same as the DelimitedText property when Delimiter is \',\' and QuoteChar is \'"\'. Including a trailing Delimiter in the source string causes a blank item to be included in the string list.'''
    Delimiter: Any
    """unicodechr(str): Specifies the delimiter used by the DelimitedText property.
        Use Delimiter to get or set the delimiter used by the DelimitedText property. DelimitedText represents all of the strings in the TStrings object as a single string, with individual strings separated by the character that is the value of Delimiter.
        The default delimiter is represented by comma (,)."""
    Encoding: Encoding
    """Encoding: Character encoding determined during reading from a stream or file.
        Encoding is a read-only property that contains the value of the character encoding detected when the LoadFromStream or LoadFromFile methods are called. If a file or stream does not contain a BOM (the encoding value cannot be detected) then Encoding is set to the value specified in the DefaultEncoding property.
        Encoding is used in the SaveToStream and SaveToFile methods."""
    KeyNames: str
    """str:"""
    LineBreak: str
    """str: Defines line-break characters.
        The LineBreak property is used internally in TStrings to set the string terminator characters. Set or read the LineBreak property to determine the string terminator characters in multistring output operations. 
        For example, the GetText method returns a long string containing all TStrings strings, each of which is terminated by the LineBreak value.
        
        Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on Android, Linux, macOS and iOS it is just a line feed (#10)."""
    NameValueSeparator: Any
    """unicodechr(str): Indicates the character used to separate names from values.
        Strings that contain the NameValueSeparator character are considered name-value pairs. NameValueSeparator defaults to the equal sign (=). TStrings defines various methods for accessing names and values and for searching for specific names.
        Strings that are name-value pairs consist of a name part, the separator character, and a value part. Any spaces around the separator character are part of the name or value. This convention corresponds to the format used in many initialization files. For example:
        
        DisplayGrid=1
        SnapToGrid=1
        GridSizeX=8
        GridSizeY=8"""
    Names: str
    """str:"""
    Objects: Any
    """Represents a set of objects that are associated one with each of the strings in the Strings property."""
    Options: StringsOptions
    """StringsOptions: Controls a set of boolean properties of TStrings.
        Use Options to specify the value of the following boolean properties of the list of strings:
        
        
        
        Option
        
        Property
        
        
        soStrictDelimiter
        
        StrictDelimiter
        
        
        soWriteBOM
        
        WriteBOM
        
        
        soTrailingLineBreak
        
        TrailingLineBreak
        
        
        soUseLocale
        
        UseLocale"""
    QuoteChar: Any
    """unicodechr(str): Specifies the quote character used by the DelimitedText property.
        Use QuoteChar to get or set the quote character that is used to enclose individual strings in the DelimitedText property.
        When QuoteChar is set to the null character, then DelimitedText does the following: 
        
        At reading, does not return quoted list items.
        At assigning, does not check an assigning value for quote char.
        That is, you can set QuoteChar to the null character to disable quoting in DelimitedText. To set the QuoteChar to the null character, do the following:
        
        
        Delphi:
        
        MyStringList.QuoteChar := #0;
        
        
        
        C++:
        
        MyStringList->QuoteChar = '\\0';"""
    StrictDelimiter: bool
    """bool: Determines how the Delimiter property is used.
        If StrictDelimiter is True, individual strings in DelimitedText are only separated by Delimiter or quoted between  QuoteChar. If StrictDelimiter is False, spaces and non-printable character are also used as delimiters.
        
        Tip: You can set QuoteChar to the null character (#0 in Delphi, '\\0' in C++) if you do not want quoted strings to be extracted as if they where surrounded by Delimiter."""
    Strings: str
    """str:"""
    StringsAdapter: IStringsAdapter
    """IStringsAdapter: Implements an IStringsAdapter interface for the TStrings object.
        
        StringsAdapter specifies the attached TStringsAdapter when it is used in OLE applications.
        
        Note: To create a StringsAdapter you can use GetOleStrings and SetOleStrings instead of creating an instance of TStringsAdapter. StringsAdapter is used internally with OLE applications."""
    Text: Any
    """Lists the strings in the TStrings object as a single string with the individual strings delimited by carriage returns and line feeds."""
    TrailingLineBreak: bool
    """bool: Determines whether to add a line Break after the last line of the Text property or not.
        Use TrailingLineBreak to add a finishing line break to Text. Set TrailingLineBreak to True to add a  line Break after the last line of Text. Set TrailingLineBreak to False to finish Text without a  line Break. Default is True."""
    Updating: bool
    """bool: Indicates whether or not the list of strings is in the middle of an update."""
    UseLocale: bool
    """bool: Determines the implementation that the list of strings must use for string comparison.
        Set UseLocale to True to use AnsiCompareStr and AnsiCompareText to compare strings.
        Set UseLocale to False to use CompareStr and CompareText. Default is True."""
    ValueFromIndex: str
    """str:"""
    Values: str
    """str:"""
    WriteBOM: bool
    """bool: Will cause SaveToStream and SaveToFile to write a BOM.
        Set WriteBOM to True to cause SaveToStream to write a BOM (byte-order mark) to the stream and to cause SaveToFile to write a BOM to the file."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Add(self, s) -> Any:
        """TStrings.Add(s)
        Adds a string to the TStrings object and returns the index position"""
    def AddObject(self, s, delphiobject) -> Any:
        """TStrings.AddObject(s, delphiobject)
        Adds a string and an associated Delphi object to the Strings and returns the index position"""
    def AddPair(self, Name: str, Value: str) -> Strings:
        """TStrings.AddPair(Name: str, Value: str) -> Strings
        Adds name-value pairs to the list of strings using fluent-style coding.
        AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
        TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding.\r
        Adds name-value pairs to the list of strings using fluent-style coding.
        AddPair adds name-value pairs using the current NameValueSeparator. You can also use AddPair to add name-value pairs and the corresponding AObject.
        TStrings returns a reference to the string list, allowing to populate the list using the fluent-style coding."""
    def AddStrings(self, Strings: Strings) -> None:
        """TStrings.AddStrings(Strings: Strings) -> None
        Adds the specified strings (and objects) to the current TStrings object.
        AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
        AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
        AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
        If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.\r
        Adds the specified strings (and objects) to the current TStrings object.
        AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
        AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
        AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
        If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised.\r
        Adds the specified strings (and objects) to the current TStrings object.
        AddStrings, with the Strings parameter of the TStrings type, appends strings and associated objects from the Strings object at the end of the string list in the current TStrings object.
        AddStrings with the Strings parameter representing the array of strings, appends strings from Strings array at the end of the string list in the current TStrings object.
        AddStrings, with two parameters, appends strings from Strings array at the end of the string list in the current TStrings object and associates references to objects from Objects with their strings (having the same numbers in Strings and Objects arrays).
        If the number of strings in Strings is not equal to the number of objects in Objects, then an exception is raised."""
    def Append(self, S: str) -> None:
        """TStrings.Append(S: str) -> None
        Adds a string to the list.
        Append is the same as the Add method, except that it does not return a value. Use Append when there is no need to know the index of the string after it has been added, or with descendants of TStrings for which the index returned is not meaningful. 
        For example, the TStrings descendant used by memo objects uses an index to determine where to insert a string, but the inserted string does not necessarily end up as a single string in the list. Part of the inserted text may become part of the previous string, and part may be broken off into a subsequent string. The index returned by Add is not meaningful in this case. 
        Use Append rather than Add as a parameter for a function requiring a TGetStrProc."""
    def Assign(self, Source: Persistent) -> None:
        """TStrings.Assign(Source: Persistent) -> None
        Sets the strings in the Strings array, possibly associated Objects, and some other properties of the current TStrings object, from the Source object.
        Use Assign to set the properties of the TStrings object from the Source object. If Source is of the TStrings type, Assign copies the following properties:
        
        Strings
        Objects
        DefaultEncoding
        Encoding
        LineBreak
        Delimiter
        QuoteChar
        NameValueSeparator
        Options
        If Source is not of the TStrings type, the inherited Assign will set the value of the string array from any object that supports TStrings in its AssignTo method."""
    def BeginUpdate(self) -> Any:
        """TStrings.BeginUpdate()
        Enables the TStrings object to track when the list of strings is changing."""
    def Clear(self) -> Any:
        """TStrings.Clear()
        Clears all strings from a TStrings (and the associated objects"""
    def Create(self, *args, **kwargs) -> Any:
        """Creates an instance of a TStrings object.
        Do not call the Create method for TStrings directly. TStrings is an abstract class and its constructor should only be called as an inherited method from the constructor of a derived class."""
    def Delete(self, i) -> Any:
        """TStrings.Delete(i)
        Deletes the string at Index i (and the associated object"""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TStrings instance and frees its memory.
        Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy."""
    def EndUpdate(self) -> Any:
        """TStrings.EndUpdate()
        Enables the TStrings object to keep track of when the list of strings has finished changing."""
    def Equals(self, Strings: Strings) -> bool:
        """TStrings.Equals(Strings: Strings) -> bool
        Compares the list of strings to the list from another TStrings object and returns true if the two lists match.
        Call Equals to compare the lists in two TStrings objects. Equals compares only the strings, not any references to associated objects. Equals returns true if the lists for both TStrings objects have the same number of strings and the strings in each list match. Equals returns false if the lists are different in length, if they contain different strings, or if the order of the strings in the two lists differ.
        
        Note:  The Equals method uses an overridden Get method to perform the compare, thus it does not provide a context-insensitive option."""
    def Exchange(self, Index1: int, Index2: int) -> None:
        """TStrings.Exchange(Index1: int, Index2: int) -> None
        Swaps the position of two strings in the list.
        Call Exchange to rearrange the strings in the list. The strings are specified by their index values in the Index1 and Index2 parameters. Indexes are zero-based, so the first string in the list has an index value of 0, the second has an index value of 1, and so on.
        If either string has an associated object, Exchange changes the position of the object as well."""
    def Get(self, Index: int) -> str:
        """TStrings.Get(Index: int) -> str
        Returns a string given its index.
        Get is the protected read implementation of the Strings property.
        In TStrings Get is abstract or, in C++ terminology, pure virtual, meaning it has no implementation. Descendant classes must override this method to return the string with the specified index."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TStrings enumerator.
        GetEnumerator returns a TStringsEnumerator reference, which enumerates the strings in a TStrings object. 
        To process all these strings, call the TStringsEnumerator GetCurrent method within a While MoveNext do loop."""
    def GetObject(self, Index: int) -> Object:
        """TStrings.GetObject(Index: int) -> Object
        Returns the object associated with the string at a specified index.
        GetObject is the protected read implementation of the Objects property.
        Index is the index of the string with which the object is associated.
        In TStrings, GetObject always returns nil (Delphi) or NULL (C++). This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override GetObject to return the specified object."""
    def GetText(self, *args, **kwargs) -> Any:
        """Allocates a text buffer and fills it with the value of the Text property.
        Call GetText to obtain a dynamically allocated character buffer containing all of the strings in the list. Individual strings are separated by a carriage return (#13) on the OS X operating system, or by a carriage return and a line feed (#13#10) on Windows operating systems. The caller is responsible for freeing the returned value using the StrDispose procedure."""
    def IndexOf(self, s) -> Any:
        """TStrings.IndexOf(s)
        Returns the Index of a string s or -1 if not found"""
    def IndexOfName(self, Name: str) -> int:
        """TStrings.IndexOfName(Name: str) -> int
        Returns the position of the first name-value pair with the specified name.
        Call IndexOfName to locate the first occurrence of a name-value pair where the name part is equal to the Name parameter or differs only in case. IndexOfName returns the 0-based index of the string. If no string in the list has the indicated name, IndexOfName returns -1.
        
        Note:  If there is more than one name-value pair with a name portion matching the Name parameter, IndexOfName returns the position of the first such string."""
    def IndexOfObject(self, AObject: Object) -> int:
        """TStrings.IndexOfObject(AObject: Object) -> int
        Returns the index of the first string in the list associated with a given object.
        Call IndexOfObject to locate the first string in the list associated with the object AObject. Specify the object you want to locate as the value of the AObject parameter. IndexOfObject returns the 0-based index of the string and object. If the object is not associated with any of the strings, IndexOfObject returns -1."""
    def Insert(self, Index: int, S: str) -> None:
        """TStrings.Insert(Index: int, S: str) -> None
        Introduces abstract (Delphi) or pure virtual (C++) method to insert a string at a specified position.
        Descendants of TStrings implement an Insert method to add the string S to the list at the position specified by Index. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on.
        All methods that add strings to the list use the Insert method to add the string.
        If the string has an associated object, use the InsertObject method instead."""
    def InsertObject(self, Index: int, S: str, AObject: Object) -> None:
        """TStrings.InsertObject(Index: int, S: str, AObject: Object) -> None
        Inserts a string into the list at the specified position, and associates it with an object.
        Call InsertObject to insert the string S into the list at the position identified by Index, and associate it with the object AObject. If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on."""
    def LoadFromFile(self, filename) -> Any:
        """TStrings.LoadFromFile(filename)
        Fills the list with the lines of text in a specified file."""
    def LoadFromStream(self, Stream: Stream) -> None:
        """TStrings.LoadFromStream(Stream: Stream) -> None
        Fills the list with lines of text read from a stream.
        LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
        If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
        If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream.\r
        Fills the list with lines of text read from a stream.
        LoadFromStream fills the string list of the TStrings object from the stream specified by Stream. The text read from the stream is parsed into strings separated by a carriage return and a line feed (#13#10) characters on Windows operating systems and a carriage return (#13) character on the macOS operating system. Thus, LoadFromStream reads the value of the Text property.
        If the Encoding parameter is not given, then the strings are loaded using the appropriate encoding. The value of the encoding is obtained by calling the GetBufferEncoding routine of the TEncoding class. LoadFromStream then saves the value of the encoding in the Encoding property, to be used if the stream is saved.
        If the stream is a file stream, LoadFromStream does the same thing as LoadFromFile, except that LoadFromFile creates and destroys the file stream."""
    def Move(self, CurIndex: int, NewIndex: int) -> None:
        """TStrings.Move(CurIndex: int, NewIndex: int) -> None
        Changes the position of a string in the list.
        Use Move to move the string at position CurIndex so that it occupies the position NewIndex. The positions are specified as 0-based indexes. For example, the following lines of code move the string in the first position to the last position:
        For Delphi:
        
        MyStringsObject.Move(0, MyStringsObject.Count - 1);
        
        For C++: 
        
        MyStringsObject->Move(0, MyStringsObject->Count - 1);
        
        If the string has an associated object, the object remains associated with the string in its new position."""
    def Put(self, Index: int, S: str) -> None:
        """TStrings.Put(Index: int, S: str) -> None
        Changes the value of the string with a specified index.
        Put is the protected write implementation of the Strings property.
        Put changes the value of the string with the index specified by Index to S. Put does not change the object at the specified position. That is, any object associated with the previous string becomes associated with the new string."""
    def PutObject(self, Index: int, AObject: Object) -> None:
        """TStrings.PutObject(Index: int, AObject: Object) -> None
        Changes the object associated with the string at a specified index.
        PutObject is the protected write implementation of the Objects property.
        As implemented in TStrings, PutObject does nothing. This provides a default implementation for descendants that do not support associating objects with the strings in the list. Descendants that support this feature override PutObject to change the specified object."""
    def SaveToFile(self, filename) -> Any:
        """TStrings.SaveToFile(filename)
        Saves the strings in the list to the specified file."""
    def SaveToStream(self, Stream: Stream) -> None:
        """TStrings.SaveToStream(Stream: Stream) -> None
        Writes the  value of the Text property to the Stream stream.
        SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
        If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
        If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 
        
        Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
        Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
        If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream.\r
        Writes the  value of the Text property to the Stream stream.
        SaveToStream gets all strings from the current TStrings object and combines them into the single string containing these strings delimited by LineBreak sequence. Then SaveToStream encodes this string using the specified Encoding. Then SaveToStream writes the encoded string into the specified Stream stream.
        If WriteBOM is True then SaveToStream first gets the preamble of the specified Encoding or of the DefaultEncoding (if Encoding = nil)  and writes the preamble bytes into the stream before the main string.
        If the Encoding parameter is not given, then the strings are saved with the encoding specified in the Encoding property. 
        
        Note:  On Windows, the default LineBreak value is a carriage return and line feed combination (#13#10), whereas on macOS, it is just a line feed (#10).
        Note:  If TrailingLineBreak is True, then SaveToStream writes a finishing line break LineBreak after the last string.
        If the stream is a file stream, SaveToStream does the same thing as SaveToFile, except that SaveToFile creates and destroys the file stream."""
    def SetStrings(self, Source: Strings) -> None:
        """TStrings.SetStrings(Source: Strings) -> None
        Sets the strings from another TStrings object to the list of strings.
        Use SetStrings to assign the value of the TStrings object from another TStrings object (Source).
        
        Note: SetStrings is similar to Assign, but Assign also copies multiple additional properties."""
    def SetText(self, Text: PWideChar) -> None:
        """TStrings.SetText(Text: PWideChar) -> None
        Sets the Text property.
        Call SetText to replace the list with the strings specified by the Text parameter. SetText adds strings one at a time to the list, using the carriage returns or linefeed characters in Text as delimiters indicating when to add a new string."""
    def ToObjectArray(self, *args, **kwargs) -> Any:
        """Returns the TObject array associated with Strings.
         
        Use ToObjectArray to obtain the array of TObject associated with Strings.
        
        Note: TStrings is an abstract class and this method has no effect. Descendent classes can associate objects with strings.
        Note:  The TStrings object does not own the objects in the Objects array. Objects added to the Objects array still exist even if the TStrings object is destroyed. They must be explicitly destroyed by the application."""
    def ToStringArray(self, *args, **kwargs) -> Any:
        """Converts a TStrings descendant to a string array.
         
        Use ToStringArray to obtain an array of strings for each string in the list."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __delitem__(self, other) -> Any:
        """Delete self[key]."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""
    def __setitem__(self, index, object) -> None:
        """Set self[key] to value."""

class StyleInfo:
    """wrapper for Delphi TStyleInfo type"""
    __hash__: ClassVar[None] = ...
    Author: Any
    """Provides access to the Author of a Style Info"""
    AuthorEMail: Any
    """Provides access to the Author E-Mail of a Style Info"""
    AuthorUrl: Any
    """Provides access to the Author URL of a Style Info"""
    Name: Any
    """Provides access to the Name of a Style Info"""
    Version: Any
    """Provides access to the Version of a Style Info"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class StyleManager(Object):
    """Handles styles-related operations.
    Use TStyleManager to:
    
    Register and unregister style classes.
    Set the active style.
    Load styles from files or resources.
    Retrieve styles and their descriptors.
    Replace and retrieve the style engine."""
    __hash__: ClassVar[None] = ...
    ActiveStyle: Any
    """Returns the current style."""
    DesignerStyle: CustomStyleServices
    """CustomStyleServices:"""
    Style: CustomStyleServices
    """CustomStyleServices:"""
    StyleDescriptor: StyleManager.TStyleClassDescriptor
    """StyleManager.TStyleClassDescriptor:"""
    StyleNames: Any
    """Provides access to the VCL style names."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    @classmethod
    def CheckSysClassName(cls, AClassName: str) -> bool:
        """TStyleManager.CheckSysClassName(AClassName: str) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def GetStyle(cls, Name: str) -> CustomStyleServices:
        """TStyleManager.GetStyle(Name: str) -> CustomStyleServices
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def HandleMessage(cls, Control: WinControl, Message: Message, DefWndProc: Callable[[Message],None]) -> bool:
        """TStyleManager.HandleMessage(Control: WinControl, Message: Message, DefWndProc: Callable[[Message], None]) -> bool
        Handles a message from a control.
        HandleMessage sends the message received from a control to the style engine.
        
        
        
        Parameter
        
        Meaning
        
        
        Control
        
        The component that passes the message.
        
        
        Message
        
        The message that is passed to the engine.
        
        
        DefWndProc
        
        The default window procedure to be called for the message."""
    @classmethod
    def Initialize(cls, *args, **kwargs) -> Any:
        """Initializes data about styles and style engines.
        
        Note: This function is reserved for internal use only. Do not call it directly."""
    @classmethod
    def IsCustomStyleAvailable(cls, AControl: Control) -> bool:
        """TStyleManager.IsCustomStyleAvailable(AControl: Control) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def IsSystemStyleDefault(cls, AControl: Control) -> bool:
        """TStyleManager.IsSystemStyleDefault(AControl: Control) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    def IsValidStyle(self) -> Any:
        """TStyleManager.IsValidStyle()
        Check if a Vcl Style file is valid"""
    @classmethod
    def LoadDesigningStyle(cls, FileName: str) -> StyleManager.TStyleServicesHandle:
        """TStyleManager.LoadDesigningStyle(FileName: str) -> StyleManager.TStyleServicesHandle
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def LoadDesigningStyles(cls, FileNames: tuple) -> None:
        """TStyleManager.LoadDesigningStyles(FileNames: tuple) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def LoadFromFile(self) -> Any:
        """TStyleManager.LoadFromFile()
        Loads a VCL style from a file"""
    @classmethod
    def LoadFromResource(cls, Instance: int, ResourceName: str) -> StyleManager.TStyleServicesHandle:
        """TStyleManager.LoadFromResource(Instance: int, ResourceName: str) -> StyleManager.TStyleServicesHandle
        Loads a style from the specified resource.
        Note that LoadFromResource does not automatically switch to the loaded style. To do that, call the SetStyle method.
        
        
        
        
        Parameter
        
        Meaning
        
        
        Instance
        
        The instance handle of the loaded resource.
        
        
        ResourceName
        
        The string associated with the resource.
        
        
        ResType
        
        A string that identifies the type of resource.\r
        Loads a style from the specified resource.
        Note that LoadFromResource does not automatically switch to the loaded style. To do that, call the SetStyle method.
        
        
        
        
        Parameter
        
        Meaning
        
        
        Instance
        
        The instance handle of the loaded resource.
        
        
        ResourceName
        
        The string associated with the resource.
        
        
        ResType
        
        A string that identifies the type of resource."""
    @classmethod
    def Notification(cls, Operation: CustomStyleEngine.TStyleEngineNotification, Data: Pointer) -> None:
        """TStyleManager.Notification(Operation: CustomStyleEngine.TStyleEngineNotification, Data: Pointer) -> None
        Notifies the style engine of an event that occured.
        
        
        
        Parameter
        
        Meaning
        
        
        Operation
        
        The action that is performed.
        
        
        Data
        
        The data on which the operation is executed."""
    @classmethod
    def RegisterStyle(cls, Style: CustomStyleServices) -> None:
        """TStyleManager.RegisterStyle(Style: CustomStyleServices) -> None
        Registers the instance of a style specified by the Style parameter."""
    @classmethod
    def RegisterStyleClass(cls, Extension: str, Description: str, ResourceType: str, StyleClass: CustomStyleServicesClass) -> None:
        """TStyleManager.RegisterStyleClass(Extension: str, Description: str, ResourceType: str, StyleClass: CustomStyleServicesClass) -> None
        Registers a style class with extension, description, and resource type.
        
        
        
        Parameter
        
        Meaning
        
        
        Extension
        
        A string that specifies the extension used with the style files.
        
        
        Description
        
        A string that specifies a description of the style.
        
        
        ResourceType
        
        A string associated with the resource type.
        
        
        StyleClass
        
        Specifies the style class to be registered.\r
        Registers a style class with extension, description, and resource type.
        
        
        
        Parameter
        
        Meaning
        
        
        Extension
        
        A string that specifies the extension used with the style files.
        
        
        Description
        
        A string that specifies a description of the style.
        
        
        ResourceType
        
        A string associated with the resource type.
        
        
        StyleClass
        
        Specifies the style class to be registered."""
    @classmethod
    def RemoveDesigningStyle(cls, Name: str) -> None:
        """TStyleManager.RemoveDesigningStyle(Name: str) -> None
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def ResetDesigningStyles(cls, *args, **kwargs) -> Any:
        """Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def SetDesigningStyle(cls, Name: str) -> None:
        """TStyleManager.SetDesigningStyle(Name: str) -> None
        Embarcadero Technologies does not currently have any additional information.\r
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def SetStyle(cls, Name: str) -> None:
        """TStyleManager.SetStyle(Name: str) -> None
        Sets the active style by name, instance, or handle.
        
        
        
        Parameter
        
        Meaning
        
        
        Name
        
        The name of the style to be set as the active style.
        
        
        Style
        
        A style instance to be set as the active style.
        
        
        Handle
        
        The handle of the style to be set as the active style, as returned by the LoadFromFile or LoadFromResource method.\r
        Sets the active style by name, instance, or handle.
        
        
        
        Parameter
        
        Meaning
        
        
        Name
        
        The name of the style to be set as the active style.
        
        
        Style
        
        A style instance to be set as the active style.
        
        
        Handle
        
        The handle of the style to be set as the active style, as returned by the LoadFromFile or LoadFromResource method.\r
        Sets the active style by name, instance, or handle.
        
        
        
        Parameter
        
        Meaning
        
        
        Name
        
        The name of the style to be set as the active style.
        
        
        Style
        
        A style instance to be set as the active style.
        
        
        Handle
        
        The handle of the style to be set as the active style, as returned by the LoadFromFile or LoadFromResource method."""
    @classmethod
    def TryLoadFromResource(cls, Instance: int, ResourceName: str, ResourceType: PWideChar, Handle: StyleManager.TStyleServicesHandle) -> bool:
        """TStyleManager.TryLoadFromResource(Instance: int, ResourceName: str, ResourceType: PWideChar, Handle: StyleManager.TStyleServicesHandle) -> bool
        Loads a style from a resource without raising an exception.
        TryLoadFromResource returns True if the style was successfully loaded, or False otherwise. 
        
        
        
        Parameter
        
        Meaning
        
        
        Instance
        
        The instance handle of the loaded resource.
        
        
        ResourceName
        
        The string associated with the resource.
        
        
        ResType
        
        A string that identifies the type of resource.
        
        
        Handle
        
        The handle of the loaded style."""
    @classmethod
    def TrySetDesigningStyle(cls, Name: str, ShowErrorDialog: bool) -> bool:
        """TStyleManager.TrySetDesigningStyle(Name: str, ShowErrorDialog: bool) -> bool
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def TrySetStyle(cls, Name: str, ShowErrorDialog: bool) -> bool:
        """TStyleManager.TrySetStyle(Name: str, ShowErrorDialog: bool) -> bool
        Sets the style specified by name as the active style, without raising an exception.
        TrySetStyle returns True if the style was successfully set as the active style, and False otherwise.
        
        
        
        Parameter
        
        Meaning
        
        
        Name
        
        A string that specifies the name of the style to be set as active.
        
        
        ShowErrorDialog
        
        Specifies whether an error dialog box is shown if the style cannot be set as the active style."""
    @classmethod
    def UnInitialize(cls, *args, **kwargs) -> Any:
        """Uninitializes data about styles and style engines.
        
        Note: This function is reserved for internal use only. Do not call it directly."""
    @classmethod
    def UnRegisterStyle(cls, Style: CustomStyleServices) -> None:
        """TStyleManager.UnRegisterStyle(Style: CustomStyleServices) -> None
        Embarcadero Technologies does not currently have any additional information."""
    @classmethod
    def UnRegisterStyleClass(cls, StyleClass: CustomStyleServicesClass) -> None:
        """TStyleManager.UnRegisterStyleClass(StyleClass: CustomStyleServicesClass) -> None
        Unregisters a style class specified by the StyleClass parameter."""
    @classmethod
    def UnRegisterStyleEngine(cls, AEngineClass: CustomStyleEngineClass) -> None:
        """TStyleManager.UnRegisterStyleEngine(AEngineClass: CustomStyleEngineClass) -> None
        Unregisters the style engine specified by the AEngineClass parameter."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TabControl(CustomTabControl):
    """TTabControl is a tab set that has the appearance of notebook dividers.
    Use TTabControl to add a control with multiple tab settings to a form. Unlike a page control, TTabControl is not made up of several pages that contain different controls. Instead, TTabControl is a single object. When the current tab changes, the tab control must directly update its contents to reflect the change in an OnChange event handler.
    Disabling a TTabControl object disables all tabs because it is one control. To disable individual tabs, use TPageControl and disable the individual TTabSheet controls that represent the pages.
    
    Note:  When using one of the page controls, if you want to restrict a user from switching to a tab, you cannot set TTabSheet.Enabled to false to accomplish that restriction. Instead, use the OnChanging event to prevent the user from selecting a tab.
    The Tabs property can be used to define an accelerator key to a tab item of the TTabControl."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    DisplayRect: Rect
    """Rect: Specifies the bounding rectangle of a tab control client area.
        Use DisplayRect to obtain the coordinates, in pixels, of the portion of the tab control that represents the contents of the tab pages. The appearance of this portion of the tab control does not change when different tabs are selected. 
        Use DisplayRect rather than the ClientRect property to determine the portion of the tab control that can contain other objects."""
    DockSite: bool
    """bool: Specifies whether the control can be the target of drag-and-dock operations.
        Set DockSite to true to allow other controls to be docked to this windowed control.
        
        Code Examples
        Docking (Delphi)
        Docking (C++)"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HotTrack: bool
    """bool: Determines whether labels on the tab under the mouse are automatically highlighted.
        Set HotTrack to true to provide visual feedback to the user about which tab would be selected if the mouse button is clicked. HotTrack is especially useful when the tab control contains multiple rows of tabs."""
    Images: CustomImageList
    """CustomImageList: Specifies the images drawn in tabs.
        Images specifies the images that are drawn in tabs. For disabled tabs, grayed versions of the images are used. 
        In the implementation of TCustomTabControl, the order of images in image list properties directly corresponds to the associated tabs in the control. In the descendant class, TPageControl, this behavior is replaced by support for individual  TTabSheet objects, each with an ImageIndex property. In any case, the application programmer can define customized image displays by defining an OnGetImageIndex event handler."""
    MultiLine: bool
    """bool: Determines whether the tabs can appear on more than one row.
        Use MultiLine to determine how the tabs are displayed. If MultiLine is true, the tabs are displayed on more than one row when the number of tabs exceeds the number that fits across the top of the tab control. How many rows is determined by how many tabs are in the tab control. If MultiLine is false, the tabs are displayed on one row only, and the user must scroll the displayed scroll arrows to view all the tabs."""
    MultiSelect: bool
    """bool: Specifies whether multiple tabs can be selected.
        Use MultiSelect to get or set whether multiple tabs can be selected.
        MultiSelect can only be true if Style is tsFlatButtons or tsButtons."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnChanging: Callable[[Object,bool],None]
    """Callable[[Object, bool], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDockDrop: Callable[[Object,DragDockObject,int,int],None]
    """Callable[[Object, DragDockObject, int, int], None]:"""
    OnDockOver: Callable[[Object,DragDockObject,int,int,DragState,bool],None]
    """Callable[[Object, DragDockObject, int, int, DragState, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnDrawTab: Callable[[CustomTabControl,int,Rect,bool],None]
    """Callable[[CustomTabControl, int, Rect, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetImageIndex: Callable[[Object,int,int],None]
    """Callable[[Object, int, int], None]:"""
    OnGetSiteInfo: Callable[[Object,Control,Rect,Point,bool],None]
    """Callable[[Object, Control, Rect, Point, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnUnDock: Callable[[Object,Control,WinControl,bool],None]
    """Callable[[Object, Control, WinControl, bool], None]:"""
    OwnerDraw: bool
    """bool: Specifies whether the tab control handles its own painting.
        Set OwnerDraw to true to override any default painting behavior."""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    RaggedRight: bool
    """bool: Specifies whether rows of tabs stretch to fill the width of the control.
        Use RaggedRight to get or set whether rows of tabs stretch to fill the width of the control."""
    ScrollOpposite: bool
    """bool: Determines how the rows of tabs are scrolled in a multi-line tab control.
        Set ScrollOpposite to determine where previous rows of tabs in a multi-line tab control move when the user selects a tab in another row. When ScrollOpposite is true, previous rows of tabs are moved to the bottom of the tab control if TabPosition is tpTop, or to the top if TabPosition is tpBottom. When ScrollOpposite is false, previous rows of tabs are moved to the back of all other rows of tabs.
        For example, in a tab control with three rows of tabs at the top, if the user selects a tab in the second row, ScrollOpposite determines where the first row moves. If ScrollOpposite is true, the second row now appears at the front (bottom) row on top of the tab control, followed by the third row behind (above) it. The first row moves to the bottom of the tab control. If ScrollOpposite is false, the first row moves to the back (top), so that the tab control displays the second row in front (at the bottom of the tab region), followed by the third row (now in the middle), followed by the first row.
        
        Note:  Setting ScrollOpposite to true automatically sets the MultiLine property to true."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    Style: TabStyle
    """TabStyle: Specifies the style of the tab control.
        Use Style to determine the appearance of the tabs. These can appear as notebook tabs or as buttons."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabHeight: int
    """int: Specifies the height, in pixels, of the tabs in the tab control.
        Set TabHeight to control the height of the tabs that appear above the client region of the tab control. The TabHeight property is the vertical size in pixels of the individual tabs. If TabHeight is set to 0, the tabs automatically size themselves to fit their text."""
    TabIndex: int
    """int: Identifies the selected tab on a tab control.
        Read TabIndex to determine which tab was selected by the user. TabIndex is the index of the tab in the list of labels maintained by the Tabs property. The first (leftmost) tab has a TabIndex of 0, the next has 1, and so on. If no tabs are selected, TabIndex has a value of -1.
        Set TabIndex to programmatically change the selected tab in the tab control."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabPosition: TabPosition
    """TabPosition: Determines whether tabs appear at the top or bottom.
        Set TabPosition to tpTop to display the tabs at the top of the tab control. Set TabPosition to tpBottom to display the tabs at the bottom. If the ScrollOpposite property is True, tabs can appear at both top and bottom, with the row containing the current tab and all subsequent rows on the side indicated by TabPosition.
        Due to a limitation in the windows common control, if TabPosition is tpLeft or tpRight, Font must be a True Type font. Otherwise, tab text may paint incorrectly."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    TabWidth: int
    """int: Specifies the horizontal size, in pixels, of the tabs in the tab control.
        TabWidth specifies a fixed width for all tabs. If TabWidth is 0, then each tab is automatically made wide enough to show its caption."""
    Tabs: Strings
    """Strings: Contains the list of text strings that label the tabs of the tab control.
        Tabs contains a TStrings, a list of strings that label the tabs in the tab control.  To add new tabs to the tab control or to edit the tabs themselves, add a new string or edit the strings currently in the Tabs property. (To open the String List editor, double-click the Tabs property in the Object Inspector.) To rearrange the tabs, rearrange the list of strings. 
        Tabs can also contain objects associated with the labels, using the System.Classes.TStrings.Objects property."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TabSheet(WinControl):
    """TTabSheet is an individual page in a TPageControl object.
    Use TTabSheet to represent a single page in a tabbed page control. Tab sheets are typically referred to as pages. TPageControl maintains an indexed array of its tab sheets in its Pages property. Users can click on a tab to activate the tab sheet.
    You can use the Caption property of the TTabSheet control to define an accelerator key to a page of the TPageControl."""
    __hash__: ClassVar[None] = ...
    BorderWidth: int
    """int: Specifies the width of the control's border.
        Use BorderWidth to get or set the width of the control's border. Graphics or text drawn by the control is clipped to the area within the border."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    Highlighted: bool
    """bool: Indicates whether the tab sheet appears highlighted.
        Use Highlighted to make a tab sheet stand out visually. When Highlighted is true, the tab sheet is drawn using a highlight color so that it stands out visually from other tab sheets.
        
        Note: Highlighted is not linked to the active page of the host page control. A page control can have only one active page, but can have multiple highlighted pages."""
    ImageIndex: int
    """int: Specifies an image for the tab.
        Use ImageIndex to get or set the index of an image to be drawn in the tab. This index identifies an image from the Images property of the page control that contains the tab sheet. Specify -1 to prevent an image from being drawn."""
    ImageName: str
    """str: Displays the name of linked items from the Image Collection."""
    Left: int
    """int: Specifies the horizontal coordinate of the left edge of a component relative to its parent.
        Use the Left property to determine where the left side of the control begins or to reposition the left side of the control.
        If the control is contained in another control, the Left and Top properties are relative to the parent control. If the control is contained directly by the form, the property values are relative to the form. For forms, the value of the Left property is relative to the screen in pixels."""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnHide: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnShow: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    PageControl: Any
    """Indicates the page control object that contains the tab sheet."""
    PageIndex: int
    """int: Indicates the index of the tab sheet in the list of tab sheets maintained by the page control.
        Use PageIndex to determine where the tab sheet sits in its page control. Each tab sheet in a page control is automatically assigned a PageIndex when it is inserted in the page control. The first tab sheet receives a value of 0, the second has a value of 1, and so on. PageIndex values are reassigned if tab sheets are deleted or moved.
        To access a particular tab sheet given its index value, use the indexed Pages property of the TPageControl object."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabIndex: Any
    """Indicates the position of the tab sheet in the set of visible tabs in a TPageControl object."""
    TabVisible: bool
    """bool: Specifies whether the tab of the TTabSheet object appears in its TPageControl.
        Use TabVisible to temporarily remove a tab sheet from a page control. When TabVisible is false, the tab does not appear in the page control and its TabIndex property is -1. Setting TabVisible to true allows the user to see the tab of the tab sheet again."""
    Top: int
    """int: Specifies the Y coordinate of the upper-left corner of a control, relative to its parent or containing control in pixels.
        Use Top to locate the top of the control or reposition the control to a different Y coordinate. The Top property, like the Left property, is the position of the control relative to its container. Thus, if a control is contained in a TPanel, the Left and Top properties are relative to the panel. If the control is contained directly by the form, it is relative to the form. For forms, the value of the Top property is relative to the screen in pixels."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TTabSheet.Create(AOwner: Component) -> None
        Creates and initializes an instance of TTabSheet.
        Call Create to instantiate a tab sheet at runtime. Tab sheets added to a page control at design time are created automatically.
        Create calls the inherited Create method, then sets the initial values for the tab sheet component.
        When creating tab sheets at runtime, use the PageControl property to insert them into a page control object."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TTabSheet.
        Do not call Destroy directly at runtime. Instead, call Free. Free verifies that the tab sheet is not nil and only then calls Destroy. Destroy removes the tab sheet from the page control and then calls the inherited Destroy method."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class Timer(Component):
    """TTimer encapsulates the Windows API timer functions.
    TTimer is used to simplify calling the Windows API timer functions SetTimer and KillTimer, and to simplify processing the WM_TIMER messages. Use one timer component for each timer in the application.
    The execution of the timer occurs through its OnTimer event. TTimer has an Interval property that determines how often the timer's OnTimer event occurs. The interval corresponds to the parameter for the Windows API SetTimer function.
    
    Warning: Limitations on the total number of timers system-wide are system-dependent."""
    __hash__: ClassVar[None] = ...
    ComponentCount: Any
    """Returns the owned component count"""
    Components: Any
    """Returns an iterator over the owned components"""
    Enabled: bool
    """bool: Controls whether the timer generates OnTimer events periodically.
        Use Enabled to enable or disable the timer. If Enabled is true, the timer responds normally. If Enabled is false, the timer does not generate OnTimer events. The default is true."""
    Interval: int
    """int: Determines the amount of time, in milliseconds, that passes before the timer component initiates another OnTimer event.
        Interval determines how frequently the OnTimer event occurs. Each time the specified interval passes, the OnTimer event occurs.
        Use Interval to specify any cardinal value as the interval between OnTimer events. The default value is 1000 (one second).
        
        Note:   A 0 value is valid, however the timer will not call an OnTimer event for a value of 0."""
    OnTimer: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Owner: Any
    """Returns the Component Owner"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BindMethodsToEvents(self, prefix) -> Any:
        '''TComponent.BindMethodsToEvents(prefix)
        Connects methods to component events if they are named using the following pattern: Prefix_ComponentName_EventName.
        Example: def handle_button1_OnClick(Sender): pass
        The function returns a list of tuples. Each tuple contains the name of the component, the name of the event and the method object assigned to the event.
        Note that the prefix parameter is optional and will default to "handle_".'''
    def Create(self, AOwner: Component) -> None:
        """TTimer.Create(AOwner: Component) -> None
        Instantiates a timer object.
        Call Create to instantiate a timer at runtime. Timers added to forms or data modules at design time are created automatically.
        AOwner specifies the component, typically a form or data module, that is responsible for freeing the timer."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Disposes of a timer object.
        Do not call Destroy directly in an application. Instead, an application should call Free. Free verifies that the timer is not nil before it calls Destroy.
        Destroy deactivates the timer by setting Enabled to False before freeing the resources required by the timer."""
    def GetParentComponent(self) -> Any:
        """TComponent.GetParentComponent()
        Returns the parent of a component."""
    def HasParent(self) -> Any:
        """TComponent.HasParent()
        Indicates whether the component has a parent to handle its filing."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ToggleSwitch(CustomToggleSwitch):
    """A clickable control that allows a user to toggle between an On state and an Off state."""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Alignment: LeftRight
    """LeftRight: Specifies whether the toggle switch caption is displayed on the right or the left side.
        Default is taRightJustify."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSize: bool
    """bool: Indicates whether the control adjusts its bounds based on the SwitchHeight, SwitchWidth, and StateCaptions properties.
        Default is True."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    DisabledColor: int
    """int: The color of the toggle switch when it is disabled.
        Default is clBtnShadow."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    FrameColor: int
    """int: The color of the toggle switch frame.
        Default is clWindowText."""
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    HelpContext: int
    """int: The HelpContext property contains the numeric context ID that identifies the Help topic for the control.
        In case of a .chm help file, you must map symbolic Context IDs of Help topics to numeric topic ID values in the [MAP] section of your project (.hhp) file.
        To enable Context ID-based context-sensitive Help for a control, set Vcl.Controls.TControl.HelpType to htContext and set HelpContext to a numeric topic ID. 
        A topic ID of 0 (default) means that no Help topic is provided for the control. 
        To use the Help, insert in the uses clause of your application the Vcl.HtmlHelpViewer or another unit that provides an interface to the external Help viewer to use. For C++, you need to include the HTMLHelpViewer.hpp header file."""
    Hint: str
    '''str: Hint contains the text string that appears when the user moves the mouse over the control.
        Use the Hint property to provide a string of Help text either as a Help Hint or as Help text on a particular location, such as a status bar. 
        A Help Hint is a box containing Help text that appears for a control when the user moves the mouse pointer over the control and pauses momentarily. 
        To set up Help Hints
        
        Specify the Hint property of each control for which a Help Hint should appear.
        Set the ShowHint property of each appropriate control to True, or set the ParentShowHint property of all controls to True and set the ShowHint property of the form to True.
        At run time, set the value of the application\'s ShowHint property to True.
        To show the Hint on a status bar or another location, use the OnHint event handler of the application. The application\'s OnHint event occurs when the mouse pointer moves over the control.
        Specify a hint to be used for both a Help Hint box and by an OnHint event handler by specifying values separated by a | (pipe) character.
        For example,
        
        Edit1.Hint := \'Name|Enter Name in the edit box|1\';
        
        Edit1->Hint = "Name|Enter Name in the edit box|1";
        
        Here:
        
        The Name part is the short hint and appears at the top of the Help Hint box.
        Enter full name in the edit box is the long hint and appears below the short hint. It can be extracted using the GetLongHint function for use in an OnHint event handler.
        1 is an optional image index in an image list in the Images property of the control and specifies the index of the image to appear in the hint.
        If Hint contains only one value, the entire string is used as a Help Hint and returned by the GetLongHint and GetShortHint functions. If a control has no Hint value specified, but its parent control does, the control uses the value of the parent control (as long as the control\'s ShowHint property is True). 
        
        Note: If the application\'s ShowHint property is False, the Help Hint does not appear, but the OnHint event handler is still called.'''
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ReadOnly: bool
    """bool: Indicates whether the toggle switch is in read-only mode.
        If True, the user cannot change the state of the toggle switch. You can still change the State programatically.
        Default is False."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    ShowStateCaption: bool
    """bool: Indicates whether to display the captions of the switch.
        Default is True."""
    State: ToggleSwitchState
    """ToggleSwitchState: The current state of the toggle switch.
        Possible values are:
        
        tssOff: Default. The toggle switch is in the off state.
        tssOn: The toggle switch is in the on state."""
    StateCaptions: ToggleSwitchStateCaptions
    """ToggleSwitchStateCaptions: The captions of the toggle switch."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    SwitchHeight: int
    """int: The height of the toggle switch excluding the captions."""
    SwitchWidth: int
    """int: The width of the toggle switch excluding the captions."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    ThumbColor: int
    """int: The color of the toggle switch thumb.
        Default is clWindowText."""
    ThumbWidth: int
    """int: The width of the thumb inside the toggle switch frame."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ToolBar(WinControl):
    """TToolBar manages tool buttons and other controls, arranging them in rows and automatically adjusting their sizes and positions.
    TToolBar is a container for tool buttons (TToolButton). It provides an easy way to arrange and manage visual controls.
    All tool buttons on a toolbar maintain a uniform width and height.
    Other controls can sit on a toolbar. These controls (which are held in place by invisible tool buttons) maintain a uniform height.
    Controls can automatically wrap around and start a new row when they do not fit horizontally on the toolbar.
    The Flat property allows the background to show through the toolbar and gives pop-up borders to the tool buttons.
    Spaces and dividers (which are in fact specially configured tool buttons) can group controls on the toolbar both visually and functionally.
    Typically, the tool buttons correspond to items in an application's menu and give the user more direct access to the application's commands."""
    __hash__: ClassVar[None] = ...
    Actions: Any
    """Lists the buttons of the toolbar."""
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    AllowTextButtons: bool
    """bool: Determines whether tool buttons that consist only of text can be placed on the Toolbar.
        When set to true, the tbsTextButton style is available for the TToolButton control, allowing you to create tool buttons on the Toolbar that consist only of text. When set to false, the tbsTextButton style is not available for the TToolButton control."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    BorderWidth: int
    """int: Specifies the width of the control's border.
        Use BorderWidth to get or set the width of the control's border. Graphics or text drawn by the control is clipped to the area within the border."""
    ButtonCount: Any
    """Indicates the number of buttons in the toolbar."""
    ButtonHeight: int
    """int: Specifies the height of the controls in the toolbar.
        ButtonHeight represents the height, in pixels, of the controls in the toolbar."""
    ButtonWidth: int
    """int: Specifies the width of the tool buttons (TToolButton) in the toolbar.
        ButtonWidth represents the width, in pixels, of the TToolButton components on the toolbar. It has no effect on tool buttons whose Style property is set to tbsSeparator or tbsDivider."""
    Buttons: ToolButton
    """ToolButton:"""
    Canvas: Canvas
    """Canvas: Specifies the drawing surface for the toolbar.
        Use Canvas to draw or paint on the surface of the toolbar in an OnCustomDraw or OnCustomDrawButton event handler. The TCanvas object provides the properties and methods needed for drawing and painting."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    Customizable: bool
    """bool: Specifies whether the user can customize the toolbar at runtime.
        Set Customizable to true to allow the user to add, delete, and move toolbar buttons at runtime. There are two ways the user can change a customizable toolbar:
        By holding the shift key, the user can drag a button to a new position on the tool bar, or drag it off the toolbar entirely to delete the button.
        By double-clicking on the toolbar, the user can display the toolbar customize dialog. The toolbar customize dialog shows all the possible buttons in two list boxes, one that contains buttons not on the tool bar, and one that contains buttons currently on the tool bar. The user can use this dialog to add or remove buttons and to change their order.
        
        Note:  When Customizable is true, a number of events inform the tool bar component when the user makes changes."""
    CustomizeKeyName: str
    """str: Specifies the registry key where the tool bar saves its current button configuration before the user changes it using the toolbar customize dialog.
        Use CustomizeKeyName to specify where the toolbar saves its button configuration when the user first displays the toolbar customize dialog. This is a subkey of HKEY_CURRENT_USER. 
        When the user double-clicks the tool bar to display the toolbar customize dialog, the tool bar receives an OnCustomizing event and then automatically saves its current configuration to this key using the name specified by the CustomizeValueName property. If the user instructs the dialog to restore this configuration, the toolbar fetches the saved configuration from this registry key."""
    CustomizeValueName: str
    """str: Specifies the registry value under which the tool bar saves its current button configuration before the user changes it using the toolbar customize dialog.
        Use CustomizeValueName to specify the name that the toolbar uses to save its button configuration when the user first displays the toolbar customize dialog. This is a value under the registry key specified by the CustomizeKeyName property.
        When the user double-clicks the tool bar to display the toolbar customize dialog, the tool bar receives an OnCustomizing event and then automatically saves its current configuration to the Registry using this value. If the user instructs the dialog to restore this configuration, the toolbar fetches this saved configuration."""
    DisabledImages: CustomImageList
    """CustomImageList: Lists the images that can appear on disabled tool buttons.
        DisabledImages contains a list of images that can appear on tool buttons when they are disabled. Each tool button's ImageIndex property determines the specific image displayed on it. If DisabledImages is unassigned, disabled tool buttons display grayed versions of their regular images (specified by the Images property)."""
    DockSite: bool
    """bool: Specifies whether the control can be the target of drag-and-dock operations.
        Set DockSite to true to allow other controls to be docked to this windowed control.
        
        Code Examples
        Docking (Delphi)
        Docking (C++)"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    DrawingStyle: TBDrawingStyle
    """TBDrawingStyle: Stores the style type.
        This property stores either the dsNormal or dsGradient style choice."""
    EdgeBorders: EdgeBorders
    """EdgeBorders:"""
    EdgeInner: EdgeStyle
    """EdgeStyle:"""
    EdgeOuter: EdgeStyle
    """EdgeStyle:"""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Flat: bool
    """bool: Makes the toolbar transparent and eliminates tool-button borders.
        If Flat is set to true, the toolbar and its tool buttons are transparent; background colors and graphics show through them. In addition, when Flat is true, tool buttons (TToolButton) on the toolbar have pop-up borders that appear only when the mouse is passed over the button."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    GradientDirection: GradientDirection
    """GradientDirection: Specifies whether the direction of the gradient is horizontal or vertical.
        This property stores the value for the gradient direction."""
    GradientDrawingOptions: TBGradientDrawingOptions
    """TBGradientDrawingOptions: Stores the drawing option chosen.
        This property contains either the gdoHotTrack or gdoGradient option, depending on which one was chosen."""
    GradientEndColor: int
    """int: Color used as end color for the gradient.
        This property stores the color that is used to paint the gradient when the drawing ends. (The end color blends with the start color)."""
    GradientStartColor: int
    """int: Color used as start color for the gradient.
        The property stores the value that represents the drawing color when the gradient starts painting."""
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    HideClippedButtons: bool
    """bool: Specifies handling of buttons obscured by adjacent toolbar.
        If HideClippedButtons is set to true, any button partially obscured by a neighboring band is hidden."""
    HotImages: CustomImageList
    """CustomImageList: Lists the images that can appear on tool buttons when the mouse points to them.
        HotImages contains a list of images that can appear on tool buttons when the mouse passes over them at runtime. Each tool button's ImageIndex property determines the specific image displayed when the mouse points to it. If HotImages is unassigned, tool buttons retain their regular images (specified by the Images property) when pointed to. Use a TImageList control to hold the images that will be shown for hot images. Typically, then, the application will have two TImageList controls, one for the Images property and one for the HotImages property.
        To use HotImages set the Flat property to True."""
    HotTrackColor: int
    """int: Color used as hot tracking color when in gradient style.
        This is the color used as the hot tracking color when the toolbar's DrawingStyle property is set to dsGradient. The hot tracking color is the color the button turns when the mouse moves over it."""
    Images: CustomImageList
    """CustomImageList: Lists the images that can appear on tool buttons.
        Images contains a list of images that can appear on the toolbar's tool buttons. Each tool button's ImageIndex property determines the specific image displayed on it. If Images is unassigned, no images are displayed on the tool buttons.
        Images in the list should be 16x16."""
    Indent: int
    """int: Specifies the margin on the left side of the toolbar.
        Indent specifies, in pixels, the margin that separates the left edge of the toolbar from the controls within it."""
    List: bool
    """bool: Aligns captions on the right and images on the left in tool buttons.
        When List is false, tool buttons (TToolButton) appear in the toolbar with their images (if any) centered and their captions (if visible) underneath. Setting List to true aligns captions to the right and images to the left."""
    Menu: MainMenu
    """MainMenu: Causes the toolbar to populate itself with buttons that correspond to items in a menu.
        Use the menu property to populate the tool bar to match a menu component. Setting Menu causes the toolbar to delete all of its current buttons and replace them with tool buttons that match the items in the specified menu component.
        In applications that use Menu to populate the toolbar, do not change the Buttons property by adding, deleting, or editing toolbar buttons.
        
        Note:  The toolbar does not dynamically track any changes to the menu specified by Menu. That is, it sets the tool buttons to reflect the set of items in the menu at the point when the application sets this property, and ignores any subsequent changes."""
    OnAdvancedCustomDraw: Callable[[ToolBar,Rect,CustomDrawStage,bool],None]
    """Callable[[ToolBar, Rect, CustomDrawStage, bool], None]:"""
    OnAdvancedCustomDrawButton: Callable[[ToolBar,ToolButton,CustomDrawState,CustomDrawStage,TBCustomDrawFlags,bool],None]
    """Callable[[ToolBar, ToolButton, CustomDrawState, CustomDrawStage, TBCustomDrawFlags, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnCustomDraw: Callable[[ToolBar,Rect,bool],None]
    """Callable[[ToolBar, Rect, bool], None]:"""
    OnCustomDrawButton: Callable[[ToolBar,ToolButton,CustomDrawState,bool],None]
    """Callable[[ToolBar, ToolButton, CustomDrawState, bool], None]:"""
    OnCustomizeAdded: Callable[[ToolBar,ToolButton],None]
    """Callable[[ToolBar, ToolButton], None]:"""
    OnCustomizeCanDelete: Callable[[ToolBar,int,bool],None]
    """Callable[[ToolBar, int, bool], None]:"""
    OnCustomizeCanInsert: Callable[[ToolBar,int,bool],None]
    """Callable[[ToolBar, int, bool], None]:"""
    OnCustomizeDelete: Callable[[ToolBar,ToolButton],None]
    """Callable[[ToolBar, ToolButton], None]:"""
    OnCustomizeNewButton: Callable[[ToolBar,int,ToolButton],None]
    """Callable[[ToolBar, int, ToolButton], None]:"""
    OnCustomizeReset: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCustomized: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCustomizing: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDockDrop: Callable[[Object,DragDockObject,int,int],None]
    """Callable[[Object, DragDockObject, int, int], None]:"""
    OnDockOver: Callable[[Object,DragDockObject,int,int,DragState,bool],None]
    """Callable[[Object, DragDockObject, int, int, DragState, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetSiteInfo: Callable[[Object,Control,Rect,Point,bool],None]
    """Callable[[Object, Control, Rect, Point, bool], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnResize: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnUnDock: Callable[[Object,Control,WinControl,bool],None]
    """Callable[[Object, Control, WinControl, bool], None]:"""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    RowCount: int
    """int: Indicates the number of rows in the toolbar.
        Reading RowCount returns the number of rows in which the tool buttons are arranged."""
    ShowCaptions: bool
    """bool: Determines whether text captions are displayed on tool buttons.
        If ShowCaptions is set to true, tool buttons appear in the toolbar with their captions displayed. Setting ShowCaptions to true may increase the size of the tool buttons."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Transparent: bool
    """bool: Specifies whether the toolbar is transparent.
        Use Transparent to get or set whether the toolbar is transparent. Note the Transparent property applies only to the toolbar itself not its buttons.
        
        Tip:  To avoid painting problems, set the Transparent property before the toolbar becomes visible."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    Wrapable: bool
    """bool: Enables automatic line-wrap for components in the toolbar.
        If Wrapable is true, components automatically wrap around and form new rows when they do not fit horizontally in the toolbar."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TToolBar.Create(AOwner: Component) -> None
        Creates and initializes a TToolBar instance.
        Call Create to create a toolbar at runtime. Toolbars added to forms at design time are created automatically.
        AOwner is the component, typically the form, that is responsible for freeing the toolbar instance. It becomes the value of the Owner property."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TToolBar instance and frees its memory.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TToolBar reference is not nil, and only then calls Destroy."""
    def FlipChildren(self, AllLevels: bool) -> None:
        """TToolBar.FlipChildren(AllLevels: bool) -> None
        Prevents the toolbar buttons from reversing position when the parent control is flipped.
        FlipChildren overrides the inherited method in order to prevent the flipping of the toolbar's children."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TToolBar.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Allows the streaming system to load and save child controls in the order they appear in the toolbar.
        GetChildren is introduced in TComponent for the streaming system that loads and saves VCL components. It executes the callback specified by Proc for all the button in the toolbar, as well as any other controls that have the toolbar as a parent and the component specified by Root as an Owner.
        Proc is a callback that the streaming system uses to load or save persistent objects on a form.
        Root is the the top-level component (such as a form or data module) that is currently being loaded or saved."""
    def GetEnumerator(self, *args, **kwargs) -> Any:
        """Returns a TComponent enumerator.
        Vcl.ComCtrls.TToolBar.GetEnumerator inherits from System.Classes.TComponent.GetEnumerator. All content below this line refers to System.Classes.TComponent.GetEnumerator.
        Returns a TComponent enumerator.
        GetEnumerator returns a TComponentEnumerator reference, which enumerates the components contained within a specified containing component. 
        To process all these subcomponents, call the TComponentEnumerator GetCurrent method within a While MoveNext do loop."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def TrackMenu(self, Button: ToolButton) -> bool:
        """TToolBar.TrackMenu(Button: ToolButton) -> bool
        Called when the accelerator for a toolbar button is pressed.
        TrackMenu is called automatically in response to the accelerator on a toolbar button. It initializes the menu of a drop-down menu button, and forwards a click to the underlying Windows control.
        Button is the toolbar button for which an accelerator was pressed.
        Override TrackMenu in a derived class to perform additional actions when the accelerator for a toolbar button is pressed."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class ToolButton(Control):
    """Wrapper for Delphi TToolButton"""
    __hash__: ClassVar[None] = ...
    Action: BasicAction
    """BasicAction: Specifies the action associated with the control.
        Action is the action object that is associated with the control. Actions allow an application to centralize the response to user commands. When a control is associated with an action, the action determines the appropriate properties and events of the control (such as whether the control is enabled or how it responds to an OnClick event).
        To create actions at design time, place an action list component on a form or data module. Double-click the action list to bring up the action list editor. Add actions in the editor using its context menu. Once the actions have been added using the Action List editor, they appear in the drop-down list for the Action property in the Object Inspector."""
    AllowAllUp: bool
    """bool:"""
    AutoSize: bool
    """bool: Specifies whether the control sizes itself automatically to accommodate its contents.
        Use AutoSize to specify whether the control sizes itself automatically. When AutoSize is True, the control resizes automatically when its contents change.
        By default, AutoSize is False."""
    Caption: str
    """str: Specifies a text string that identifies the control to the user.
        Use Caption to specify the text string that labels the control.
        To underline a character in a Caption that labels a component, include an ampersand (&) before the character. This type of character is called an accelerator character. The user can then select the component by pressing ALT while typing the underlined character. To display an ampersand character in the caption, use two ampersands (&&).
        
        Notes:
        Controls that display text use either the Caption property or the Text property to specify the text value. The property that is used depends on the type of control. In general, Caption is used for text that appears as a window title or label, while Text is used for text that appears as the content of a control.
        For some controls, such as TButton, it is not possible to change the color of the Caption. If you want to change the color of a button caption, you should use an alternate button type such as TSpeedButton or TBitBtn instead of TButton. With either TSpeedButton or TBitBtn, you can change the color of the Caption property by using the Font property.
        For TLinkLabel, an HTML tag is declared inside the Caption property either at run time or at design time."""
    Down: bool
    """bool:"""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    DropdownMenu: PopupMenu
    """PopupMenu:"""
    EnableDropdown: bool
    """bool:"""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Grouped: bool
    """bool:"""
    Height: int
    """int: Specifies the vertical size of the control in pixels.
        Use the Height property to read or change the height of the control."""
    ImageIndex: int
    """int:"""
    ImageName: str
    """str:"""
    Indeterminate: bool
    """bool:"""
    Index: int
    """int:"""
    Marked: bool
    """bool:"""
    MenuItem: MenuItem
    """MenuItem:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    Parent: Any
    """Returns/Sets the Control Parent"""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    Style: ToolButtonStyle
    """ToolButtonStyle:"""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    Width: int
    """int: Specifies the horizontal size of the control or form in pixels.
        Use the Width property to read or change the width of the control.
        
        Note:  For tab sheet controls, changing this property at run time has no effect."""
    Wrap: bool
    """bool:"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def BringToFront(self) -> Any:
        """TControl.BringToFront()
        Puts the control in front of all other controls in its parent control."""
    def CheckMenuDropdown(self, *args, **kwargs) -> Any: ...
    def Click(self, *args, **kwargs) -> Any:
        """Respond to user click.
        Click is called automatically when the user left-clicks the control. Component or application code can call Click to simulate a user mouse click. This is often done in menu actions and hotkey handlers.
        As implemented in TControl, Click queries whether the OnClick event handler exists and is different from the OnExecute handler for the control's Action. If this is true, the OnClick event handler is called. If this is false, and the Action OnExecute event handler exists, the Action's Execute method is called. Override Click to provide additional behavior."""
    def ClientToScreen(self) -> Any:
        """TControl.ClientToScreen()
        Translates a given point from client area coordinates to global screen coordinates."""
    def Create(self, AOwner: Component) -> None:
        """TToolButton.Create(AOwner: Component) -> None
        Creates an instance of TControl.
        Calling Create constructs and initializes an instance of TControl. However, you should never attempt to instantiate a TControl. This class is intended solely as a base class from which other control classes descend and you should only call Create to instantiate one of these descendants.
        Create calls the parent constructor and initializes the control. 
        When overriding Create, always call the inherited Create method first, then proceed with the control's initialization. Remember to specify the override directive when overriding the Create method.
        
        Note:  If a control's constructor allocates resources or memory, also override the destructor to free those resources."""
    def Hide(self) -> Any:
        """TControl.Hide()
        Hides the wrapped Control"""
    def Invalidate(self) -> Any:
        """TControl.Invalidate()
        Completely repaint control."""
    def Repaint(self) -> Any:
        """TControl.Repaint()
        Forces the control to repaint its image on the screen."""
    def ScreenToClient(self) -> Any:
        """TControl.ScreenToClient()
        Converts the screen coordinates of a specified point on the screen to client coordinates."""
    def SendToBack(self) -> Any:
        """TControl.SendToBack()
        Puts a windowed control behind all other windowed controls, or puts a non-windowed control behind all other non-windowed controls."""
    def SetBounds(self, Left, Top, Width, Height) -> Any:
        """TControl.SetBounds(Left, Top, Width, Height)
        Sets the Left, Top, Width, and Height properties all at once."""
    def Show(self) -> Any:
        """TControl.Show()
        Shows the wrapped Control"""
    def Update(self) -> Any:
        """TControl.Update()
        Processes any pending paint messages immediately."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TrackBar(WinControl):
    """TTrackBar is a wrapper for a track bar control.
    Use TTrackBar to put a track bar on a form. A track bar represents a position along a continuum using a slider and, optionally, tick marks. A track bar can also display a selected range marked by triangular ticks at the starting and ending positions of the selection.
    During program execution, the slider can be moved to the desired position by dragging it with the mouse or by clicking the mouse on the bar. To use the keyboard to move the slider, press the arrow keys or the Page Up and Page Down keys."""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    BorderWidth: int
    """int: Specifies the width of the control's border.
        Use BorderWidth to get or set the width of the control's border. Graphics or text drawn by the control is clipped to the area within the border."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Frequency: int
    """int: Specifies the increment between tick marks on the track bar.
        Use Frequency to specify the spacing of the tick marks, using the logical units used by the Position property. For example, a Frequency of 5 sets a tick mark at every fifth possible increment. To provide visual feedback about the units used by the track bar, set Frequency to LineSize or PageSize.
        
        Note:  If the value of the TickStyle property is not set to tsAuto, the value of Frequency is ignored."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    LineSize: int
    """int: Indicates the amount the value of Position changes when the user presses the arrow keys.
        Use LineSize to specify the distance along the slider that represents a single unit. The current Position is marked by a slider. The right and down arrow keys increment the value of Position by LineSize, and the left and up arrow keys decrement the value of Position by LineSize.
        Use the PageSize property to set the number of ticks moved using the Page Up and Page Down keys."""
    Max: int
    """int: Specifies the maximum Position of a TTrackBar.
        Use Max to set an upper limit to the value that can be represented using the track bar. A slider indicates the current Position in a range between Min and Max."""
    Min: int
    """int: Specifies the minimum Position of a TTrackBar.
        Use Min to set a lower limit to the value that can be represented using the track bar. A slider indicates the current Position in a range between Min and Max."""
    OnChange: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    OnTracking: Callable[[Object],None]
    """Callable[[Object], None]:"""
    Orientation: TrackBarOrientation
    """TrackBarOrientation: Specifies whether the track bar is horizontal or vertical.
        Set Orientation to the desired orientation of the track bar. Orientation has these possible values: 
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        tbHorizontal
        
        
        
        The long edge of the track is parallel to the top of the form. The Min position is on the left and the Max position is on the right.
        
        
        
        
        tbVertical
        
        
        
        The long edge of the track is parallel to the side of the form. The Min position is on the top and the Max position is on the bottom."""
    PageSize: int
    """int: Specifies the amount Position is changed when the PageUp or PageDown key is pressed, or when the bar is clicked.
        Set PageSize to the distance along the track bar that corresponds to a single view. A slider marks the current Position. The Page Up key increments the value of Position by PageSize, and Page Down key decrements the value of Position by PageSize. 
        Use the LineSize property to set the number of ticks moved using the arrow keys."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    Position: int
    """int: Contains the current position of the slider of a TTrackBar.
        Read Position to determine the current value represented by the track bar. Position is a value in the range between Min and Max (inclusive). Set Position to programmatically move the slider of the track bar to a new value."""
    PositionToolTip: PositionToolTip
    """PositionToolTip: Determines the position of the (optional) Tool Tip displaying the position of the track bar.
        You can set this property to one of the following values.
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        ptNone
        
        
        
        No Tool Tip is shown.
        
        
        
        
        ptTop
        
        
        
        The Tool Tip appears at the top side of the TrackBar.
        
        
        
        
        ptBottom
        
        
        
        The Tool Tip appears at the bottom side of the TrackBar.
        
        
        
        
        ptLeft
        
        
        
        The Tool Tip appears at the left side of the TrackBar.
        
        
        
        
        ptRight
        
        
        
        The Tool Tip appears at the right side of the TrackBar.
        
        
        
        
        
        Note:  Use ptLeft and ptRight for the vertical Track Bars. Use ptTop and ptBottom for the horizontal Track Bars."""
    SelEnd: int
    """int: Specifies the position of the end point of the selection range.
        Set SelEnd to determine the length of a selection that begins at SelStart. The track bar indicates a selection range on the bar by placing special tick marks at the positions specified by the SelStart and SelEnd properties and highlighting the selected portion of the bar. 
        SelEnd must be greater than or equal to Position. If SelEnd is set to a value less than Position, Position changes to SelEnd. SelEnd must be greater than or equal to SelStart. If SelEnd is the same as SelStart, there is no selection, and the value of Position is the same as SelStart and SelEnd."""
    SelStart: int
    """int: Specifies the position of the starting point of the selection range.
        Set SelStart to determine the beginning of a selection that runs to SelEnd. The track bar indicates a selection range on the bar by placing special tick marks at the positions specified by the SelStart and SelEnd properties and highlighting the selected portion of the bar. 
        SelStart must be less than or equal to Position. If SelStart is set to a value greater than Position, Position changes to SelStart. SelStart must be less than or equal to SelEnd. If SelStart is the same as SelEnd, there is no selection, and the value of Position is the same as SelStart and SelEnd."""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    ShowSelRange: bool
    """bool: Specifies whether the track bar shows the selection range.
        If set to True, the selection range on the track bar is displayed. If set to False, the selection range is not displayed."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    SliderVisible: bool
    """bool: Specifies whether the track bar's slider is visible.
        Use SliderVisible to get or set whether the track bar's slider is visible."""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    ThumbLength: int
    """int: Specifies the length of the track bar's slider.
        Use ThumbLength to get or set the length of the track bar's slider."""
    TickMarks: TickMark
    """TickMark: Specifies the location of the tick marks.
        Set TickMarks to specify where the tick marks should be drawn. TickMarks has these possible values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        tmBottomRight
        
        
        
        Tick marks are on the bottom or right of the track bar, depending of the value of Orientation.
        
        
        
        
        tmTopLeft
        
        
        
        Tick marks are on the top or left of the track bar, depending of the value of Orientation.
        
        
        
        
        tmBoth
        
        
        
        Tick marks are on both sides of the track bar.
        
        
        
        
        If the TickStyle property is tsNone, the value of TickMarks is ignored."""
    TickStyle: TickStyle
    """TickStyle: Specifies how tick marks are placed on the track bar.
        Set TickStyle to specify whether the track bar should display tick marks, and if so, how those tick marks are set. TickStyle has these possible values:
        
        
        
        
        
        Value
        
        Meaning
        
        
        
        tsAuto
        
        
        
        Tick marks are automatically displayed at increments equal to the value of the Frequency property.
        
        
        
        
        tsManual
        
        
        
        Tick marks are displayed at the Min and Max values. Additional tick marks can be set using the SetTick method.
        
        
        
        
        tsNone
        
        
        
        No tick marks are displayed."""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def Create(self, AOwner: Component) -> None:
        """TTrackBar.Create(AOwner: Component) -> None
        Creates and initializes an instance of TTrackBar.
        Call Create to instantiate a TTrackBar object at runtime. Track bars placed on forms at design time are created automatically.
        Create allocates memory and initializes the following properties:
        ControlStyle is set to [csCaptureMouse, csClickEvents, csSetCaption].
        Frequency is set to 1.
        Height is set to 45 and Width to 150.
        LineSize is set to 1 and PageSize to 2.
        Max is set to 10 and Min to 0.
        Orientation is set to trHorizontal.
        TickMarks is set to tbBottomRight and TickStyle to tsAuto.
        TabStop is set to true."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def SetTick(self, Value: int) -> None:
        """TTrackBar.SetTick(Value: int) -> None
        Adds a tick mark to the track bar at a specified location.
        Use SetTick to place a tick mark on the bar at the position that corresponds to the Value parameter. Tick marks specified in this manner are only displayed when the TickStyle is set to tsManual."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TreeNode(Persistent):
    """Wrapper for Delphi TTreeNode"""
    __hash__: ClassVar[None] = ...
    AbsoluteIndex: int
    """int:"""
    CheckState: NodeCheckState
    """NodeCheckState:"""
    Checked: bool
    """bool:"""
    ClassName: Any
    """Returns the TObject.ClassName"""
    Count: int
    """int:"""
    Cut: bool
    """bool:"""
    Data: Pointer
    """Pointer:"""
    Deleting: bool
    """bool:"""
    DropHighlighted: bool
    """bool:"""
    DropTarget: bool
    """bool:"""
    Enabled: bool
    """bool:"""
    Expanded: bool
    """bool:"""
    ExpandedImageIndex: int
    """int:"""
    Focused: bool
    """bool:"""
    Handle: int
    """int:"""
    HasChildren: bool
    """bool:"""
    ImageIndex: int
    """int:"""
    Index: int
    """int:"""
    IsVisible: bool
    """bool:"""
    Item: TreeNode
    """TreeNode:"""
    ItemId: HREEITEM
    """HREEITEM:"""
    Level: int
    """int:"""
    OverlayIndex: int
    """int:"""
    Owner: TreeNodes
    """TreeNodes:"""
    Parent: TreeNode
    """TreeNode:"""
    Selected: bool
    """bool:"""
    SelectedIndex: int
    """int:"""
    StateIndex: int
    """int:"""
    Text: str
    """str:"""
    TreeView: CustomTreeView
    """CustomTreeView:"""
    __bound__: Any
    """Returns True if the wrapper is still bound to the Delphi instance."""
    __owned__: Any
    """Returns True if the wrapper owns the Delphi instance."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def AlphaSort(self, ARecurse: bool) -> bool:
        """TTreeNode.AlphaSort(ARecurse: bool) -> bool"""
    def Assign(self, persistent) -> Any:
        """TPersistent.Assign(persistent)
        Assigns to this object the values of another TPersistent object"""
    def Collapse(self, Recurse: bool) -> None:
        """TTreeNode.Collapse(Recurse: bool) -> None"""
    def Create(self, AOwner: TreeNodes) -> None:
        """TTreeNode.Create(AOwner: TreeNodes) -> None
        Constructs an object and initializes its data before the object is first used.
        Create constructs an object. The purpose, size, and behavior of objects differ greatly. The Create constructor defined by TObject allocates memory but does not initialize data. 
        Descendant objects usually define a constructor that creates the particular kind of object and initializes its data.
        
        Note: If an exception escapes from a constructor, the object's destructor is called to clean up the failed instance."""
    def CustomSort(self, SortProc: Callable[[int,int,int],int], Data: int, ARecurse: bool) -> bool:
        """TTreeNode.CustomSort(SortProc: Callable[[int, int, int], int], Data: int, ARecurse: bool) -> bool"""
    def Delete(self, *args, **kwargs) -> Any: ...
    def DeleteChildren(self, *args, **kwargs) -> Any: ...
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys the TPersistent instance and frees its memory.
        Do not call Destroy directly. Call Free instead. Free checks that the object reference is not nil before calling Destroy."""
    def DisplayRect(self, TextOnly: bool) -> Rect:
        """TTreeNode.DisplayRect(TextOnly: bool) -> Rect"""
    def EditText(self, *args, **kwargs) -> Any: ...
    def EndEdit(self, Cancel: bool) -> None:
        """TTreeNode.EndEdit(Cancel: bool) -> None"""
    def Expand(self, Recurse: bool) -> None:
        """TTreeNode.Expand(Recurse: bool) -> None"""
    def GetHandle(self, *args, **kwargs) -> Any: ...
    def GetLastChild(self, *args, **kwargs) -> Any: ...
    def GetNamePath(self) -> Any:
        """TPersistent.GetNamePath()
        Returns the name of the object as it appears in the Object Inspector."""
    def GetNext(self, *args, **kwargs) -> Any: ...
    def GetNextChild(self, Value: TreeNode) -> TreeNode:
        """TTreeNode.GetNextChild(Value: TreeNode) -> TreeNode"""
    def GetNextVisible(self, *args, **kwargs) -> Any: ...
    def GetPrev(self, *args, **kwargs) -> Any: ...
    def GetPrevChild(self, Value: TreeNode) -> TreeNode:
        """TTreeNode.GetPrevChild(Value: TreeNode) -> TreeNode"""
    def GetPrevVisible(self, *args, **kwargs) -> Any: ...
    def HasAsParent(self, Value: TreeNode) -> bool:
        """TTreeNode.HasAsParent(Value: TreeNode) -> bool"""
    def IndexOf(self, Value: TreeNode) -> int:
        """TTreeNode.IndexOf(Value: TreeNode) -> int"""
    def IsFirstNode(self, *args, **kwargs) -> Any: ...
    def MakeVisible(self, *args, **kwargs) -> Any: ...
    def MoveTo(self, Destination: TreeNode, Mode: NodeAttachMode) -> None:
        """TTreeNode.MoveTo(Destination: TreeNode, Mode: NodeAttachMode) -> None"""
    def getFirstChild(self, *args, **kwargs) -> Any: ...
    def getNextSibling(self, *args, **kwargs) -> Any: ...
    def getPrevSibling(self, *args, **kwargs) -> Any: ...
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class TreeView(CustomTreeView):
    """Wrapper for Delphi TTreeView"""
    __hash__: ClassVar[None] = ...
    Align: Align
    """Align: Determines how the control aligns within its container (parent control).
        Use Align to align a control to the top, bottom, left, or right of a form or panel and have it remain there even if the size of the form, panel, or component that contains the control changes. When the parent is resized, an aligned control also resizes so that it continues to span the top, bottom, left, or right edge of the parent.
        For example, to use a panel component with various controls on it as a tool palette, change the panel's Align value to alLeft. The value of alLeft for the Align property of the panel guarantees that the tool palette remains on the left side of the form and always equals the client height of the form.
        The default value of Align is alNone, which means a control remains where it is positioned on a form or panel.
        
        Tip: If Align is set to alClient, the control fills the entire client area so that it is impossible to select the parent form by clicking it. In this case, select the parent by selecting the control on the form and pressing ESC, or by using the Object Inspector.
        Any number of child components within a single parent can have the same Align value, in which case they stack up along the edge of the parent. The child controls stack up in z-order. To adjust the order in which the controls stack up, drag the controls into their desired positions.
        
        Note: To cause a control to maintain a specified relationship with an edge of its parent, but not necessarily lie along one edge of the parent, use the Anchors property instead."""
    Anchors: Anchors
    """Anchors: Specifies how the control is anchored to its parent.
        Use Anchors to ensure that a control maintains its current position relative to an edge of its parent, even if the parent is resized. When its parent is resized, the control holds its position relative to the edges to which it is anchored.
        If a control is anchored to opposite edges of its parent, the control stretches when its parent is resized. For example, if a control has its Anchors property set to [akLeft, akRight], the control stretches when the width of its parent changes.
        Anchors is enforced only when the parent is resized. Thus, for example, if a control is anchored to opposite edges of a form at design time and the form is created in a maximized state, the control is not stretched because the form is not resized after the control is created.
        
        Note: If a control should maintain contact with three edges of its parent (hugging one side of the parent and stretching the length of that side), use the Align property instead. Unlike Anchors, Align allows controls to adjust to changes in the size of other aligned sibling controls as well as changes to the parent's size."""
    AutoExpand: bool
    """bool:"""
    BevelEdges: BevelEdges
    """BevelEdges: Specifies which edges of the control are beveled.
        Use BevelEdges to get or set which edges of the control are beveled. The BevelInner, BevelOuter, and BevelKind properties determine the appearance of the specified edges."""
    BevelInner: BevelCut
    """BevelCut: Specifies the cut of the inner bevel.
        Use BevelInner to specify whether the inner bevel has a raised, lowered, or flat look. 
        The inner bevel appears immediately inside the outer bevel. If there is no outer bevel (BevelOuter is bvNone), the inner bevel appears immediately inside the border."""
    BevelKind: BevelKind
    """BevelKind: Specifies the control's bevel style.
        Use BevelKind to modify the appearance of a bevel. BevelKind influences how sharply the bevel stands out.
        BevelKind, in combination with BevelWidth and the cut of the bevel specified by BevelInner or BevelOuter, can create a variety of effects. Experiment with various combinations to get the look you want."""
    BevelOuter: BevelCut
    """BevelCut: Specifies the cut of the outer bevel.
        Use BevelOuter to specify whether the outer bevel has a raised, lowered, or flat look.
        The outer bevel appears immediately inside the border and outside the inner bevel."""
    BevelWidth: int
    """int: Specifies the width of the inner and outer bevels.
        Use BevelWidth to specify the width, in pixels, of the inner and outer bevels."""
    BiDiMode: BiDiMode
    """BiDiMode: Specifies the bidirectional mode for the control.
        Use BiDiMode to enable the control to adjust its appearance and behavior automatically when the application runs in a locale that reads from right to left instead of left to right. The bidirectional mode controls the reading order for the text, the placement of the vertical scroll bar, and whether the alignment is changed.
        Alignment does not change for controls that are known to contain number, date, time, or currency values. For example, with data-aware controls, the alignment does not change for the following field types: ftSmallint, ftInteger, ftWord, ftFloat, ftCurrency, ftBCD, ftDate, ftTime, ftDateTime, ftAutoInc."""
    BorderStyle: BorderStyle
    """BorderStyle:"""
    BorderWidth: int
    """int: Specifies the width of the control's border.
        Use BorderWidth to get or set the width of the control's border. Graphics or text drawn by the control is clipped to the area within the border."""
    ChangeDelay: int
    """int:"""
    CheckBoxes: bool
    """bool:"""
    CheckStyles: CheckStyles
    """CheckStyles:"""
    Color: int
    """int: Specifies the background color of the control.
        Use Color to read or change the background color of the control.
        If a control's Vcl.Controls.TControl.ParentColor property is True, then changing the Color property of the control's parent automatically changes the Color property of the control. When the value of the Color property is changed, the control's ParentColor property is automatically set to False.
        The Color of a TLabel is always the color of the background unless you set TLabel.Transparent to False."""
    Constraints: SizeConstraints
    """SizeConstraints: Specifies the size constraints for the control.
        Use Constraints to specify the minimum and maximum width and height of the control. When Constraints contains maximum or minimum values, the control cannot be resized to violate those constraints. 
        
        Note: Constraints apply to the height of the form. However, the height of the form depends on how large Windows makes the title bar. For example, Windows XP uses much larger title bars than other windowing systems. To work around this, note the ClientHeight when you design your form and set the constraints in the FormCreate event. In the following example, ClientHeight is represented by x: Constraints.MinHeight?:= x + Height - ClientHeight.
        Warning: Do not set up constraints that conflict with the value of the Align or Anchors property. When these properties conflict, the response of the control to resize attempts is not well-defined."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    Ctl3D: bool
    """bool: Determines whether a control has a three-dimensional (3-D) or two-dimensional look.
        Ctl3D is provided for backward compatibility. It is not used by 32-bit versions of Windows or NT4.0 and later, with the exception of Windows XP Home, where it is used on occasion.
        On earlier platforms, Ctl3D controlled whether the control had a flat or beveled appearance.
        
        
        Note RAD Studio no longer supports Windows Vista or earlier."""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    DragCursor: int
    """int: Specifies the image used to represent the mouse pointer when the control is being dragged.
        Use the DragCursor property to change the cursor image presented when the control is being dragged.
        
        Note: To make a custom cursor available for the DragCursor property, see the Cursor property."""
    DragKind: DragKind
    """DragKind: Specifies whether the control is being dragged normally or for docking.
        Use DragKind to get or set whether the control participates in drag-and-drop operations or drag-and-dock operations."""
    DragMode: DragMode
    """DragMode: Specifies how the control initiates drag-and-drop or drag-and-dock operations.
        Use DragMode to control when the user can drag the control. Disable the drag-and-drop or drag-and-dock capability at run time by setting the DragMode property value to dmManual. Enable automatic dragging by setting DragMode to dmAutomatic. For more information about dmManual and dmAutomatic, see TDragMode."""
    Enabled: bool
    """bool: Controls whether the control responds to mouse, keyboard, and timer events.
        Use Enabled to change the availability of the control to the user. To disable a control, set Enabled to False. Some disabled controls appear dimmed (for example: buttons, check boxes, labels), while others (container controls) simply lose their functionality without changing their appearance. If Enabled is set to False, the control ignores mouse, keyboard, and timer events.
        To re-enable a control, set Enabled to True.
        
        Note: This property applies to all TControl descendants."""
    Focused: Any
    """Determines whether the control has input focus."""
    Font: Font
    """Font: Specifies the attributes of text written on or in the control.
        To change to a new font, specify a new TFont object. To modify a font, change the value of the Charset, Color, Height, Name , Pitch, Size, or Style of the TFont object.
        
        Note: Changing the font color of the Caption is not supported for some controls (such as TButton). In most cases, there is an alternate control you can use whose Font property will change the color of the caption or text (such as TBitBtn or TSpeedButton)."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    HandleAllocated: Any
    """Reports whether a screen object handle exists for the control."""
    HideSelection: bool
    """bool:"""
    HotTrack: bool
    """bool:"""
    Images: CustomImageList
    """CustomImageList:"""
    Indent: int
    """int:"""
    Items: TreeNodes
    """TreeNodes:"""
    MultiSelect: bool
    """bool:"""
    MultiSelectStyle: MultiSelectStyle
    """MultiSelectStyle:"""
    OnAddition: Callable[[Object,TreeNode],None]
    """Callable[[Object, TreeNode], None]:"""
    OnAdvancedCustomDraw: Callable[[CustomTreeView,Rect,CustomDrawStage,bool],None]
    """Callable[[CustomTreeView, Rect, CustomDrawStage, bool], None]:"""
    OnAdvancedCustomDrawItem: Callable[[CustomTreeView,TreeNode,CustomDrawState,CustomDrawStage,bool,bool],None]
    """Callable[[CustomTreeView, TreeNode, CustomDrawState, CustomDrawStage, bool, bool], None]:"""
    OnCancelEdit: Callable[[Object,TreeNode],None]
    """Callable[[Object, TreeNode], None]:"""
    OnChange: Callable[[Object,TreeNode],None]
    """Callable[[Object, TreeNode], None]:"""
    OnChanging: Callable[[Object,TreeNode,bool],None]
    """Callable[[Object, TreeNode, bool], None]:"""
    OnCheckStateChanged: Callable[[CustomTreeView,TreeNode,NodeCheckState],None]
    """Callable[[CustomTreeView, TreeNode, NodeCheckState], None]:"""
    OnCheckStateChanging: Callable[[CustomTreeView,TreeNode,NodeCheckState,NodeCheckState,bool],None]
    """Callable[[CustomTreeView, TreeNode, NodeCheckState, NodeCheckState, bool], None]:"""
    OnClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnCollapsed: Callable[[Object,TreeNode],None]
    """Callable[[Object, TreeNode], None]:"""
    OnCollapsing: Callable[[Object,TreeNode,bool],None]
    """Callable[[Object, TreeNode, bool], None]:"""
    OnCompare: Callable[[Object,TreeNode,TreeNode,int,int],None]
    """Callable[[Object, TreeNode, TreeNode, int, int], None]:"""
    OnContextPopup: Callable[[Object,Point,bool],None]
    """Callable[[Object, Point, bool], None]:"""
    OnCreateNodeClass: Callable[[CustomTreeView,TreeNodeClass],None]
    """Callable[[CustomTreeView, TreeNodeClass], None]:"""
    OnCustomDraw: Callable[[CustomTreeView,Rect,bool],None]
    """Callable[[CustomTreeView, Rect, bool], None]:"""
    OnCustomDrawItem: Callable[[CustomTreeView,TreeNode,CustomDrawState,bool],None]
    """Callable[[CustomTreeView, TreeNode, CustomDrawState, bool], None]:"""
    OnDblClick: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnDeletion: Callable[[Object,TreeNode],None]
    """Callable[[Object, TreeNode], None]:"""
    OnDragDrop: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnDragOver: Callable[[Object,Object,int,int,DragState,bool],None]
    """Callable[[Object, Object, int, int, DragState, bool], None]:"""
    OnEdited: Callable[[Object,TreeNode,str],None]
    """Callable[[Object, TreeNode, str], None]:"""
    OnEditing: Callable[[Object,TreeNode,bool],None]
    """Callable[[Object, TreeNode, bool], None]:"""
    OnEndDock: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEndDrag: Callable[[Object,Object,int,int],None]
    """Callable[[Object, Object, int, int], None]:"""
    OnEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExit: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnExpanded: Callable[[Object,TreeNode],None]
    """Callable[[Object, TreeNode], None]:"""
    OnExpanding: Callable[[Object,TreeNode,bool],None]
    """Callable[[Object, TreeNode, bool], None]:"""
    OnGesture: Callable[[Object,GestureEventInfo,bool],None]
    """Callable[[Object, GestureEventInfo, bool], None]:"""
    OnGetImageIndex: Callable[[Object,TreeNode],None]
    """Callable[[Object, TreeNode], None]:"""
    OnGetSelectedIndex: Callable[[Object,TreeNode],None]
    """Callable[[Object, TreeNode], None]:"""
    OnHint: Callable[[Object,TreeNode,str],None]
    """Callable[[Object, TreeNode, str], None]:"""
    OnKeyDown: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnKeyPress: Any
    """Callable[[Object, unicodechr(str)], None]:"""
    OnKeyUp: Callable[[Object,int,ShiftState],None]
    """Callable[[Object, int, ShiftState], None]:"""
    OnMouseActivate: Callable[[Object,MouseButton,ShiftState,int,int,int,MouseActivate],None]
    """Callable[[Object, MouseButton, ShiftState, int, int, int, MouseActivate], None]:"""
    OnMouseDown: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnMouseEnter: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseLeave: Callable[[Object],None]
    """Callable[[Object], None]:"""
    OnMouseMove: Callable[[Object,ShiftState,int,int],None]
    """Callable[[Object, ShiftState, int, int], None]:"""
    OnMouseUp: Callable[[Object,MouseButton,ShiftState,int,int],None]
    """Callable[[Object, MouseButton, ShiftState, int, int], None]:"""
    OnStartDock: Callable[[Object,DragDockObject],None]
    """Callable[[Object, DragDockObject], None]:"""
    OnStartDrag: Callable[[Object,DragObject],None]
    """Callable[[Object, DragObject], None]:"""
    ParentBiDiMode: bool
    """bool: Specifies whether the control uses its parent's BiDiMode.
        Use ParentBiDiMode to get or set whether the control uses its parent's BiDiMode. When ParentBiDiMode is true, the control's BiDiMode property is always equal to that of its parent. If ParentBiDiMode is false, the control uses its own BiDiMode property.
        Set ParentBiDiMode to true for all controls in a form to ensure that the entire user interface adjusts to Middle Eastern locales in a uniform manner.
        When the value of the control's BiDiMode property changes, ParentBiDiMode becomes false automatically."""
    ParentColor: bool
    """bool: Specifies where a control looks for its color information.
        To have a control use the same color as its parent control, set ParentColor to True. If ParentColor is False, the control uses its own Color property.
        Set ParentColor to True for all controls to ensure that all the controls on a form have a uniform appearance. For example, if ParentColor is True for all controls in a form, changing the background color of the form to gray causes all the controls on the form to also have a gray background.
        When the value of a control's Color property changes, ParentColor becomes False automatically."""
    ParentCtl3D: bool
    """bool: Determines where a component looks to determine whether it should have a three-dimensional look.
        ParentCtl3D is provided for backwards compatibility. It has no effect on 32-bit versions of Windows or NT 4.0 and later.
        ParentCtl3D determines whether the control uses its parent's Ctl3D property."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentFont: bool
    """bool: Specifies where a control looks for its font information.
        To have a control use the same font as its parent control, set ParentFont to true. If ParentFont is false, the control uses its own Font property. Many controls default ParentFont to true so that all the controls in a form or other container present a uniform appearance. When the value of a control's Font property changes, ParentFont becomes false automatically.
        When ParentFont is true for a form, the form uses the default font. Currently, the default font is Tahoma 8 pt."""
    ParentShowHint: bool
    """bool: Specifies where a control looks to find out if its Help Hint should be shown.
        Use ParentShowHint to ensure that all the controls on a form either uniformly show their Help Hints or uniformly do not show them. 
        If ParentShowHint is True, the control uses the ShowHint property value of its parent. If ParentShowHint is False, the control uses the value of its own ShowHint property.
        To provide Help Hints only for selected controls on a form, set the ShowHint property for those controls that should have Help Hints to True, and ParentShowHint becomes False automatically.
        
        Note:  Enable or disable all Help Hints for the entire application using the ShowHint property of the application object."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PopupMenu: PopupMenu
    """PopupMenu: Specifies the pop-up menu associated with the control.
        Assign a value to PopupMenu to make a pop-up menu appear when the user selects the control and clicks the right mouse button. If the TPopupMenu's AutoPopup property is True, the pop-up menu appears automatically. If the menu's AutoPopup property is False, display the menu with a call to its Popup method from the control's OnContextPopup event handler."""
    ReadOnly: bool
    """bool:"""
    RightClickSelect: bool
    """bool:"""
    RowSelect: bool
    """bool:"""
    ShowButtons: bool
    """bool:"""
    ShowHint: bool
    """bool: ShowHint specifies whether to show the Help Hint when the mouse pointer moves over the control.
        ShowHint determines whether the Help Hint appears for the control. The Help Hint is the value of the TControl.Hint property. The Help Hint appears in a box just beneath the control when the mouse pointer moves over the control. 
        To enable Help Hints for a particular control, two conditions must be satisfied:
        
        The application's ShowHint property must be True.
        Either the control's own ShowHint property must be True, or the control's ParentShowHint property must be True and its parent's ShowHint property must be True.
        For example, imagine a check box within a group box. If the ShowHint property of the group box is True and the ParentShowHint property of the check box is True, but the ShowHint property of the check box is False, the check box still displays its Help Hint.
        Changing the ShowHint value automatically sets the ParentShowHint property to False."""
    ShowLines: bool
    """bool:"""
    ShowRoot: bool
    """bool:"""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    SortType: SortType
    """SortType:"""
    StateImages: CustomImageList
    """CustomImageList:"""
    StyleElements: StyleElements
    """StyleElements: Specifies the style elements that are used by the control.
        Use StyleElements to customize the style of the control. If a custom style is enabled, you can enable or disable style elements in the control.
        StyleElements is a set of values that specify which elements of the current style are to be applied to this control. By default, all the elements of the style are enabled."""
    StyleName: str
    """str: Embarcadero Technologies does not currently have any additional information."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    ToolTips: bool
    """bool:"""
    Touch: TouchManager
    """TouchManager: Specifies the touch manager component associated with the control.
        Use the Touch property to access gesturing options associated with a control. Touch specifies a class of type TTouchManager. 
        Touch is used to: 
        
        Associate a TGestureManager.
        (TGestureManager manages all the gestures that can be used by the control.)
        Select the standard, interactive, or custom gestures to associate with the control.
        (You can also connect each gesture to an action; see Assigning Actions to Gestures.)
        Specify a set of options for interactive or tablet gestures."""
    Visible: bool
    """bool: Specifies whether the component appears onscreen.
        Use the Visible property to control the visibility of the control at run time. If Visible is True, the control appears. If Visible is False, the control is not visible.
        Calling the Show method sets the control's Visible property to True. Calling the Hide method sets it to False.
        For TCustomForm descendants, the Show and ShowModal methods set Visible to True and bring the form to the front of all open windows.
        For TTabSheet descendants, Visible does not control the visibility of the control at run time. For more information, see the description of the TabVisible property."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class VarParameter:
    """Container object allowing modification of Delphi var parameters from Python"""
    __hash__: ClassVar[None] = ...
    Value: Any
    """Provides access to the Value associated with the Var parameter"""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

class WinControl(Control):
    '''TWinControl is the base class for all controls that are wrappers for Microsoft Windows screen objects.
    TWinControl provides the common functionality for all controls that act as wrappers for Microsoft Windows screen objects ("windows"). Controls that are wrap underlying windows have the following features:
    
    The control can incorporate the functionality of an underlying window. For example, if the underlying screen object is a text editor, the control can incorporate the editor ability to manage and display a text buffer.
    The control can receive user input focus. The focused control can handle keyboard input events. Some controls change their appearance when they have the focus. For example, button controls typically indicate the focus by drawing a rectangle around the caption.
    The control can serve as a container for other controls, referred to as child controls. This relationship is signified by the child\'s Parent property. Container controls provide important services to their children, including display services for controls that do not implement their own canvases. Examples of container controls include forms, panels, and toolbars.
    Controls based on TWinControl can display standard screen objects provided by Microsoft Windows, or customized screen objects developed by the VCL programmer.
    Descendants of TWinControl include abstract base classes that support most kinds of user interface objects. The most significant descendant is TCustomControl, which provides code to implement a canvas and handle paint messages. Other important abstract descendants include TScrollingWinControl, TButtonControl, TCustomComboBox, TCustomEdit, and TCustomListBox. When defining new control classes, consider these descendants before deriving directly from TWinControl.
    Every TWinControl object has a Handle property which provides the window handle for the underlying Microsoft Windows screen object. Use the Handle property to bypass the VCL API and directly access the underlying window.'''
    __hash__: ClassVar[None] = ...
    AlignDisabled: bool
    """bool: Indicates child control realignment disabled.
        AlignDisabled returns true if child control realignment has been temporarily disabled by a call to DisableAlign."""
    Brush: Brush
    """Brush: Determines the color and pattern used for painting the background of the control.
        The Brush property accesses the TBrush object that determines pattern and color for the control background. Brush is a read-only property, but an application can manipulate the TBrush object by setting its properties or by using its Assign method."""
    ControlCount: Any
    """Returns the count of contained controls"""
    Controls: Any
    """Returns an iterator over contained controls"""
    DockClientCount: int
    """int: Specifies the number of controls that are docked on the windowed control.
        Use DockClientCount to get the number of controls that are docked to the windowed control. This value can be used as an upper bound when iterating through the DockClients property.
        
        Note:  The DockClients property can contain controls that are not visible. To get the number of docked clients that are visible, use the VisibleDockClientCount property instead."""
    DockClients: Control
    """Control:"""
    DockManager: IDockManager
    """IDockManager: Specifies the control's docking manager interface.
        Use DockManager to specify the control's docking manager. The docking manager handles the layout of docking zones (where controls are docked) and any painting associated with docking zones.
        If you set DockSite and UseDockManager to true, but do not assign a value to DockManager, the windowed control generates a default docking manager, using the global DefaultDockTreeClass variable."""
    DockSite: bool
    """bool: Specifies whether the control can be the target of drag-and-dock operations.
        Set DockSite to true to allow other controls to be docked to this windowed control.
        
        Code Examples
        Docking (Delphi)
        Docking (C++)"""
    DoubleBuffered: bool
    """bool: Determines whether the control's image is rendered directly to the window or painted to an in-memory bitmap first.
        When DoubleBuffered is false, the windowed control paints itself directly to the window. When DoubleBuffered is true, the windowed control paints itself to an in-memory bitmap that is then used to paint the window. Double buffering reduces the amount of flicker when the control repaints, but is more memory intensive.
        When a windowed control is a dock site and has an associated dock manager, it must be double-buffered.
        
        Note:  Some controls, such as TRichEdit, can't paint themselves into a bitmap. For such controls, DoubleBuffered must be set to false."""
    Handle: Any
    """Provides access to the underlying Windows screen object for the control."""
    IsDrawingLocked: bool
    """bool: IsDrawingLocked property returns True when redrawing for this control is locked.  It is True when the number of LockDrawing calls is less than UnlockDrawing calls for this control."""
    MouseInClient: bool
    """bool: Indicates whether the mouse pointer is currently in the client area of the control.
        Use MouseInClient to check whether the mouse pointer is currently located in the client area of the control. MouseInClient is also used internally to fire the OnMouseEnter and OnMouseLeave events."""
    Padding: Padding
    """Padding: Specifies the padding of a control.
        Use Padding to specify the padding of a control. This value is an instance of the class TPadding."""
    ParentDoubleBuffered: bool
    """bool: ParentDoubleBuffered defers the DoubleBuffered property of this component to the value of the parent's DoubleBuffered property.
        ParentDoubleBuffered is a boolean indicating that the DoubleBuffered property of this component is overridden by the value of the parent's DoubleBuffered property."""
    ParentWindow: Any
    """Reference to parent's underlying control."""
    PixelsPerInch: int
    """int: Embarcadero Technologies does not currently have any additional information."""
    RedrawDisabled: bool
    """bool: RedrawDisabled property returns True when redrawing for this control is locked.  It is similar to IsDrawingLocked, but uses Win32 API to determine when a Win32 window redrawing is disabled. 
        For example, when a parent control redrawing is locked using LockDrawing, then IsDrawingLocked returns True for parent control and False for child control. RedrawDisabled returns True for both parent and child controls."""
    Showing: Any
    """Indicates whether the control is showing on the screen."""
    TabOrder: int
    """int: Indicates the position of the control in its parent's tab order.
        TabOrder is the order in which child windows are visited when the user presses the Tab key. The control with the TabOrder value of 0 is the control that has the focus when the form first appears.
        Initially, the tab order is always the order in which the controls were added to the form. The first control added to the form has a TabOrder value of 0, the second is 1, the third is 2, and so on. Change this by changing the TabOrder property.
        Each control has a unique tab-order value within its parent. If you change the TabOrder property value of one control to be the same as the value of a second control, the TabOrder value for all the other controls changes. For example, suppose a control is sixth in the tab order. If you change the control's TabOrder property value to 3 (making the control fourth in the tab order), the control that was originally fourth in the tab order now becomes fifth, and the control that was fifth becomes sixth.
        Assigning TabOrder a value greater than the number of controls contained in the parent control moves the control to the end of the tab order. The control does not take on the assigned value of TabOrder, but instead is given the number that assures the control is the last in the tab order.
        
        Note: TabOrder is meaningful only if the TabStop property is True and if the control has a parent. (The TabOrder property of a form is not used unless the form is the child of another form.) A control with a TabOrder of -1 has no parent, and therefore cannot be reached by pressing the Tab key. To remove a parented control from the Tab order, set its TabStop property to False."""
    TabStop: bool
    """bool: Determines whether the user can tab to a control.
        Use the TabStop to allow or disallow access to the control using the Tab key.
        If TabStop is True, the control is in the tab order. If TabStop is False, the control is not in the tab order and the user cannot press the TAB key to move to the control. 
        
        Note: TabStop is not meaningful for a form unless the form assigns another form to be its parent."""
    UseDockManager: bool
    """bool: Specifies whether the docking manager is used in drag-and-dock operations.
        Use UseDockManager to get or set whether a docking manager is used in drag-and-dock operations. 
        The docking manager handles the positioning of docked controls and any painting of docking zones around those controls. If you do not use a docking manager, docked controls are aligned to the windowed control based on the closest edge to where they are released. When you do not use a docking manager, there is no region for a user to grab to automatically undock a docked control."""
    VisibleDockClientCount: int
    """int: Specifies the number of visible controls that are docked on the windowed control.
        Use VisibleDockClientCount to determine the number of controls in the DockClients list that have a Visible property value of true. This value is less than or equal to the value of DockClientCount."""
    def __init__(self, *args, **kwargs) -> None:
        """Initialize self.  See help(type(self)) for accurate signature."""
    def Broadcast(self, Message) -> None:
        """TWinControl.Broadcast(Message) -> None
        Sends a message to each of the child controls.
        Use Broadcast when you want to send the same message to each of the child controls contained within the windowed control. Specify the message to be passed as the value of the Message parameter."""
    def CanFocus(self) -> Any:
        """TWinControl.CanFocus()
        Indicates whether a control can receive focus."""
    def ContainsControl(self, Control: Control) -> bool:
        """TWinControl.ContainsControl(Control: Control) -> bool
        Indicates whether a specified control exists within the control.
        Use ContainsControl to find out if a particular control exists within this control. ContainsControl returns true if the specified value of the Control parameter is a child control of this control. The Control parameter need not be an immediate child (in the Controls property), but may be contained in a child of the control, or in a child of a child of the control, for indefinitely many levels deep.
        If the method returns false, the specified control is not within the control."""
    def ControlAtPos(self, Pos: Point, AllowDisabled: bool, AllowWinControls: bool, AllLevels: bool) -> Control:
        """TWinControl.ControlAtPos(Pos: Point, AllowDisabled: bool, AllowWinControls: bool, AllLevels: bool) -> Control
        Returns the child control located at a specified position within the control.
        Use ControlAtPos to determine which child control is at the specified location within the control. ControlAtPos returns an immediate child of the control; that is, one of the entries of the Controls property, that has this control for its Parent property.
        Specify the position in client coordinates as the value of the Pos parameter. Pos can be anywhere within the boundaries of the child control, not just the upper left corner.
        The AllowDisabled parameter determines whether the search for controls includes disabled controls.
        The AllowWinControls parameter determines whether descendants of TWinControl are considered when looking for the child control.
        If there is no control that matches the AllowDisabled and AllowWinControls parameters at the specified position, ControlAtPos returns nil (Delphi) or NULL (C++)."""
    def Create(self, AOwner: Component) -> None:
        """TWinControl.Create(AOwner: Component) -> None
        Creates an instance of TWinControl.
        Call Create to construct and initialize a new control and insert the newly-constructed control into its owner, as specified by the AOwner parameter. Create inserts the control in the owner by calling the owner's InsertComponent method. 
        Most controls override Create to initialize their unique properties. Objects that override the Create method must always call the inherited Create method first, and then proceed with the component-specific initialization. Specify the override directive when overriding the Create method.
        If a component's Create method allocates resources or memory, override the Destroy method to free those resources."""
    def CreateParented(self, ParentWindow: int) -> None:
        """TWinControl.CreateParented(ParentWindow: int) -> None"""
    @classmethod
    def CreateParentedControl(cls, ParentWindow: int) -> WinControl:
        """TWinControl.CreateParentedControl(ParentWindow: int) -> WinControl
        Creates and initializes a control as the child of a specified non-VCL window.
        Call CreateParentedControl to embed a new control in a non-VCL parent. 
        CreateParentedControl allocates memory for a new instance of the same class as the control (Delphi) or is the class specified by the vmt parameter (C++), sets its ParentWindow property to ParentWindow, and calls the constructor, passing in nil (Delphi) or NULL (C++) for the Owner parameter. CreateParentedControl returns the newly created control.
        CreateParentedControl has the same purpose as CreateParented, but is a simple class function instead of a constructor. Unlike CreateParented, CreateParentedControl can be called from C++ code."""
    def DefaultHandler(self, Message) -> None:
        """TWinControl.DefaultHandler(Message) -> None
        Provides message handling for all messages that the control does not fully process by itself.
        Override DefaultHandler to change the default message handling for the control. The Message parameter can be cast to a TMessage type, to obtain the WParam, LParam, and Result of the message. If the Result of the message is non-zero, the message has already been handled. Set the Result field to a non-zero value to prevent further processing of the message by the inherited method.
        
        Note:  In Delphi code, calling inherited in a message-handling method results in a call to the ancestor's DefaultHandler method unless that ancestor specifies an explicit handler for the message. 
        TWinControl overrides the TControl DefaultHandler method to handle messages for all its descendant types. DefaultHandler passes any otherwise-unhandled messages to the control's window procedure using the CallWindowProc API function."""
    def Destroy(self, *args, **kwargs) -> Any:
        """Destroys an instance of TWinControl.
        Do not call Destroy directly in an application. Instead, call Free. Free verifies that the TWinControl reference is not nil, and only then calls Destroy."""
    def DisableAlign(self, *args, **kwargs) -> Any:
        """Disables the realignment of child controls.
        Call DisableAlign to temporarily prevent child controls from realigning. For example, while performing multiple manipulations of controls, such as reading from a form file or scaling, performance improves if child controls are not realigned until all manipulations are complete. The EnableAlign method restores normal child realignment.
        Every call to DisableAlign must be followed by a matching call to EnableAlign. If an exception could be raised after the call to DisableAlign, use an exception block to ensure that EnableAlign will always be called.
        DisableAlign/EnableAlign call sequences can be nested. An internal counter records the level of nesting. As long as the counter is positive, realignment is disabled and the AlignDisabled property returns true. Once the counter returns to zero, realignment is enabled and AlignDisabled returns false."""
    def DockDrop(self, Source: DragDockObject, X: int, Y: int) -> None:
        """TWinControl.DockDrop(Source: DragDockObject, X: int, Y: int) -> None
        Generates an OnDockDrop event.
        DockDrop is called automatically when a control is docked to the windowed control. It instructs the control that is being dropped to prepare for the dock operation and then generates an OnDockDrop event.
        Although you can override DockDrop to perform actions in addition to the generated OnDockDrop event, typically descendant classes override the DoAddDockClient method instead. This is because DoAddDockClient is called by the client after it has performed its own preparations, but before the OnDockDrop event.
        DockDrop is called only if DockSite is True."""
    def EnableAlign(self, *args, **kwargs) -> Any:
        """Decrements the reference count incremented by the DisableAlign method, eventually realigning the child controls.
        Call EnableAlign to allow child controls within the control to realign again after they were prevented from realigning by a call to DisableAlign. 
        Each time the DisableAlign method is called, it increments a reference count. Each time EnableAlign is called, it decrements the same reference count. When the reference count reaches zero, EnableAlign calls the Realign method to perform any pending realignments.
        Be sure to pair each call to DisableAlign with a call to EnableAlign. If an exception could be raised after the call to DisableAlign, use an exception block to ensure that the corresponding call to EnableAlign is executed."""
    def FindChildControl(self, ControlName: str) -> Control:
        """TWinControl.FindChildControl(ControlName: str) -> Control
        Returns a child control given its name.
        Call FindChildControl to locate a specified child control. FindChildControl searches the control's children and returns the control with the specified name. If no child controls match the specified name, FindChildControl returns nil (Delphi) or NULL (C++).
        
        Note: FindChildControl only locates immediate children of the control. It can't find a control that is a child of one of the control's children."""
    def FlipChildren(self, AllLevels: bool) -> None:
        """TWinControl.FlipChildren(AllLevels: bool) -> None
        Reverses the positions of child controls.
        Call FlipChildren to flip the control's children; that is, to move children on the left side of the control to the right side and vice versa. FlipChildren reverses the position of all child controls and adjusts their Align properties, if necessary, to enforce the new position.
        AllLevels specifies whether FlipChildren should be called recursively on the control's children.
        FlipChildren can be used to reverse the layout of an application when it is running in Middle Eastern locales where users read from right to left instead of left to right: Call UseRightToLeftAlignment to determine whether the BiDiMode property dictates a reversal of alignment based on the system locale.
        
        Note: FlipChildren does the same thing as the Flip Children command on the control's context menu in the IDE."""
    def Focused(self, *args, **kwargs) -> Any:
        """Determines whether the control has input focus.
        Use the Focused method to see if the control is the active control. When Focused returns true, the control has the input focus. If Focused returns false, the user cannot interact with the control."""
    def GetChildren(self, Proc: Callable[[Component],None], Root: Component) -> None:
        """TWinControl.GetChildren(Proc: Callable[[Component], None], Root: Component) -> None
        Calls a specified method for each child of the control.
        GetChildren is called by the streaming system that loads and saves components. Applications seldom need to call this routine.
        GetChildren executes the callback specified by the Proc parameter for every child control listed by the Controls property that lists the Root parameter as its Owner.
        Override GetChildren to limit or augment which child controls are saved with the control. When overriding GetChildren, call the procedure passed as the Proc parameter for every child control that should be saved. The Root parameter indicates the component (usually a form) that owns the control."""
    def GetTabControlList(self, List: List) -> None:
        """TWinControl.GetTabControlList(List: List) -> None
        Builds a list of owned controls.
        Call GetTabControlList to construct a list of child controls.
        GetTabControlList iterates through the control's internal tab order list, adding each of the child controls to List. The result is a list of all the owned controls in TabOrder."""
    def GetTabOrderList(self, List: List) -> None:
        """TWinControl.GetTabOrderList(List: List) -> None
        Builds a list of controls in tab order.
        Call GetTabOrderList to construct a list of child controls in tab order.
        GetTabOrderList iterates through the control's internal tab order list, adding each of the child controls to List, including any controls contained in those controls. The result is a list of all the controls and their owned controls, in tab order.
        The FindNextControl method calls GetTabOrderList to build a complete list of the controls that FindNextControl uses to locate the next control in the tab order."""
    def HandleAllocated(self, *args, **kwargs) -> Any:
        """Reports whether a screen object handle exists for the control.
        Query HandleAllocated to find out if the control's underlying screen object has been generated.
        If the screen object exists, HandleAllocated returns true. If the screen object does not exist, HandleAllocated returns false. Testing the Handle property of a control directly causes the window to be created if it does not already exist. Call the HandleAllocated method to determine whether a window exists without creating one as a side effect."""
    def HandleNeeded(self, *args, **kwargs) -> Any:
        """Creates a screen object for the control if it doesn't already exist.
        Call HandleNeeded to create a screen object for the control.
        If the screen object does not exist, HandleNeeded calls the CreateHandle method for the parent of the control before it creates a screen object for this control."""
    def InsertControl(self, AControl: Control) -> None:
        """TWinControl.InsertControl(AControl: Control) -> None
        Inserts a control into the Controls array property.
        Applications should not need to call InsertControl directly. Child controls are automatically inserted and removed when added or deleted at design time. At run time, use the Parent property of the child control to insert it in the Controls array. If the child control is already the child of another control, setting the Parent property ensures that the child is removed from the Controls of the original parent.
        InsertControl makes the inserted control a child, and the containing control the parent. The AControl parameter is the child control that is inserted into the Controls array."""
    def Invalidate(self, *args, **kwargs) -> Any:
        """Schedules a control repaint.
        Invalidate informs a control that its entire surface needs to be repainted. Calling Invalidate can prevent flicker caused by a series of partial repaints. There is no performance penalty for calling Invalidate multiple times before the control is actually repainted.
        The actual repaint does not occur until the control is updated. To force an immediate repaint, call Repaint instead."""
    def LockDrawing(self, *args, **kwargs) -> Any:
        """Call LockDrawing method to prevent changes in that control from being redrawn. To resume redrawing call UnlockDrawing method. If to recreate a window handle after a LockDrawing call, the control will remain locked until the corresponding UnlockDrawing call. 
        LockDrawing / UnlockDrawing calls may be nested."""
    def PaintTo(self, DC: int, X: int, Y: int) -> None:
        """TWinControl.PaintTo(DC: int, X: int, Y: int) -> None
        Draws the windowed control to a device context.
        Call PaintTo to draw the control on a device context. Specify the device context as the value of the DC parameter and specify the X and Y coordinates on the device context where the top-left corner of the windowed control is to be drawn. PaintTo first erases the background of the device context and then paints the control.
        PaintTo is useful for drawing an image of the control into a bitmap DC.
        
        Warning:  When using PaintTo to draw on a canvas, you must lock the canvas first (and unlock it after the call to PaintTo. If you do not lock the canvas, Windows calls that occur while the control is painting can cause the canvas to lose its handle.\r
        Draws the windowed control to a device context.
        Call PaintTo to draw the control on a device context. Specify the device context as the value of the DC parameter and specify the X and Y coordinates on the device context where the top-left corner of the windowed control is to be drawn. PaintTo first erases the background of the device context and then paints the control.
        PaintTo is useful for drawing an image of the control into a bitmap DC.
        
        Warning:  When using PaintTo to draw on a canvas, you must lock the canvas first (and unlock it after the call to PaintTo. If you do not lock the canvas, Windows calls that occur while the control is painting can cause the canvas to lose its handle."""
    def PreProcessMessage(self, Msg: tagMSG) -> bool:
        """TWinControl.PreProcessMessage(Msg: tagMSG) -> bool
        Returns False, no matter the value of Msg.
        As a member of the TWinControl class, PreProcessMessage always returns False, no matter the value of Msg.
        
        Note:  When overriding PreProcessMessage in descendant classes, we recommend to implement it such that it returns True if Msg is a preprocess message, and False otherwise."""
    def Realign(self, *args, **kwargs) -> Any:
        """Forces the control to realign children.
        The EnableAlign method calls Realign when the reference count reaches zero. It adjusts the size and position of any child controls according to their Align properties.
        If all of the child controls have their Align properties set to alNone, Realign has no effect."""
    def RemoveControl(self, AControl: Control) -> None:
        """TWinControl.RemoveControl(AControl: Control) -> None
        Removes a specified control from the Controls array.
        RemoveControl removes a child control from the Controls property. After calling RemoveControl, the control is no longer the parent of the child specified by the AControl parameter. 
        Applications should not call RemoveControl directly. Child controls are automatically inserted and removed when added or deleted at design time. At runtime, use the Parent property of the child control to remove it from the Controls array."""
    def Repaint(self, *args, **kwargs) -> Any:
        """Repaints the entire control.
        Call Repaint to repaint the control.
        As implemented in TWinControl, Repaint calls the Invalidate method and then the Update method to repaint the control."""
    def ScaleBy(self, M: int, D: int) -> None:
        """TWinControl.ScaleBy(M: int, D: int) -> None
        Rescale control and its children.
        ScaleBy resizes a control without moving its upper left corner. This is similar to changing the Height and Width properties, but the control also attempts to rescale and rearrange any child controls to maintain their relative size and placement.
        The M and D parameters define a multiplier and divisor by which to scale the control. For example, to make a control 75% of its original size, specify the value of M as 75, and the value of D as 100. Any pair of values that has the same ratio has the same effect. Thus M = 3 and D = 4 also makes the control 75% of its previous size.
        To rescale the control's children without rescaling the control itself, use ScaleControls."""
    def ScaleForPPI(self, NewPPI: int) -> None:
        """TWinControl.ScaleForPPI(NewPPI: int) -> None
        Embarcadero Technologies does not currently have any additional information."""
    def ScrollBy(self, DeltaX: int, DeltaY: int) -> None:
        """TWinControl.ScrollBy(DeltaX: int, DeltaY: int) -> None
        Scroll control contents.
        Call ScrollBy to scroll the contents within the control. While ScrollBy can be used for any TWinControl, it makes the most sense to use it for descendants of TScrollingWinControl.
        Applications seldom need to call the ScrollBy method unless they implement their own scrolling interface rather than relying on a scroll bar.
        The DeltaX parameter is the change in pixels along the X axis. A positive DeltaX value scrolls the contents to the right; a negative value scrolls the contents to the left. The DeltaY parameter is the change in pixels along the Y axis. A positive DeltaY value scrolls the contents down; a negative value scrolls the contents up."""
    def SetBounds(self, ALeft: int, ATop: int, AWidth: int, AHeight: int) -> None:
        """TWinControl.SetBounds(ALeft: int, ATop: int, AWidth: int, AHeight: int) -> None
        Sets the windowed control's boundary properties all at once.
        Use SetBounds to change all of the control's boundary properties at once. The same effect can be achieved by setting the Left, Top, Width, and Height properties separately. By setting all four properties at once, SetBounds ensures that the control will not repaint between changes
        Specify the values for the Left, Top, Width, and Height properties as the value of the ALeft, ATop, AWidth, and AHeight parameters, respectively."""
    def SetDesignVisible(self, Value: bool) -> None:
        """TWinControl.SetDesignVisible(Value: bool) -> None
        Makes a control visible at design time.
        Vcl.Controls.TWinControl.SetDesignVisible inherits from Vcl.Controls.TControl.SetDesignVisible. All content below this line refers to Vcl.Controls.TControl.SetDesignVisible.
        Makes a control visible at design time.
        SetDesignVisible is used internally by Delphi during form design."""
    def SetFocus(self) -> Any:
        """TWinControl.SetFocus()
        Gives the input focus to the control."""
    def UnlockDrawing(self, *args, **kwargs) -> Any:
        """Call UnlockDrawing method to allow changes in that control to be redrawn. 
        LockDrawing / UnlockDrawing calls may be nested."""
    def Update(self, *args, **kwargs) -> Any:
        """Forces the control to update.
        Update repaints any part of the control surface that is out of date. Normally, updates occur automatically, but an Update call may be necessary before lengthy processing that might interfere with automatic updates. Calling Update unnecessarily can increase overhead and cause screen flicker.
        Update only repaints areas of the control the have been determined to be out of date. To force immediate repainting of the entire control, call the Repaint method. To notify a control that it is out of date (without forcing an immediate repaint), call the Invalidate method."""
    def UpdateControlState(self, *args, **kwargs) -> Any:
        """Respond to state change.
        UpdateControlState is called automatically when any display change occurs that might affect the internal state of the control.
        As implemented in TWinControl, UpdateControlState climbs the chain of parent controls to verify that each control in the chain has Showing equal to true. If this is the case, UpdateControlState makes sure that the Showing property is accurate for this control and for all its descendants. Descendant classes can extend this behavior."""
    def __contains__(self, other) -> bool:
        """Return key in self."""
    def __delattr__(self, name) -> Any:
        """Implement delattr(self, name)."""
    def __eq__(self, other) -> bool:
        """Return self==value."""
    def __ge__(self, other) -> bool:
        """Return self>=value."""
    def __getitem__(self, index) -> Any:
        """Return self[key]."""
    def __gt__(self, other) -> bool:
        """Return self>value."""
    def __iter__(self) -> Any:
        """Implement iter(self)."""
    def __le__(self, other) -> bool:
        """Return self<=value."""
    def __len__(self) -> int:
        """Return len(self)."""
    def __lt__(self, other) -> bool:
        """Return self<value."""
    def __ne__(self, other) -> bool:
        """Return self!=value."""
    def __setattr__(self, name, value) -> Any:
        """Implement setattr(self, name, value)."""

def Abort() -> Any:
    """Abort()
    Raises a silent exception."""
def CreateComponent(ComponentClass, Owner) -> Any:
    """CreateComponent(ComponentClass, Owner)
    Creates a component of type ComponentClass owned by Owner"""
def FreeConsole(*args, **kwargs) -> Any:
    """FreeConsole_Wrapper()
    Frees the MS-DOS console associated with the process."""
def GetProcessDpiAwareness() -> Any:
    """GetProcessDpiAwareness()
    Get the DPI awareness of the process."""
def IsDpiAware(*args, **kwargs) -> Any:
    """IsDPIAware()
    Check for process DPI awareness."""
def SetHighDpiAware() -> Any:
    """SetHighDpiAware()
    Automatically set the DPI awareness that best fits to the process."""
def SetProcessDpiAwareness() -> Any:
    """SetProcessDpiAwareness()
    Set the DPI awareness to the process."""
def ShowMessage(*args, **kwargs) -> Any:
    """ShowMessage_Wrapper()
    Show a custom message as a dialog box."""
def StyleServices(*args, **kwargs) -> Any:
    """StyleServices_Wrapper()
    Get a StyleServices instance."""
